{"version":3,"sources":["Connector.jsx","Toolbar.js","App.js","index.js"],"names":["Connector","getConnectorPoints","stuff","points","from","to","point","mouseX","mouseY","type","attrs","name","includes","dy","y","height","dx","x","width","angle","Math","atan2","PI","fromTextHeight","textHeight","fromTextWidth","textWidth","origin","radiusX","cos","radiusY","sin","outerRadius","toTextHeight","toTextWidth","dy1","dx1","console","log","endPoint","this","props","current","arrowEndX","arrowEndY","toSend","react_default","a","createElement","ReactKonva","strokeWidth","stroke","fill","Component","ToolBar","shadowBlur","shadowColor","Toolbar","state","arrowDraggable","previousShape","undefined","count","isDragging","_this2","Fragment","layer","Toolbar_ToolBar","draggable","ref","onDragEnd","e","ellipseName","target","rotation","appendToEllipses","refs","draggableEllipse","position","rectName","useImage","appendToRectangles","draggableRect","innerRadius","numPoints","starName","appendToStars","draggableStar","fontSize","text","fontFamily","textName","draggableText","appendToTexts","onDragStart","draggableArrow","setAttr","onDragMove","pos","getStage","getPointerPosition","shape","getIntersection","id","draw","setState","event","newArrowOnDragEnd","arrow","TransformerComponent","checkNode","stage","transformer","selectedShapeName","selectedNode","findOne","node","attachTo","detach","getLayer","batchDraw","_this","boundBoxFunc","oldBox","newBox","max","enabledAnchors","resizeEnabled","rotateEnabled","keepRatio","React","history","historyStep","Graphics","Object","classCallCheck","possibleConstructorReturn","getPrototypeOf","call","handleSave","rects","rectangles","ellipses","stars","texts","arrows","JSON","stringify","saved","arrows1","forEach","eachArrow","roadmapId","saving","fetch","method","headers","Content-Type","body","data","then","res","userId","auth","user","roadmapType","json","handleStageClick","layer2","graphicStage","newArrowRef","map","handleMouseOver","link","document","style","cursor","transform","getAbsoluteTransform","copy","invert","forceUpdate","index","indexOf","currentArrow","handleUndo","isTransforming","textEditVisible","connectors","redoing","shapeIsGone","handleRedo","length","next","returnTo","toReturn","currentShapeName","_ref","eachRect","eachEllipse","eachStar","eachText","IsJsonString","str","parse","layerX","layerY","layerScale","errMsg","currentTextRef","shouldTextUpdate","textX","textY","newArrowDropped","newConnectorDropped","lastFill","alreadyCreated","publishing","title","category","description","thumbnail","isPasteDisabled","ellipseDeleteCount","starDeleteCount","arrowDeleteCount","textDeleteCount","rectDeleteCount","handleWheel","bind","assertThisInitialized","evt","preventDefault","oldScale","scaleX","mousePointTo","newScale","deltaY","scale","prevProps","prevState","prevMainShapes","currentMainShapes","slice","toAppend","concat","push","_this3","color","gradient","getContext","createLinearGradient","addColorStop","errDisplay","className","onKeyDown","ctrlKey","keyCode","that","filter","shiftKey","copiedElement","toPush","toConsumableArray","setTimeout","tabIndex","outline","onClick","onMouseMove","onWheel","window","innerHeight","innerWidth","scaleY","onTransformStart","rect","onTransform","lastRotation","onTransformEnd","objectSpread","strokeScaleEnabled","ellipse","star","textDecoration","currentText","eachtext","onDblClick","absolutePosition","textNode","textareaWidth","textareaHeight","textareaFill","textareaFontFamily","textareaFontSize","textarea","focus","hide","src_Connector","oldPoints","shiftX","shiftY","newPoints","eachArr","App_TransformerComponent","Toolbar_Toolbar","uh","newArrow","fire","value","onChange","show","onBlur","display","top","left","overflow","border","padding","margin","resize","background","ReactDOM","render","App","getElementById"],"mappings":"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","file":"static/js/main.cd668e9a.chunk.js","sourcesContent":["import React, { Component } from 'react'\r\nimport { Arrow } from 'react-konva'\r\nclass Connector extends Component {\r\n    /*******uses current position of two shapes to determine the points of an arrow\r\n     ******************************************************************************/\r\n\r\n    getConnectorPoints = stuff => {\r\n        var points = stuff.points\r\n        var from = stuff.from\r\n        var to = stuff.to\r\n        var mouseX = stuff.mouseX\r\n        var mouseY = stuff.mouseY\r\n        var point = { x: mouseX, y: mouseY }\r\n\r\n        if (stuff.type === 'FromAndTo') {\r\n            if (\r\n                to.attrs.name.includes('rect') &&\r\n                from.attrs.name.includes('rect')\r\n            ) {\r\n                //only works for rect because the calculation for origin is different for ellipse and rect\r\n                var dy =\r\n                    to.attrs.y +\r\n                    to.attrs.height / 2 -\r\n                    (from.attrs.y + from.attrs.height / 2)\r\n                var dx =\r\n                    to.attrs.x +\r\n                    to.attrs.width / 2 -\r\n                    (from.attrs.x + from.attrs.width / 2)\r\n                var theta = Math.atan2(dy, dx)\r\n                let angle = (theta / Math.PI) * 180\r\n\r\n                if (angle <= 45 && angle >= -45) {\r\n                    points[0] += from.attrs.width\r\n                    points[1] += from.attrs.height / 2\r\n                    points[3] += to.attrs.height / 2\r\n                } else if (angle > 45 && angle < 135) {\r\n                    points[0] += from.attrs.width / 2\r\n                    points[1] += from.attrs.height\r\n                    points[2] += to.attrs.width / 2\r\n                } else if (\r\n                    (angle > 135 && angle < 180) ||\r\n                    (angle > -180 && angle < -135)\r\n                ) {\r\n                    points[1] += from.attrs.height / 2\r\n                    points[2] += to.attrs.width\r\n                    points[3] += to.attrs.height / 2\r\n                } else if (angle < -45 && angle > -135) {\r\n                    points[0] += from.attrs.width / 2\r\n                    points[3] += to.attrs.height\r\n                    points[2] += to.attrs.width / 2\r\n                }\r\n            } else if (\r\n                to.attrs.name.includes('rect') &&\r\n                from.attrs.name.includes('text')\r\n            ) {\r\n                //only works for rect because the calculation for origin is different for ellipse and rect\r\n\r\n                let fromTextHeight = from.textHeight || from.attrs.textHeight\r\n                let fromTextWidth = from.textWidth || from.attrs.textWidth\r\n                dy =\r\n                    to.attrs.y +\r\n                    to.attrs.height / 2 -\r\n                    (from.attrs.y + fromTextHeight / 2)\r\n                dx =\r\n                    to.attrs.x +\r\n                    to.attrs.width / 2 -\r\n                    (from.attrs.x + fromTextWidth / 2)\r\n                theta = Math.atan2(dy, dx)\r\n                let angle = (theta / Math.PI) * 180\r\n\r\n                if (angle <= 45 && angle >= -45) {\r\n                    points[0] += fromTextWidth\r\n                    points[1] += fromTextHeight / 2\r\n                    points[3] += to.attrs.height / 2\r\n                } else if (angle > 45 && angle < 135) {\r\n                    points[0] += fromTextWidth / 2\r\n                    points[1] += fromTextHeight\r\n                    points[2] += to.attrs.width / 2\r\n                } else if (\r\n                    (angle > 135 && angle < 180) ||\r\n                    (angle > -180 && angle < -135)\r\n                ) {\r\n                    points[1] += fromTextHeight / 2\r\n                    points[2] += to.attrs.width\r\n                    points[3] += to.attrs.height / 2\r\n                } else if (angle < -45 && angle > -135) {\r\n                    points[0] += fromTextWidth / 2\r\n                    points[3] += to.attrs.height\r\n                    points[2] += to.attrs.width / 2\r\n                }\r\n            } else if (\r\n                to.attrs.name.includes('ellipse') &&\r\n                from.attrs.name.includes('ellipse')\r\n            ) {\r\n                //two ellipses\r\n                var origin = { x: from.attrs.x, y: from.attrs.y }\r\n                const dy = points[3] - points[1]\r\n                const dx = points[2] - points[0]\r\n                let angle = Math.atan2(-dy, dx)\r\n                points[0] += -from.attrs.radiusX * Math.cos(angle + Math.PI)\r\n                points[1] += from.attrs.radiusY * Math.sin(angle + Math.PI)\r\n                points[2] += to.attrs.radiusX * Math.cos(angle + Math.PI)\r\n                points[3] -= to.attrs.radiusY * Math.sin(angle + Math.PI)\r\n            } else if (\r\n                to.attrs.name.includes('star') &&\r\n                from.attrs.name.includes('star')\r\n            ) {\r\n                origin = { x: from.attrs.x, y: from.attrs.y }\r\n                dy = points[3] - points[1]\r\n                dx = points[2] - points[0]\r\n                let angle = Math.atan2(-dy, dx)\r\n                points[0] += -from.attrs.outerRadius * Math.cos(angle + Math.PI)\r\n                points[1] += from.attrs.outerRadius * Math.sin(angle + Math.PI)\r\n                points[2] += to.attrs.outerRadius * Math.cos(angle + Math.PI)\r\n                points[3] -= to.attrs.outerRadius * Math.sin(angle + Math.PI)\r\n            } else if (\r\n                to.attrs.name.includes('text') &&\r\n                from.attrs.name.includes('text')\r\n            ) {\r\n                let fromTextHeight = from.textHeight || from.attrs.textHeight\r\n                let fromTextWidth = from.textWidth || from.attrs.textWidth\r\n                let toTextHeight = to.textHeight || to.attrs.textHeight\r\n                let toTextWidth = to.textWidth || to.attrs.textWidth\r\n                dy =\r\n                    to.attrs.y +\r\n                    toTextHeight / 2 -\r\n                    (from.attrs.y + fromTextHeight / 2)\r\n                dx =\r\n                    to.attrs.x +\r\n                    toTextWidth / 2 -\r\n                    (from.attrs.x + fromTextWidth / 2)\r\n                theta = Math.atan2(dy, dx)\r\n                let angle = (theta / Math.PI) * 180\r\n\r\n                if (angle <= 45 && angle >= -45) {\r\n                    points[0] += fromTextWidth\r\n                    points[1] += fromTextHeight / 2\r\n                    points[3] += toTextHeight / 2\r\n                } else if (angle > 45 && angle < 135) {\r\n                    points[0] += fromTextWidth / 2\r\n                    points[1] += fromTextHeight\r\n                    points[2] += toTextWidth / 2\r\n                } else if (\r\n                    (angle > 135 && angle < 180) ||\r\n                    (angle > -180 && angle < -135)\r\n                ) {\r\n                    points[1] += fromTextHeight / 2\r\n                    points[2] += toTextWidth\r\n                    points[3] += toTextHeight / 2\r\n                } else if (angle < -45 && angle > -135) {\r\n                    points[0] += fromTextWidth / 2\r\n                    points[3] += toTextHeight\r\n                    points[2] += toTextWidth / 2\r\n                }\r\n            } else if (\r\n                from.attrs.name.includes('rect') &&\r\n                to.attrs.name.includes('ellipse')\r\n            ) {\r\n                //rect change\r\n                var dy1 = to.attrs.y + -(from.attrs.y + from.attrs.height / 2)\r\n                var dx1 = to.attrs.x + -(from.attrs.x + from.attrs.width / 2)\r\n\r\n                theta = Math.atan2(dy1, dx1)\r\n                var angle = (theta / Math.PI) * 180\r\n                if (angle <= -45 && angle >= -135) {\r\n                    //top\r\n                    points[0] += from.attrs.width / 2\r\n                } else if (angle > 45 && angle < 135) {\r\n                    //bottom\r\n                    points[0] += from.attrs.width / 2\r\n                    points[1] += from.attrs.height\r\n                } else if (\r\n                    (angle > 135 && angle < 180) ||\r\n                    (angle > -180 && angle < -135)\r\n                ) {\r\n                    //left\r\n                    points[1] += from.attrs.height / 2\r\n                } else if (angle > -45 && angle < 45) {\r\n                    points[0] += from.attrs.width\r\n                    points[1] += from.attrs.height / 2\r\n                }\r\n                //ellipse change\r\n                const dy = points[3] - points[1]\r\n                const dx = points[2] - points[0]\r\n                angle = Math.atan2(-dy, dx)\r\n                //      console.log(dy, dx);\r\n\r\n                points[2] += to.attrs.radiusX * Math.cos(angle + Math.PI)\r\n                points[3] -= to.attrs.radiusY * Math.sin(angle + Math.PI)\r\n            } else if (\r\n                from.attrs.name.includes('rect') &&\r\n                to.attrs.name.includes('star')\r\n            ) {\r\n                //rect change\r\n                dy1 = to.attrs.y + -(from.attrs.y + from.attrs.height / 2)\r\n                dx1 = to.attrs.x + -(from.attrs.x + from.attrs.width / 2)\r\n\r\n                theta = Math.atan2(dy1, dx1)\r\n                angle = (theta / Math.PI) * 180\r\n                if (angle <= -45 && angle >= -135) {\r\n                    //top\r\n                    points[0] += from.attrs.width / 2\r\n                } else if (angle > 45 && angle < 135) {\r\n                    //bottom\r\n                    points[0] += from.attrs.width / 2\r\n                    points[1] += from.attrs.height\r\n                } else if (\r\n                    (angle > 135 && angle < 180) ||\r\n                    (angle > -180 && angle < -135)\r\n                ) {\r\n                    //left\r\n                    points[1] += from.attrs.height / 2\r\n                } else if (angle > -45 && angle < 45) {\r\n                    points[0] += from.attrs.width\r\n                    points[1] += from.attrs.height / 2\r\n                }\r\n                //ellipse change\r\n                const dy = points[3] - points[1]\r\n                const dx = points[2] - points[0]\r\n                angle = Math.atan2(-dy, dx)\r\n                //      console.log(dy, dx);\r\n\r\n                points[2] += to.attrs.outerRadius * Math.cos(angle + Math.PI)\r\n                points[3] -= to.attrs.outerRadius * Math.sin(angle + Math.PI)\r\n            } else if (\r\n                from.attrs.name.includes('rect') &&\r\n                to.attrs.name.includes('text')\r\n            ) {\r\n                //only works for rect because the calculation for origin is different for ellipse and rect\r\n                let toTextHeight = to.textHeight || to.attrs.textHeight\r\n                let toTextWidth = to.textWidth || to.attrs.textWidth\r\n                console.log(to)\r\n                dy =\r\n                    to.attrs.y +\r\n                    toTextHeight / 2 -\r\n                    (from.attrs.y + from.attrs.height / 2)\r\n                dx =\r\n                    to.attrs.x +\r\n                    toTextWidth / 2 -\r\n                    (from.attrs.x + from.attrs.width / 2)\r\n                var theta = Math.atan2(dy, dx)\r\n                let angle = (theta / Math.PI) * 180\r\n\r\n                /*  console.log(\r\n                    'from rect and to text',\r\n                    'angle: ',\r\n                    angle,\r\n                    'from',\r\n                    from,\r\n                    'to',\r\n                    to\r\n                )*/\r\n\r\n                if (angle <= 45 && angle >= -45) {\r\n                    points[0] += from.attrs.width\r\n                    points[1] += from.attrs.height / 2\r\n                    points[3] += toTextHeight / 2\r\n                } else if (angle > 45 && angle < 135) {\r\n                    points[0] += from.attrs.width / 2\r\n                    points[1] += from.attrs.height\r\n                    points[2] += toTextWidth / 2\r\n                } else if (\r\n                    (angle > 135 && angle < 180) ||\r\n                    (angle > -180 && angle < -135)\r\n                ) {\r\n                    points[1] += from.attrs.height / 2\r\n                    points[2] += toTextWidth\r\n                    points[3] += toTextHeight / 2\r\n                } else if (angle < -45 && angle > -135) {\r\n                    points[0] += from.attrs.width / 2\r\n                    points[3] += toTextHeight\r\n                    points[2] += toTextWidth / 2\r\n                }\r\n            } else if (\r\n                from.attrs.name.includes('ellipse') &&\r\n                to.attrs.name.includes('rect')\r\n            ) {\r\n                //rect change\r\n                dy1 = to.attrs.y + to.attrs.height / 2 - from.attrs.y\r\n                dx1 = to.attrs.x + to.attrs.width / 2 - from.attrs.x\r\n\r\n                theta = Math.atan2(dy1, dx1)\r\n                angle = (theta / Math.PI) * 180\r\n\r\n                if (angle <= -45 && angle >= -135) {\r\n                    //top\r\n                    points[2] += to.attrs.width / 2\r\n                    points[3] += to.attrs.height\r\n                } else if (angle > 45 && angle < 135) {\r\n                    //bottom\r\n                    points[2] += to.attrs.width / 2\r\n                } else if (\r\n                    (angle > 135 && angle < 180) ||\r\n                    (angle > -180 && angle < -135)\r\n                ) {\r\n                    //left\r\n                    points[2] += to.attrs.width\r\n                    points[3] += to.attrs.height / 2\r\n                } else if (angle > -45 && angle < 45) {\r\n                    points[3] += to.attrs.height / 2\r\n                }\r\n                //ellipse change\r\n                const dy = points[3] - points[1]\r\n                const dx = points[2] - points[0]\r\n                angle = Math.atan2(-dy, dx)\r\n                //      console.log(dy, dx);\r\n\r\n                points[0] -= from.attrs.radiusX * Math.cos(angle + Math.PI)\r\n                points[1] += from.attrs.radiusY * Math.sin(angle + Math.PI)\r\n            } else if (\r\n                from.attrs.name.includes('ellipse') &&\r\n                to.attrs.name.includes('text')\r\n            ) {\r\n                let toTextHeight = to.textHeight || to.attrs.textHeight\r\n                let toTextWidth = to.textWidth || to.attrs.textWidth\r\n                //rect change\r\n                dy1 = to.attrs.y + toTextHeight / 2 - from.attrs.y\r\n                dx1 = to.attrs.x + toTextWidth / 2 - from.attrs.x\r\n\r\n                theta = Math.atan2(dy1, dx1)\r\n                angle = (theta / Math.PI) * 180\r\n\r\n                if (angle <= -45 && angle >= -135) {\r\n                    //top\r\n                    points[2] += toTextWidth / 2\r\n                    points[3] += toTextHeight\r\n                } else if (angle > 45 && angle < 135) {\r\n                    //bottom\r\n                    points[2] += toTextWidth / 2\r\n                } else if (\r\n                    (angle > 135 && angle < 180) ||\r\n                    (angle > -180 && angle < -135)\r\n                ) {\r\n                    //left\r\n                    points[2] += toTextWidth\r\n                    points[3] += toTextHeight / 2\r\n                } else if (angle > -45 && angle < 45) {\r\n                    points[3] += toTextHeight / 2\r\n                }\r\n                //ellipse change\r\n                const dy = points[3] - points[1]\r\n                const dx = points[2] - points[0]\r\n                angle = Math.atan2(-dy, dx)\r\n                //      console.log(dy, dx);\r\n\r\n                points[0] -= from.attrs.radiusX * Math.cos(angle + Math.PI)\r\n                points[1] += from.attrs.radiusY * Math.sin(angle + Math.PI)\r\n\r\n                console.log(\r\n                    'new points',\r\n                    points,\r\n                    'from',\r\n                    from,\r\n                    'from coord',\r\n                    from.attrs\r\n                )\r\n            } else if (\r\n                from.attrs.name.includes('ellipse') &&\r\n                to.attrs.name.includes('star')\r\n            ) {\r\n                //two ellipses\r\n                origin = { x: from.attrs.x, y: from.attrs.y }\r\n                const dy = points[3] - points[1]\r\n                const dx = points[2] - points[0]\r\n                let angle = Math.atan2(-dy, dx)\r\n                points[0] += -from.attrs.radiusX * Math.cos(angle + Math.PI)\r\n                points[1] += from.attrs.radiusY * Math.sin(angle + Math.PI)\r\n                points[2] += to.attrs.outerRadius * Math.cos(angle + Math.PI)\r\n                points[3] -= to.attrs.outerRadius * Math.sin(angle + Math.PI)\r\n            } else if (\r\n                from.attrs.name.includes('star') &&\r\n                to.attrs.name.includes('ellipse')\r\n            ) {\r\n                //two ellipses\r\n                origin = { x: from.attrs.x, y: from.attrs.y }\r\n                const dy = points[3] - points[1]\r\n                const dx = points[2] - points[0]\r\n                let angle = Math.atan2(-dy, dx)\r\n                points[0] += -from.attrs.outerRadius * Math.cos(angle + Math.PI)\r\n                points[1] += from.attrs.outerRadius * Math.sin(angle + Math.PI)\r\n                points[2] += to.attrs.radiusX * Math.cos(angle + Math.PI)\r\n                points[3] -= to.attrs.radiusY * Math.sin(angle + Math.PI)\r\n            } else if (\r\n                from.attrs.name.includes('star') &&\r\n                to.attrs.name.includes('rect')\r\n            ) {\r\n                //two ellipses\r\n                dy1 = to.attrs.y + to.attrs.width / 2 - from.attrs.y\r\n                dx1 = to.attrs.x + to.attrs.width / 2 - from.attrs.x\r\n\r\n                theta = Math.atan2(dy1, dx1)\r\n                angle = (theta / Math.PI) * 180\r\n\r\n                if (angle <= -45 && angle >= -135) {\r\n                    //top\r\n                    points[2] += to.attrs.width / 2\r\n                    points[3] += to.attrs.height\r\n                } else if (angle > 45 && angle < 135) {\r\n                    //bottom\r\n                    points[2] += to.attrs.width / 2\r\n                } else if (\r\n                    (angle > 135 && angle < 180) ||\r\n                    (angle > -180 && angle < -135)\r\n                ) {\r\n                    //left\r\n                    points[2] += to.attrs.width\r\n                    points[3] += to.attrs.height / 2\r\n                } else if (angle > -45 && angle < 45) {\r\n                    points[3] += to.attrs.width / 2\r\n                }\r\n                //ellipse change\r\n                const dy = points[3] - points[1]\r\n                const dx = points[2] - points[0]\r\n                angle = Math.atan2(-dy, dx)\r\n                //      console.log(dy, dx);\r\n\r\n                points[0] -= from.attrs.outerRadius * Math.cos(angle + Math.PI)\r\n                points[1] += from.attrs.outerRadius * Math.sin(angle + Math.PI)\r\n            } else if (\r\n                from.attrs.name.includes('star') &&\r\n                to.attrs.name.includes('text')\r\n            ) {\r\n                let toTextHeight = to.textHeight || to.attrs.textHeight\r\n                let toTextWidth = to.textWidth || to.attrs.textWidth\r\n                //two ellipses\r\n                dy1 = to.attrs.y + toTextHeight / 2 - from.attrs.y\r\n                dx1 = to.attrs.x + toTextWidth / 2 - from.attrs.x\r\n\r\n                theta = Math.atan2(dy1, dx1)\r\n                angle = (theta / Math.PI) * 180\r\n\r\n                if (angle <= -45 && angle >= -135) {\r\n                    //top\r\n                    points[2] += toTextWidth / 2\r\n                    points[3] += toTextHeight\r\n                } else if (angle > 45 && angle < 135) {\r\n                    //bottom\r\n                    points[2] += toTextWidth / 2\r\n                } else if (\r\n                    (angle > 135 && angle < 180) ||\r\n                    (angle > -180 && angle < -135)\r\n                ) {\r\n                    //left\r\n                    points[2] += toTextWidth\r\n                    points[3] += toTextHeight / 2\r\n                } else if (angle > -45 && angle < 45) {\r\n                    points[3] += toTextHeight / 2\r\n                }\r\n                //ellipse change\r\n                const dy = points[3] - points[1]\r\n                const dx = points[2] - points[0]\r\n                angle = Math.atan2(-dy, dx)\r\n                //      console.log(dy, dx);\r\n\r\n                points[0] -= from.attrs.outerRadius * Math.cos(angle + Math.PI)\r\n                points[1] += from.attrs.outerRadius * Math.sin(angle + Math.PI)\r\n            } else if (\r\n                from.attrs.name.includes('text') &&\r\n                to.attrs.name.includes('star')\r\n            ) {\r\n                let fromTextHeight = from.textHeight || from.attrs.textHeight\r\n                let fromTextWidth = from.textWidth || from.attrs.textWidth\r\n                //rect change\r\n                dy1 = to.attrs.y + -(from.attrs.y + fromTextHeight / 2)\r\n                dx1 = to.attrs.x + -(from.attrs.x + fromTextWidth / 2)\r\n\r\n                theta = Math.atan2(dy1, dx1)\r\n                angle = (theta / Math.PI) * 180\r\n                if (angle <= -45 && angle >= -135) {\r\n                    //top\r\n                    points[0] += fromTextWidth / 2\r\n                } else if (angle > 45 && angle < 135) {\r\n                    //bottom\r\n                    points[0] += fromTextWidth / 2\r\n                    points[1] += fromTextHeight\r\n                } else if (\r\n                    (angle > 135 && angle < 180) ||\r\n                    (angle > -180 && angle < -135)\r\n                ) {\r\n                    //left\r\n                    points[1] += fromTextHeight / 2\r\n                } else if (angle > -45 && angle < 45) {\r\n                    points[0] += fromTextWidth\r\n                    points[1] += fromTextHeight / 2\r\n                }\r\n                //ellipse change\r\n                const dy = points[3] - points[1]\r\n                const dx = points[2] - points[0]\r\n                angle = Math.atan2(-dy, dx)\r\n                //      console.log(dy, dx);\r\n\r\n                points[2] += to.attrs.outerRadius * Math.cos(angle + Math.PI)\r\n                points[3] -= to.attrs.outerRadius * Math.sin(angle + Math.PI)\r\n            } else if (\r\n                from.attrs.name.includes('text') &&\r\n                to.attrs.name.includes('ellipse')\r\n            ) {\r\n                let fromTextHeight = from.textHeight || from.attrs.textHeight\r\n                let fromTextWidth = from.textWidth || from.attrs.textWidth\r\n                //rect change\r\n                dy1 = to.attrs.y + -(from.attrs.y + fromTextHeight / 2)\r\n                dx1 = to.attrs.x + -(from.attrs.x + fromTextWidth / 2)\r\n\r\n                theta = Math.atan2(dy1, dx1)\r\n                angle = (theta / Math.PI) * 180\r\n                if (angle <= -45 && angle >= -135) {\r\n                    //top\r\n                    points[0] += fromTextWidth / 2\r\n                } else if (angle > 45 && angle < 135) {\r\n                    //bottom\r\n                    points[0] += fromTextWidth / 2\r\n                    points[1] += fromTextHeight\r\n                } else if (\r\n                    (angle > 135 && angle < 180) ||\r\n                    (angle > -180 && angle < -135)\r\n                ) {\r\n                    //left\r\n                    points[1] += fromTextHeight / 2\r\n                } else if (angle > -45 && angle < 45) {\r\n                    points[0] += fromTextWidth\r\n                    points[1] += fromTextHeight / 2\r\n                }\r\n                //ellipse change\r\n                const dy = points[3] - points[1]\r\n                const dx = points[2] - points[0]\r\n                angle = Math.atan2(-dy, dx)\r\n                //      console.log(dy, dx);\r\n\r\n                points[2] += to.attrs.radiusX * Math.cos(angle + Math.PI)\r\n                points[3] -= to.attrs.radiusY * Math.sin(angle + Math.PI)\r\n            }\r\n        }\r\n\r\n        if (stuff.type === 'onlyFrom') {\r\n            if (from.attrs.name.includes('rect')) {\r\n                origin = {\r\n                    x: from.attrs.x + from.attrs.width / 2,\r\n                    y: from.attrs.y + from.attrs.height / 2\r\n                }\r\n                dy = point.y - origin.y\r\n                dx = point.x - origin.x\r\n                theta = Math.atan2(dy, dx)\r\n                angle = (theta / Math.PI) * 180\r\n                if (angle <= -45 && angle >= -135) {\r\n                    //top\r\n                    points[0] += from.attrs.width / 2\r\n                } else if (angle > 45 && angle < 135) {\r\n                    //bottom\r\n                    points[0] += from.attrs.width / 2\r\n                    points[1] += from.attrs.height\r\n                } else if (\r\n                    (angle > 135 && angle < 180) ||\r\n                    (angle > -180 && angle < -135)\r\n                ) {\r\n                    //left\r\n                    points[1] += from.attrs.height / 2\r\n                } else if (angle > -45 && angle < 45) {\r\n                    points[0] += from.attrs.width\r\n                    points[1] += from.attrs.height / 2\r\n                }\r\n            } else if (from.attrs.name.includes('ellipse')) {\r\n                origin = {\r\n                    x: from.attrs.x,\r\n                    y: from.attrs.y\r\n                }\r\n\r\n                const dy = points[3] - points[1]\r\n                const dx = points[2] - points[0]\r\n                let angle = Math.atan2(-dy, dx)\r\n\r\n                //  console.log(\"we messing with a ellipse\", points, angle, from);\r\n\r\n                points[0] += -from.attrs.radiusX * Math.cos(angle + Math.PI)\r\n                points[1] += from.attrs.radiusY * Math.sin(angle + Math.PI)\r\n            } else if (from.attrs.name.includes('star')) {\r\n                origin = { x: from.attrs.x, y: from.attrs.y }\r\n                const dy = points[3] - points[1]\r\n                const dx = points[2] - points[0]\r\n                let angle = Math.atan2(-dy, dx)\r\n\r\n                //  console.log(\"we messing with a ellipse\", points, angle, from);\r\n\r\n                points[0] += -from.attrs.outerRadius * Math.cos(angle + Math.PI)\r\n                points[1] += from.attrs.outerRadius * Math.sin(angle + Math.PI)\r\n            } else if (from.attrs.name.includes('text')) {\r\n                let fromTextHeight = from.textHeight || from.attrs.textHeight\r\n                let fromTextWidth = from.textWidth || from.attrs.textWidth\r\n\r\n                origin = {\r\n                    x: from.attrs.x + fromTextWidth / 2,\r\n                    y: from.attrs.y + fromTextWidth / 2\r\n                }\r\n                dy = point.y - origin.y\r\n                dx = point.x - origin.x\r\n                theta = Math.atan2(dy, dx)\r\n                angle = (theta / Math.PI) * 180\r\n\r\n                if (angle <= -45 && angle >= -135) {\r\n                    //top\r\n                    points[0] += fromTextWidth / 2\r\n                } else if (angle > 45 && angle < 135) {\r\n                    //bottom\r\n                    points[0] += fromTextWidth / 2\r\n                    points[1] += fromTextHeight\r\n                } else if (\r\n                    (angle > 135 && angle < 180) ||\r\n                    (angle > -180 && angle < -135)\r\n                ) {\r\n                    //left\r\n                    points[1] += fromTextHeight / 2\r\n                } else if (angle > -45 && angle < 45) {\r\n                    points[0] += fromTextWidth\r\n                    points[1] += fromTextHeight / 2\r\n                }\r\n            }\r\n        }\r\n        if (stuff.type === 'onlyTo') {\r\n            if (to.attrs.name.includes('rect')) {\r\n                var endPoint = { x: points[0], y: points[1] }\r\n                origin = {\r\n                    x: to.attrs.x + to.attrs.width / 2,\r\n                    y: to.attrs.y + to.attrs.height / 2\r\n                }\r\n\r\n                dy = endPoint.y - origin.y\r\n                dx = endPoint.x - origin.x\r\n                theta = Math.atan2(dy, dx)\r\n                angle = (theta / Math.PI) * 180\r\n\r\n                if (angle > 45 && angle < 135) {\r\n                    points[2] += to.attrs.width / 2\r\n                    points[3] += to.attrs.height\r\n                } else if (\r\n                    (angle > 135 && angle < 180) ||\r\n                    (angle > -180 && angle < -135)\r\n                ) {\r\n                    points[3] += to.attrs.height / 2\r\n                } else if (angle > -135 && angle < -45) {\r\n                    points[2] += to.attrs.width / 2\r\n                } else {\r\n                    points[2] += to.attrs.width\r\n                    points[3] += to.attrs.height / 2\r\n                }\r\n            } else if (to.attrs.name.includes('ellipse')) {\r\n                const dy = points[3] - points[1]\r\n                const dx = points[2] - points[0]\r\n                let angle = Math.atan2(-dy, dx)\r\n                //      console.log(dy, dx);\r\n\r\n                points[2] += to.attrs.radiusX * Math.cos(angle + Math.PI)\r\n                points[3] -= to.attrs.radiusY * Math.sin(angle + Math.PI)\r\n            } else if (to.attrs.name.includes('star')) {\r\n                const dy = points[3] - points[1]\r\n                const dx = points[2] - points[0]\r\n                let angle = Math.atan2(-dy, dx)\r\n                //      console.log(dy, dx);\r\n\r\n                points[2] += to.attrs.outerRadius * Math.cos(angle + Math.PI)\r\n                points[3] -= to.attrs.outerRadius * Math.sin(angle + Math.PI)\r\n            } else if (to.attrs.name.includes('text')) {\r\n                let toTextHeight = to.textHeight || to.attrs.textHeight\r\n                let toTextWidth = to.textWidth || to.attrs.textWidth\r\n\r\n                endPoint = { x: points[0], y: points[1] }\r\n                origin = {\r\n                    x: to.attrs.x + toTextWidth / 2,\r\n                    y: to.attrs.y + toTextWidth / 2\r\n                }\r\n\r\n                dy = endPoint.y - origin.y\r\n                dx = endPoint.x - origin.x\r\n                theta = Math.atan2(dy, dx)\r\n                angle = (theta / Math.PI) * 180\r\n\r\n                if (angle > 45 && angle < 135) {\r\n                    points[2] += toTextWidth / 2\r\n                    points[3] += toTextHeight\r\n                } else if (\r\n                    (angle > 135 && angle < 180) ||\r\n                    (angle > -180 && angle < -135)\r\n                ) {\r\n                    points[3] += toTextHeight / 2\r\n                } else if (angle > -135 && angle < -45) {\r\n                    points[2] += toTextWidth / 2\r\n                } else {\r\n                    points[2] += toTextHeight\r\n                    points[3] += toTextHeight / 2\r\n                }\r\n            }\r\n        }\r\n\r\n        return points\r\n    }\r\n\r\n    render() {\r\n        var points = null\r\n\r\n        if (this.props.current) {\r\n            if (this.props.from) {\r\n                points = [\r\n                    this.props.from.attrs.x,\r\n                    this.props.from.attrs.y,\r\n                    this.props.arrowEndX,\r\n                    this.props.arrowEndY\r\n                ]\r\n                let stuff = {\r\n                    points: points,\r\n                    from: this.props.from,\r\n                    mouseX: this.props.arrowEndX,\r\n                    mouseY: this.props.arrowEndY,\r\n                    type: 'onlyFrom'\r\n                }\r\n                points = this.getConnectorPoints(stuff)\r\n            }\r\n        }\r\n        if (this.props.current === false) {\r\n            if (this.props.from && this.props.to) {\r\n                points = [\r\n                    this.props.from.attrs.x,\r\n                    this.props.from.attrs.y,\r\n                    this.props.to.attrs.x,\r\n                    this.props.to.attrs.y\r\n                ]\r\n\r\n                let toSend = {\r\n                    points: points,\r\n                    from: this.props.from,\r\n                    to: this.props.to,\r\n                    type: 'FromAndTo'\r\n                }\r\n\r\n                points = this.getConnectorPoints(toSend)\r\n\r\n                //get connector points\r\n            } else if (this.props.from) {\r\n                points = [\r\n                    this.props.from.attrs.x,\r\n                    this.props.from.attrs.y,\r\n                    this.props.points[2],\r\n                    this.props.points[3]\r\n                ]\r\n\r\n                let stuff = {\r\n                    points: points,\r\n                    from: this.props.from,\r\n                    mouseX: this.props.points[2],\r\n                    mouseY: this.props.points[3],\r\n                    type: 'onlyFrom'\r\n                }\r\n                points = this.getConnectorPoints(stuff)\r\n            } else if (this.props.to) {\r\n                points = [\r\n                    this.props.points[0],\r\n                    this.props.points[1],\r\n                    this.props.to.attrs.x,\r\n                    this.props.to.attrs.y\r\n                ]\r\n\r\n                let stuff = {\r\n                    points: points,\r\n                    to: this.props.to,\r\n                    type: 'onlyTo',\r\n                    mouseX: this.props.to.attrs.x,\r\n                    mouseY: this.props.to.attrs.y\r\n                }\r\n                points = this.getConnectorPoints(stuff)\r\n            }\r\n        }\r\n        return (\r\n            <Arrow\r\n                name={this.props.name}\r\n                points={points}\r\n                strokeWidth={1.5}\r\n                stroke={this.props.stroke}\r\n                fill={this.props.fill}\r\n            />\r\n        )\r\n    }\r\n}\r\n\r\nexport default Connector\r\n","import React, { Component } from 'react'\r\n\r\nimport { Rect, Ellipse, Star, Text, Arrow } from 'react-konva'\r\n//at start, two same rectangles at one place\r\n//at the end of drag, note the x and y of the dragged rectangle, append it to GraphicsMain\r\n//return the dragged rectangle to original\r\n\r\nconst ToolBar = () => (\r\n    <Rect\r\n        y={80}\r\n        width={77.5}\r\n        height={355}\r\n        fill=\"white\"\r\n        shadowBlur={5}\r\n        shadowColor=\"black\"\r\n    />\r\n)\r\n\r\nexport default class Toolbar extends Component {\r\n    state = {\r\n        arrowDraggable: false,\r\n        previousShape: undefined,\r\n        count: 0,\r\n        isDragging: false\r\n    }\r\n    render() {\r\n        return (\r\n            <React.Fragment>\r\n                {this.props.layer ? (\r\n                    <React.Fragment>\r\n                        <ToolBar />\r\n                        <Ellipse\r\n                            radiusX={20}\r\n                            radiusY={20}\r\n                            stroke=\"black\"\r\n                            strokeWidth={1.5}\r\n                            x={37.5}\r\n                            y={125}\r\n                        />\r\n                        <Ellipse\r\n                            radiusX={20}\r\n                            radiusY={20}\r\n                            stroke=\"black\"\r\n                            strokeWidth={1.5}\r\n                            x={37.5}\r\n                            y={125}\r\n                            draggable\r\n                            ref=\"draggableEllipse\"\r\n                            onDragEnd={e => {\r\n                                //add the rectangle to parent\r\n                                let name = 'ellipse' + this.props.ellipseName\r\n                                let toSend = {\r\n                                    x: e.target.x(),\r\n                                    y: e.target.y(),\r\n                                    radiusX: 20,\r\n                                    radiusY: 20,\r\n                                    stroke: 'black',\r\n                                    strokeWidth: 1.5,\r\n                                    name: name,\r\n                                    fill: 'white',\r\n                                    ref: name,\r\n                                    rotation: 0\r\n                                }\r\n                                this.props.appendToEllipses(toSend)\r\n\r\n                                var ellipse = this.refs.draggableEllipse\r\n\r\n                                ellipse.position({\r\n                                    x: 37.5,\r\n                                    y: 125\r\n                                })\r\n                            }}\r\n                        />\r\n                        <Rect\r\n                            width={35}\r\n                            height={35}\r\n                            stroke=\"black\"\r\n                            strokeWidth={1.5}\r\n                            x={20}\r\n                            y={180}\r\n                            fill=\"white\"\r\n                        />\r\n                        <Rect\r\n                            width={35}\r\n                            height={35}\r\n                            stroke=\"black\"\r\n                            strokeWidth={1.5}\r\n                            x={20}\r\n                            y={180}\r\n                            draggable\r\n                            fill=\"white\"\r\n                            ref=\"draggableRect\"\r\n                            onDragEnd={e => {\r\n                                //add the rectangle to parent\r\n                                let name = 'rectangle' + this.props.rectName\r\n                                let toSend = {\r\n                                    x: e.target.x(),\r\n                                    y: e.target.y(),\r\n                                    width: 35,\r\n                                    height: 35,\r\n                                    stroke: 'black',\r\n                                    strokeWidth: 1.5,\r\n                                    rotation: 0,\r\n                                    name: name,\r\n                                    ref: name,\r\n                                    fill: 'white',\r\n                                    useImage: false\r\n                                }\r\n                                this.props.appendToRectangles(toSend)\r\n\r\n                                var rect = this.refs.draggableRect\r\n\r\n                                rect.position({\r\n                                    x: 20,\r\n                                    y: 180\r\n                                })\r\n                            }}\r\n                        />\r\n                        <Star\r\n                            innerRadius={8}\r\n                            outerRadius={20}\r\n                            numPoints={5}\r\n                            stroke=\"black\"\r\n                            strokeWidth={1.5}\r\n                            x={37.5}\r\n                            y={270}\r\n                            fill=\"white\"\r\n                        />\r\n                        <Star\r\n                            innerRadius={8}\r\n                            outerRadius={20}\r\n                            numPoints={5}\r\n                            stroke=\"black\"\r\n                            strokeWidth={1.5}\r\n                            x={37.5}\r\n                            y={270}\r\n                            draggable\r\n                            ref=\"draggableStar\"\r\n                            onDragEnd={e => {\r\n                                //add the rectangle to parent\r\n                                let name = 'star' + this.props.starName\r\n                                let toSend = {\r\n                                    x: e.target.x(),\r\n                                    y: e.target.y(),\r\n                                    innerRadius: 8,\r\n                                    outerRadius: 20,\r\n                                    numPoints: 5,\r\n                                    stroke: 'black',\r\n                                    strokeWidth: 1.5,\r\n                                    name: name,\r\n                                    fill: 'white',\r\n                                    ref: name,\r\n                                    rotation: 0\r\n                                }\r\n                                this.props.appendToStars(toSend)\r\n\r\n                                var star = this.refs.draggableStar\r\n\r\n                                star.position({\r\n                                    x: 37.5,\r\n                                    y: 270\r\n                                })\r\n                            }}\r\n                        />\r\n                        <Text\r\n                            fontSize={40}\r\n                            text=\"T\"\r\n                            fontFamily=\"Belgrano\"\r\n                            x={24}\r\n                            y={320}\r\n                        />\r\n                        <Text\r\n                            fontSize={40}\r\n                            text=\"T\"\r\n                            fontFamily=\"Belgrano\"\r\n                            x={24}\r\n                            y={320}\r\n                            draggable\r\n                            ref=\"draggableText\"\r\n                            onDragEnd={e => {\r\n                                //add the rectangle to parent\r\n                                let name = 'text' + this.props.textName\r\n                                let ref = 'text' + this.props.textName\r\n                                let toSend = {\r\n                                    x: e.target.x(),\r\n                                    y: e.target.y(),\r\n                                    fontSize: 25,\r\n                                    fontFamily: 'Belgrano',\r\n                                    ref: ref,\r\n                                    name: name,\r\n                                    text: '',\r\n                                    fill: 'black',\r\n                                    width: 300,\r\n                                    height: 25,\r\n                                    rotation: 0,\r\n                                    textWidth: this.refs.draggableText\r\n                                        .textWidth,\r\n                                    textHeight: this.refs.draggableText\r\n                                        .textHeight\r\n                                }\r\n                                console.log('tosend', toSend)\r\n                                this.props.appendToTexts(toSend)\r\n\r\n                                var text = this.refs.draggableText\r\n\r\n                                text.position({\r\n                                    x: 24,\r\n                                    y: 320\r\n                                })\r\n                            }}\r\n                        />\r\n                        <Arrow\r\n                            points={[20, 400, 50, 400]}\r\n                            fill=\"black\"\r\n                            stroke=\"black\"\r\n                        />\r\n                        <Arrow\r\n                            points={[20, 400, 50, 400]}\r\n                            fill=\"black\"\r\n                            stroke=\"black\"\r\n                            ref=\"draggableArrow\"\r\n                            name=\"draggableArrow\"\r\n                            draggable\r\n                            onDragStart={() => {\r\n                                this.refs.draggableArrow.setAttr('fill', 'grey')\r\n                                this.refs.draggableArrow.setAttr(\r\n                                    'stroke',\r\n                                    'grey'\r\n                                )\r\n                            }}\r\n                            onDragMove={() => {\r\n                                var pos = this.props.layer\r\n                                    .getStage()\r\n                                    .getPointerPosition()\r\n                                var shape = this.props.layer.getIntersection(\r\n                                    pos\r\n                                )\r\n\r\n                                //after first frame\r\n                                if (\r\n                                    this.state.previousShape !== undefined &&\r\n                                    this.state.previousShape !== null\r\n                                )\r\n                                    if (this.state.previousShape !== shape) {\r\n                                        //arrow entered a new shape\r\n\r\n                                        //the shape we left gets its original color back\r\n                                        if (\r\n                                            this.state.previousShape.attrs\r\n                                                .id !== 'ContainerRect' &&\r\n                                            !this.state.previousShape.attrs.name.includes(\r\n                                                'arrow'\r\n                                            )\r\n                                        ) {\r\n                                            this.refs.draggableArrow.setAttr(\r\n                                                'fill',\r\n                                                'black'\r\n                                            )\r\n                                            this.refs.draggableArrow.setAttr(\r\n                                                'stroke',\r\n                                                'black'\r\n                                            )\r\n                                        }\r\n                                    }\r\n                                    //if arrow is moving in a single shape\r\n                                    else if (\r\n                                        this.state.previousShape.attrs.id !==\r\n                                            'ContainerRect' &&\r\n                                        !shape.attrs.name.includes('arrow')\r\n                                    ) {\r\n                                        //if it the first time the shapes are same, set shape to blue, store the original color\r\n                                        this.refs.draggableArrow.setAttr(\r\n                                            'fill',\r\n                                            '#ccf5ff'\r\n                                        )\r\n                                        this.refs.draggableArrow.setAttr(\r\n                                            'stroke',\r\n                                            '#ccf5ff'\r\n                                        )\r\n                                    }\r\n\r\n                                this.props.layer.draw()\r\n\r\n                                this.setState({ previousShape: shape })\r\n                            }}\r\n                            onDragEnd={event => {\r\n                                var pos = this.props.layer\r\n                                    .getStage()\r\n                                    .getPointerPosition()\r\n                                var shape = this.props.layer.getIntersection(\r\n                                    pos\r\n                                )\r\n\r\n                                //shape is not containerRect, which means we are on a shape\r\n                                if (\r\n                                    shape &&\r\n                                    shape.attrs.id === undefined &&\r\n                                    !shape.attrs.name.includes('arrow')\r\n                                ) {\r\n                                    let toSend = {\r\n                                        x: pos.x,\r\n                                        y: pos.y,\r\n                                        points: [20, 475, 60, 475],\r\n                                        from: shape,\r\n                                        stroke: 'black',\r\n                                        strokeWidth: '1.5',\r\n                                        fill: 'black'\r\n                                    }\r\n                                    console.log('from shape', shape)\r\n                                    this.props.newArrowOnDragEnd(toSend)\r\n                                } else {\r\n                                    let toSend = {\r\n                                        x: pos.x,\r\n                                        y: pos.y,\r\n                                        points: [20, 475, 60, 475],\r\n                                        stroke: 'black',\r\n                                        strokeWidth: '1.5',\r\n                                        fill: 'black'\r\n                                    }\r\n\r\n                                    this.props.newArrowOnDragEnd(toSend)\r\n                                }\r\n\r\n                                //if shape is not arrow nor the containerRect then we make a connector instead\r\n\r\n                                //onDragEnd = dropping arrow down, create a new arrow with 2 same points at the dropped location\r\n                                //create new arrow in Graphics.js\r\n                                //from there, fire onMouseMove over the entire stage\r\n                                //the arrow's points should be the first point onDragEnd and the second should be the current\r\n                                //mouse position determined by onMouseMove event in stage\r\n                                var arrow = this.refs.draggableArrow\r\n                                arrow.position({ x: 0, y: 0 })\r\n                                arrow.setAttr('fill', 'black')\r\n                                arrow.setAttr('stroke', 'black')\r\n\r\n                                arrow.draw()\r\n                            }}\r\n                        />\r\n                    </React.Fragment>\r\n                ) : null}\r\n            </React.Fragment>\r\n        )\r\n    }\r\n}\r\n","import React, { Component } from \"react\";\r\n\r\nimport {\r\n  Stage,\r\n  Layer,\r\n  Rect,\r\n  Transformer,\r\n  Ellipse,\r\n  Star,\r\n  Text,\r\n  Arrow\r\n} from \"react-konva\";\r\nimport Connector from \"./Connector.jsx\";\r\nimport Toolbar from \"./Toolbar.js\";\r\n\r\nimport \"./Graphics.css\";\r\n\r\nclass TransformerComponent extends React.Component {\r\n  componentDidMount() {\r\n    this.checkNode();\r\n  }\r\n  componentDidUpdate() {\r\n    this.checkNode();\r\n  }\r\n  checkNode() {\r\n    const stage = this.transformer.getStage();\r\n\r\n    const { selectedShapeName } = this.props;\r\n    if (selectedShapeName === \"\") {\r\n      this.transformer.detach();\r\n      return;\r\n    }\r\n    const selectedNode = stage.findOne(\".\" + selectedShapeName);\r\n    if (selectedNode === this.transformer.node()) {\r\n      return;\r\n    }\r\n\r\n    if (selectedNode) {\r\n      this.transformer.attachTo(selectedNode);\r\n    } else {\r\n      this.transformer.detach();\r\n    }\r\n    this.transformer.getLayer().batchDraw();\r\n  }\r\n  render() {\r\n    if (this.props.selectedShapeName.includes(\"text\")) {\r\n      var stuff = (\r\n        <Transformer\r\n          ref={node => {\r\n            this.transformer = node;\r\n          }}\r\n          name=\"transformer\"\r\n          boundBoxFunc={(oldBox, newBox) => {\r\n            newBox.width = Math.max(30, newBox.width);\r\n            return newBox;\r\n          }}\r\n          enabledAnchors={[\"middle-left\", \"middle-right\"]}\r\n        />\r\n      );\r\n    } else if (this.props.selectedShapeName.includes(\"star\")) {\r\n      var stuff = (\r\n        <Transformer\r\n          ref={node => {\r\n            this.transformer = node;\r\n          }}\r\n          name=\"transformer\"\r\n          enabledAnchors={[\r\n            \"top-left\",\r\n            \"top-right\",\r\n            \"bottom-left\",\r\n            \"bottom-right\"\r\n          ]}\r\n        />\r\n      );\r\n    } else if (this.props.selectedShapeName.includes(\"arrow\")) {\r\n      var stuff = (\r\n        <Transformer\r\n          ref={node => {\r\n            this.transformer = node;\r\n          }}\r\n          name=\"transformer\"\r\n          resizeEnabled={false}\r\n          rotateEnabled={false}\r\n        />\r\n      );\r\n    } else {\r\n      var stuff = (\r\n        <Transformer\r\n          ref={node => {\r\n            this.transformer = node;\r\n          }}\r\n          name=\"transformer\"\r\n          keepRatio={true}\r\n        />\r\n      );\r\n    }\r\n    return stuff;\r\n  }\r\n}\r\n\r\nvar history = [];\r\nvar historyStep = 0;\r\n\r\nclass Graphics extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n\r\n    this.state = {\r\n      layerX: 0,\r\n      layerY: 0,\r\n      layerScale: 1,\r\n      selectedShapeName: \"\",\r\n      errMsg: \"\",\r\n      rectangles: [],\r\n      ellipses: [],\r\n      stars: [],\r\n      texts: [],\r\n      arrows: [],\r\n      connectors: [],\r\n      currentTextRef: \"\",\r\n      shouldTextUpdate: true,\r\n      textX: 0,\r\n      textY: 0,\r\n      textEditVisible: false,\r\n      arrowDraggable: false,\r\n      newArrowRef: \"\",\r\n      count: 0,\r\n      newArrowDropped: false,\r\n      newConnectorDropped: false,\r\n      arrowEndX: 0,\r\n      arrowEndY: 0,\r\n      isTransforming: false,\r\n      lastFill: null,\r\n\r\n      saving: null,\r\n      saved: [],\r\n      roadmapId: null,\r\n      alreadyCreated: false,\r\n      publishing: false,\r\n      title: \"\",\r\n      category: \"\",\r\n      description: \"\",\r\n      thumbnail: \"\",\r\n      isPasteDisabled: false,\r\n      ellipseDeleteCount: 0,\r\n      starDeleteCount: 0,\r\n      arrowDeleteCount: 0,\r\n      textDeleteCount: 0,\r\n      rectDeleteCount: 0\r\n    };\r\n\r\n    this.handleWheel = this.handleWheel.bind(this);\r\n\r\n  }\r\n\r\n  handleSave = () => {\r\n    const rects = this.state.rectangles,\r\n      ellipses = this.state.ellipses,\r\n      stars = this.state.stars,\r\n      texts = this.state.texts,\r\n      arrows = this.state.arrows;\r\n    if (\r\n      JSON.stringify(this.state.saved) !==\r\n      JSON.stringify([rects, ellipses, stars, texts, arrows])\r\n    ) {\r\n      this.setState({ saved: [rects, ellipses, stars, texts, arrows] });\r\n\r\n      let arrows1 = this.state.arrows;\r\n      arrows1.forEach(eachArrow => {\r\n        //for \"from & to of each arrow\"\r\n        if (eachArrow.from && eachArrow.from.attrs) {\r\n          if (eachArrow.from.attrs.name.includes(\"text\")) {\r\n            eachArrow.from.textWidth = eachArrow.from.textWidth;\r\n\r\n            eachArrow.from.textHeight = eachArrow.from.textHeight;\r\n          }\r\n        }\r\n        if (eachArrow.to && eachArrow.to.attrs) {\r\n          if (eachArrow.to.attrs.name.includes(\"text\")) {\r\n            eachArrow.to.attrs.textWidth = eachArrow.to.textWidth;\r\n            eachArrow.to.attrs.textHeight = eachArrow.to.textHeight;\r\n          }\r\n        }\r\n      });\r\n\r\n      if (this.state.roadmapId) {\r\n        //if draft already exists\r\n        this.setState({ saving: true });\r\n        fetch(\"/api/roadmap/modifyDraftDB\", {\r\n          method: \"POST\",\r\n          headers: { \"Content-Type\": \"application/json\" },\r\n          body: JSON.stringify({\r\n            roadmapId: this.state.roadmapId,\r\n\r\n            data: {\r\n              rects: rects,\r\n              ellipses: ellipses,\r\n              stars: stars,\r\n              texts: texts,\r\n              arrows: arrows1\r\n            }\r\n          })\r\n        }).then(res => {\r\n          this.setState({ saving: false });\r\n        });\r\n      } else {\r\n        //if first time pressing sav\r\n        this.setState({ saving: true });\r\n        fetch(\"/api/roadmap/saveRoadmapToDB\", {\r\n          method: \"POST\",\r\n          headers: { \"Content-Type\": \"application/json\" },\r\n          body: JSON.stringify({\r\n            userId: this.props.auth.user.id,\r\n            roadmapType: \"draft\",\r\n            data: {\r\n              rects: rects,\r\n              ellipses: ellipses,\r\n              stars: stars,\r\n              texts: texts,\r\n              arrows: arrows\r\n            }\r\n          })\r\n        }).then(res =>\r\n          res.json().then(data => {\r\n            this.setState({ saving: false });\r\n            this.setState({ roadmapId: data.roadmapId });\r\n          })\r\n        );\r\n      }\r\n    }\r\n  };\r\n\r\n  handleStageClick = e => {\r\n    var pos = this.refs.layer2.getStage().getPointerPosition();\r\n    var shape = this.refs.layer2.getIntersection(pos);\r\n\r\n    console.log(\"texts\", this.state.texts);\r\n\r\n    if (\r\n      shape !== null &&\r\n      shape.name() !== undefined &&\r\n      shape !== undefined &&\r\n      shape.name() !== undefined\r\n    ) {\r\n      this.setState(\r\n        {\r\n          selectedShapeName: shape.name()\r\n        },\r\n        () => {\r\n          this.refs.graphicStage.draw();\r\n        }\r\n      );\r\n    }\r\n\r\n    //arrow logic\r\n    if (this.state.newArrowRef !== \"\") {\r\n      if (this.state.previousShape) {\r\n        if (this.state.previousShape.attrs.id !== \"ContainerRect\") {\r\n          //console.log(this.refs.graphicStage.findOne(\".\" + this.state.newArrowRef));\r\n          //\r\n\r\n          this.state.arrows.map(eachArrow => {\r\n            if (eachArrow.name === this.state.newArrowRef) {\r\n              eachArrow.to = this.state.previousShape;\r\n            }\r\n          });\r\n\r\n          //console.log(newConnector, this.state.newArrowRef);\r\n          //newConnector.setAttr(\"to\", this.state.previousShape);\r\n          //console.log(newConnector);\r\n        }\r\n      }\r\n\r\n      //handle connector more\r\n      //if the currentArrow ref has a from, and that e.target.attrs.id isn't containerRect,\r\n      //then find the current shape with stage find name and then yeah\r\n      this.state.arrows.map(eachArrow => {\r\n        if (eachArrow.name === this.state.newArrowRef) {\r\n          eachArrow.fill = \"black\";\r\n          eachArrow.stroke = \"black\";\r\n        }\r\n      });\r\n      //arrow logic, there's e.evt.pageX, pageY\r\n      this.setState({\r\n        arrowDraggable: false,\r\n        newArrowRef: \"\"\r\n      });\r\n    }\r\n  };\r\n  handleMouseOver = event => {\r\n    //get the currennt arrow ref and modify its position by filtering & pushing again\r\n    //console.log(\"lastFill: \", this.state.lastFill);\r\n    var pos = this.refs.graphicStage.getPointerPosition();\r\n    var shape = this.refs.graphicStage.getIntersection(pos);\r\n\r\n    if (shape && shape.attrs.link) {\r\n      document.body.style.cursor = \"pointer\";\r\n    } else {\r\n      document.body.style.cursor = \"default\";\r\n    }\r\n\r\n    //if we are moving an arrow\r\n    if (this.state.newArrowRef !== \"\") {\r\n      //filling color logic:\r\n\r\n      var transform = this.refs.layer2.getAbsoluteTransform().copy();\r\n      transform.invert();\r\n\r\n      pos = transform.point(pos);\r\n      this.setState({ arrowEndX: pos.x, arrowEndY: pos.y });\r\n      //last non arrow object\r\n      if (shape && shape.attrs && shape.attrs.name != undefined) {\r\n        //  console.log(shape);\r\n        if (!shape.attrs.name.includes(\"arrow\")) {\r\n          //after first frame\r\n          if (this.state.previousShape)\r\n            if (this.state.previousShape !== shape) {\r\n              //arrow entered a new shape\r\n\r\n              //set current arrow to blue\r\n              if (this.state.previousShape.attrs.id !== \"ContainerRect\") {\r\n                this.state.arrows.map(eachArrow => {\r\n                  if (eachArrow.name === this.state.newArrowRef) {\r\n                    eachArrow.fill = \"black\";\r\n                    eachArrow.stroke = \"black\";\r\n                  }\r\n                });\r\n                this.forceUpdate();\r\n              } else {\r\n                this.state.arrows.map(eachArrow => {\r\n                  if (eachArrow.name === this.state.newArrowRef) {\r\n                    eachArrow.fill = \"#ccf5ff\";\r\n                    eachArrow.stroke = \"#ccf5ff\";\r\n                  }\r\n                });\r\n                this.forceUpdate();\r\n              }\r\n            }\r\n          //if arrow is moving in a single shape\r\n        }\r\n\r\n        if (!shape.attrs.name.includes(\"arrow\")) {\r\n          this.setState({ previousShape: shape });\r\n        }\r\n      }\r\n    }\r\n    var arrows = this.state.arrows;\r\n\r\n    arrows.map(eachArrow => {\r\n      if (eachArrow.name === this.state.newArrowRef) {\r\n        var index = arrows.indexOf(eachArrow);\r\n        let currentArrow = eachArrow;\r\n        currentArrow.points = [\r\n          currentArrow.points[0],\r\n          currentArrow.points[1],\r\n          pos.x,\r\n          pos.y\r\n          /*  event.evt.pageY -\r\n            document.getElementById(\"NavBar\").getBoundingClientRect().height */\r\n        ];\r\n\r\n        this.state.arrows[index] = currentArrow;\r\n      }\r\n    });\r\n  };\r\n  handleWheel(event) {\r\n    if (\r\n      this.state.rectangles.length === 0 &&\r\n      this.state.ellipses.length === 0 &&\r\n      this.state.stars.length === 0 &&\r\n      this.state.texts.length === 0 &&\r\n      this.state.arrows.length === 0\r\n    ) {\r\n    } else {\r\n      event.evt.preventDefault();\r\n      const scaleBy = 1.2;\r\n      const stage = this.refs.graphicStage;\r\n      const layer = this.refs.layer2;\r\n      const oldScale = layer.scaleX();\r\n      const mousePointTo = {\r\n        x:\r\n          stage.getPointerPosition().x / oldScale -\r\n          this.state.layerX / oldScale,\r\n        y:\r\n          stage.getPointerPosition().y / oldScale - this.state.layerY / oldScale\r\n      };\r\n\r\n      const newScale =\r\n        event.evt.deltaY < 0 ? oldScale * scaleBy : oldScale / scaleBy;\r\n\r\n      layer.scale({ x: newScale, y: newScale });\r\n\r\n      /*  console.log(\r\n        oldScale,\r\n        mousePointTo,\r\n        stage.getPointerPosition().x,\r\n        stage.getPointerPosition().y\r\n      );\r\n    */\r\n      this.setState({\r\n        layerScale: newScale,\r\n        layerX:\r\n          -(mousePointTo.x - stage.getPointerPosition().x / newScale) *\r\n          newScale,\r\n        layerY:\r\n          -(mousePointTo.y - stage.getPointerPosition().y / newScale) * newScale\r\n      });\r\n    }\r\n  }\r\n  componentDidUpdate(prevProps, prevState) {\r\n    let prevMainShapes = [\r\n      prevState.rectangles,\r\n      prevState.ellipses,\r\n      prevState.stars,\r\n      prevState.arrows,\r\n      prevState.connectors,\r\n      prevState.texts\r\n    ];\r\n    let currentMainShapes = [\r\n      this.state.rectangles,\r\n      this.state.ellipses,\r\n      this.state.stars,\r\n      this.state.arrows,\r\n      this.state.connectors,\r\n      this.state.texts\r\n    ];\r\n\r\n    if (!this.state.redoing && !this.state.isTransforming)\r\n      if (JSON.stringify(this.state) !== JSON.stringify(prevState)) {\r\n        if (\r\n          JSON.stringify(prevMainShapes) !== JSON.stringify(currentMainShapes)\r\n        ) {\r\n          //if text shouldn't update, don't append to  history\r\n          if (this.state.shouldTextUpdate) {\r\n            var uh = history;\r\n            history = uh.slice(0, historyStep + 1);\r\n            //console.log(\"sliced\", history);\r\n            var toAppend = this.state;\r\n            history = history.concat(toAppend);\r\n            //console.log(\"new\", history);\r\n            historyStep += 1;\r\n            //console.log(history, historyStep, history[historyStep]);\r\n          }\r\n        }\r\n      } else {\r\n        //console.log(\"compoenntDidUpdate but attrs didn't change\");\r\n      }\r\n    this.state.redoing = false;\r\n  }\r\n\r\n  handleUndo = () => {\r\n    if (!this.state.isTransforming) {\r\n      if (!this.state.textEditVisible) {\r\n        if (historyStep === 0) {\r\n          return;\r\n        }\r\n        historyStep -= 1;\r\n\r\n        this.setState(\r\n          {\r\n            rectangles: history[historyStep].rectangles,\r\n            arrows: history[historyStep].arrows,\r\n            ellipses: history[historyStep].ellipses,\r\n            stars: history[historyStep].stars,\r\n            texts: history[historyStep].texts,\r\n            connectors: history[historyStep].connectors,\r\n            redoing: true,\r\n            selectedShapeName: this.shapeIsGone(history[historyStep])\r\n              ? \"\"\r\n              : this.state.selectedShapeName\r\n          },\r\n          () => {\r\n            this.refs.graphicStage.draw();\r\n          }\r\n        );\r\n      }\r\n    }\r\n  };\r\n\r\n  handleRedo = () => {\r\n    if (historyStep === history.length - 1) {\r\n      return;\r\n    }\r\n    historyStep += 1;\r\n    const next = history[historyStep];\r\n    this.setState(\r\n      {\r\n        rectangles: next.rectangles,\r\n        arrows: next.arrows,\r\n        ellipses: next.ellipses,\r\n        stars: next.stars,\r\n        texts: next.texts,\r\n        redoing: true,\r\n        selectedShapeName: this.shapeIsGone(history[historyStep])\r\n          ? \"\"\r\n          : this.state.selectedShapeName\r\n      },\r\n      () => {\r\n        this.forceUpdate();\r\n      }\r\n    );\r\n  };\r\n\r\n  shapeIsGone = returnTo => {\r\n    var toReturn = true;\r\n    let currentShapeName = this.state.selectedShapeName;\r\n    let [rectangles, ellipses, stars, arrows, texts] = [\r\n      returnTo.rectangles,\r\n      returnTo.ellipses,\r\n      returnTo.stars,\r\n      returnTo.arrows,\r\n\r\n      returnTo.texts\r\n    ];\r\n    rectangles.map(eachRect => {\r\n      if (eachRect.name === currentShapeName) {\r\n        toReturn = false;\r\n      }\r\n    });\r\n    ellipses.map(eachEllipse => {\r\n      if (eachEllipse.name === currentShapeName) {\r\n        toReturn = false;\r\n      }\r\n    });\r\n    stars.map(eachStar => {\r\n      if (eachStar.name === currentShapeName) {\r\n        toReturn = false;\r\n      }\r\n    });\r\n    arrows.map(eachArrow => {\r\n      if (eachArrow.name === currentShapeName) {\r\n        toReturn = false;\r\n      }\r\n    });\r\n\r\n    texts.map(eachText => {\r\n      if (eachText.name === currentShapeName) {\r\n        toReturn = false;\r\n      }\r\n    });\r\n\r\n    return toReturn;\r\n  };\r\n  IsJsonString = str => {\r\n    try {\r\n      JSON.parse(str);\r\n    } catch (e) {\r\n      return false;\r\n    }\r\n    return true;\r\n  };\r\n\r\n  async componentDidMount() {\r\n    history.push(this.state);\r\n    this.setState({ selectedShapeName: \"\" });\r\n\r\n\r\n\r\n    //if draft\r\n\r\n  }\r\n\r\n  render() {\r\n    let saveText;\r\n\r\n    let saving = this.state.saving;\r\n    if (saving !== null) {\r\n      if (saving) {\r\n        saveText = <div style={{ color: \"white\" }}>Saving</div>;\r\n      } else {\r\n        saveText = <div style={{ color: \"white\" }}>Saved</div>;\r\n      }\r\n    }\r\n\r\n    const canvas = document.createElement(\"canvas\");\r\n    const ctx = canvas.getContext(\"2d\");\r\n\r\n    var gradient = ctx.createLinearGradient(0, 0, 100, 100);\r\n    gradient.addColorStop(0.0, \"red\");\r\n    gradient.addColorStop(1 / 6, \"orange\");\r\n    gradient.addColorStop(2 / 6, \"yellow\");\r\n    gradient.addColorStop(3 / 6, \"green\");\r\n    gradient.addColorStop(4 / 6, \"aqua\");\r\n    gradient.addColorStop(5 / 6, \"blue\");\r\n    gradient.addColorStop(1.0, \"purple\");\r\n\r\n    const errMsg = this.state.errMsg;\r\n    let errDisplay;\r\n    if (errMsg !== \"\") {\r\n      errDisplay = (\r\n        <div className=\"errMsginner\">\r\n          <span style={{ color: \"white\" }}>\r\n            {errMsg !== \"\" ? errMsg : null}\r\n          </span>\r\n        </div>\r\n      );\r\n    } else {\r\n    }\r\n\r\n    const countryOptions = [\r\n      { key: \"1\", value: \"Machine Learning\", text: \"Machine Learning\" },\r\n      { key: \"2\", value: \"Computer Science\", text: \"Computer Science\" },\r\n      {\r\n        key: \"3\",\r\n        value: \"Software Engineering\",\r\n        text: \"Software Engineering\"\r\n      },\r\n      { key: \"12\", value: \"Technology\", text: \"Technology\" },\r\n      { key: \"4\", value: \"Engineering\", text: \"Engineering\" },\r\n\r\n      {\r\n        key: \"6\",\r\n        value: \"Sciences and Mathematics\",\r\n        text: \"Sciences and Mathematics\"\r\n      },\r\n      {\r\n        key: \"7\",\r\n        value: \"Law, Economics and Social Sciences\",\r\n        text: \"Law, Economics and Social Sciences\"\r\n      },\r\n      { key: \"8\", value: \"Humanities\", text: \"Humanities\" },\r\n      {\r\n        key: \"9\",\r\n        value: \"Linguistics and Cultural Studies\",\r\n        text: \"Linguistics and Cultural Studies\"\r\n      },\r\n      { key: \"10\", value: \"Art and Music\", text: \"Art and Music\" },\r\n      { key: \"11\", value: \"Lifestyle\", text: \"Lifestyle\" },\r\n      {\r\n        key: \"13\",\r\n        value: \"Others\",\r\n        text: \"Others\"\r\n      }\r\n    ];\r\n\r\n    return (\r\n      <React.Fragment>\r\n        <div\r\n          onKeyDown={event => {\r\n            const x = 88,\r\n              deleteKey = 46,\r\n              copy = 67,\r\n              paste = 86,\r\n              z = 90,\r\n              y = 89;\r\n\r\n            if (\r\n              ((event.ctrlKey && event.keyCode === x) ||\r\n                event.keyCode === deleteKey) &&\r\n              !this.state.isPasteDisabled\r\n            ) {\r\n              if (this.state.selectedShapeName !== \"\") {\r\n                var that = this;\r\n                //delete it from the state too\r\n                let name = this.state.selectedShapeName;\r\n                let rectDeleted = false,\r\n                  ellipseDeleted = false,\r\n                  starDeleted = false,\r\n                  arrowDeleted = false,\r\n                  textDeleted = false;\r\n\r\n                var rects = this.state.rectangles.filter(function(eachRect) {\r\n                  if (eachRect.name === name) {\r\n                    that.setState({\r\n                      rectDeleteCount: that.state.rectDeleteCount + 1\r\n                    });\r\n                  }\r\n                  return eachRect.name !== name;\r\n                });\r\n\r\n                var ellipses = this.state.ellipses.filter(function(eachRect) {\r\n                  if (eachRect.name === name) {\r\n                    that.setState({\r\n                      ellipseDeleteCount: that.state.ellipseDeleteCount + 1\r\n                    });\r\n                  }\r\n                  return eachRect.name !== name;\r\n                });\r\n\r\n                var stars = this.state.stars.filter(function(eachRect) {\r\n                  if (eachRect.name === name) {\r\n                    that.setState({\r\n                      starDeleteCount: that.state.starDeleteCount + 1\r\n                    });\r\n                  }\r\n                  return eachRect.name !== name;\r\n                });\r\n\r\n                var arrows = this.state.arrows.filter(function(eachRect) {\r\n                  if (eachRect.name === name) {\r\n                    that.setState({\r\n                      arrowDeleteCount: that.state.arrowDeleteCount + 1\r\n                    });\r\n                  }\r\n                  return eachRect.name !== name;\r\n                });\r\n\r\n                var texts = this.state.texts.filter(function(eachRect) {\r\n                  if (eachRect.name === name) {\r\n                    that.setState({\r\n                      textDeleteCount: that.state.textDeleteCount + 1\r\n                    });\r\n                  }\r\n                  return eachRect.name !== name;\r\n                });\r\n\r\n                this.setState({\r\n                  rectangles: rects,\r\n                  ellipses: ellipses,\r\n                  stars: stars,\r\n                  arrows: arrows,\r\n                  texts: texts,\r\n                  selectedShapeName: \"\"\r\n                });\r\n              }\r\n            } else if (event.shiftKey && event.ctrlKey && event.keyCode === z) {\r\n              this.handleRedo();\r\n            } else if (event.ctrlKey && event.keyCode === z) {\r\n              this.handleUndo();\r\n            } else if (event.ctrlKey && event.keyCode === y) {\r\n              this.handleRedo();\r\n            } else if (event.ctrlKey && event.keyCode === copy) {\r\n              if (this.state.selectedShapeName !== \"\") {\r\n                //find it\r\n                let name = this.state.selectedShapeName;\r\n                let copiedElement = null;\r\n                if (name.includes(\"rect\")) {\r\n                  copiedElement = this.state.rectangles.filter(function(\r\n                    eachRect\r\n                  ) {\r\n                    return eachRect.name === name;\r\n                  });\r\n                } else if (name.includes(\"ellipse\")) {\r\n                  copiedElement = this.state.ellipses.filter(function(\r\n                    eachRect\r\n                  ) {\r\n                    return eachRect.name === name;\r\n                  });\r\n                } else if (name.includes(\"star\")) {\r\n                  copiedElement = this.state.stars.filter(function(eachRect) {\r\n                    return eachRect.name === name;\r\n                  });\r\n                } else if (name.includes(\"text\")) {\r\n                  copiedElement = this.state.texts.filter(function(eachRect) {\r\n                    return eachRect.name === name;\r\n                  });\r\n                } else if (name.includes(\"arrow\")) {\r\n                  copiedElement = this.state.arrows.filter(function(eachRect) {\r\n                    return eachRect.name === name;\r\n                  });\r\n                }\r\n\r\n                this.setState({ copiedElement: copiedElement }, () => {\r\n                  console.log(\"copied ele\", this.state.copiedElement);\r\n                });\r\n              }\r\n            } else if (\r\n              event.ctrlKey &&\r\n              event.keyCode === paste &&\r\n              !this.state.isPasteDisabled\r\n            ) {\r\n              let copiedElement = this.state.copiedElement[0];\r\n              console.log(copiedElement);\r\n              var length;\r\n              if (copiedElement) {\r\n                if (copiedElement.attrs) {\r\n                } else {\r\n                  if (copiedElement.name.includes(\"rectangle\")) {\r\n                    length =\r\n                      this.state.rectangles.length +\r\n                      1 +\r\n                      this.state.rectDeleteCount;\r\n                    var toPush = {\r\n                      x: copiedElement.x + 10,\r\n                      y: copiedElement.y + 10,\r\n                      width: copiedElement.width,\r\n                      height: copiedElement.height,\r\n                      stroke: copiedElement.stroke,\r\n                      strokeWidth: copiedElement.strokeWidth,\r\n                      name:\r\n                        \"rectangle\" +\r\n                        (this.state.rectangles.length +\r\n                          this.state.rectDeleteCount +\r\n                          1),\r\n                      ref:\r\n                        \"rectangle\" +\r\n                        (this.state.rectangles.length +\r\n                          this.state.rectDeleteCount +\r\n                          1),\r\n                      fill: copiedElement.fill,\r\n                      useImage: copiedElement.useImage,\r\n                      link: copiedElement.link,\r\n                      rotation: copiedElement.rotation\r\n                    };\r\n                    let newName = this.state.selectedShapeName;\r\n\r\n                    this.setState(\r\n                      prevState => ({\r\n                        rectangles: [...prevState.rectangles, toPush]\r\n                      }),\r\n                      () => {\r\n                        this.setState({\r\n                          selectedShapeName:\r\n                            \"rectangle\" + this.state.rectangles.length\r\n                        });\r\n                      }\r\n                    );\r\n                  } else if (copiedElement.name.includes(\"arrow\")) {\r\n                    length =\r\n                      this.state.arrows.length +\r\n                      1 +\r\n                      this.state.arrowDeleteCount;\r\n\r\n                    if (copiedElement.to || copiedElement.from) {\r\n                      this.setState(\r\n                        {\r\n                          errMsg: \"Connectors cannot be pasted\"\r\n                        },\r\n                        () => {\r\n                          var that = this;\r\n                          setTimeout(function() {\r\n                            that.setState({\r\n                              errMsg: \"\"\r\n                            });\r\n                          }, 1000);\r\n                        }\r\n                      );\r\n                    } else {\r\n                      var toPush = {\r\n                        points: [\r\n                          copiedElement.points[0] + 30,\r\n                          copiedElement.points[1] + 30,\r\n                          copiedElement.points[2] + 30,\r\n                          copiedElement.points[3] + 30\r\n                        ],\r\n                        fill: copiedElement.fill,\r\n                        link: copiedElement.link,\r\n                        stroke: copiedElement.stroke,\r\n                        strokeWidth: copiedElement.strokeWidth,\r\n                        name:\r\n                          \"arrow\" +\r\n                          (this.state.arrows.length +\r\n                            1 +\r\n                            this.state.arrowDeleteCount),\r\n                        ref:\r\n                          \"arrow\" +\r\n                          (this.state.arrows.length +\r\n                            1 +\r\n                            this.state.arrowDeleteCount),\r\n                        rotation: copiedElement.rotation\r\n                      };\r\n\r\n                      let newName = this.state.selectedShapeName;\r\n\r\n                      this.setState(\r\n                        prevState => ({\r\n                          arrows: [...prevState.arrows, toPush]\r\n                        }),\r\n                        () => {\r\n                          this.setState({\r\n                            selectedShapeName:\r\n                              \"arrow\" + this.state.arrows.length\r\n                          });\r\n                        }\r\n                      );\r\n                    }\r\n                  } else if (copiedElement.name.includes(\"ellipse\")) {\r\n                    length =\r\n                      this.state.ellipses.length +\r\n                      1 +\r\n                      this.state.ellipseDeleteCount;\r\n                    var toPush = {\r\n                      x: copiedElement.x + 10,\r\n                      y: copiedElement.y + 10,\r\n                      radiusX: copiedElement.radiusX,\r\n                      radiusY: copiedElement.radiusY,\r\n                      stroke: copiedElement.stroke,\r\n                      strokeWidth: copiedElement.strokeWidth,\r\n                      name:\r\n                        \"ellipse\" +\r\n                        (this.state.ellipses.length +\r\n                          1 +\r\n                          this.state.ellipseDeleteCount),\r\n                      ref:\r\n                        \"ellipse\" +\r\n                        (this.state.ellipses.length +\r\n                          1 +\r\n                          this.state.ellipseDeleteCount),\r\n                      fill: copiedElement.fill,\r\n                      link: copiedElement.link,\r\n                      useImage: copiedElement.useImage,\r\n                      rotation: copiedElement.rotation\r\n                    };\r\n                    let newName = this.state.selectedShapeName;\r\n\r\n                    this.setState(\r\n                      prevState => ({\r\n                        ellipses: [...prevState.ellipses, toPush]\r\n                      }),\r\n                      () => {\r\n                        this.setState({\r\n                          selectedShapeName:\r\n                            \"ellipse\" + this.state.ellipses.length\r\n                        });\r\n                      }\r\n                    );\r\n                  } else if (copiedElement.name.includes(\"star\")) {\r\n                    length =\r\n                      this.state.stars.length + 1 + this.state.starDeleteCount;\r\n                    var toPush = {\r\n                      x: copiedElement.x + 10,\r\n                      y: copiedElement.y + 10,\r\n                      link: copiedElement.link,\r\n                      innerRadius: copiedElement.innerRadius,\r\n                      outerRadius: copiedElement.outerRadius,\r\n                      stroke: copiedElement.stroke,\r\n                      strokeWidth: copiedElement.strokeWidth,\r\n                      name:\r\n                        \"star\" +\r\n                        (this.state.stars.length +\r\n                          1 +\r\n                          this.state.starDeleteCount),\r\n                      ref:\r\n                        \"star\" +\r\n                        (this.state.stars.length +\r\n                          1 +\r\n                          this.state.starDeleteCount),\r\n                      fill: copiedElement.fill,\r\n                      useImage: copiedElement.useImage,\r\n                      rotation: copiedElement.rotation\r\n                    };\r\n                    let newName = this.state.selectedShapeName;\r\n\r\n                    this.setState(\r\n                      prevState => ({\r\n                        stars: [...prevState.stars, toPush]\r\n                      }),\r\n                      () => {\r\n                        this.setState({\r\n                          selectedShapeName: \"star\" + this.state.stars.length\r\n                        });\r\n                      }\r\n                    );\r\n                  } else if (copiedElement.name.includes(\"text\")) {\r\n                    length =\r\n                      this.state.texts.length + 1 + this.state.textDeleteCount;\r\n                    var toPush = {\r\n                      x: copiedElement.x + 10,\r\n                      y: copiedElement.y + 10,\r\n                      link: copiedElement.link,\r\n\r\n                      name:\r\n                        \"text\" +\r\n                        (this.state.texts.length +\r\n                          1 +\r\n                          this.state.textDeleteCount),\r\n                      ref:\r\n                        \"text\" +\r\n                        (this.state.texts.length +\r\n                          1 +\r\n                          this.state.textDeleteCount),\r\n                      fill: copiedElement.fill,\r\n                      fontSize: copiedElement.fontSize,\r\n                      fontFamily: copiedElement.fontFamily,\r\n                      useImage: copiedElement.useImage,\r\n                      text: copiedElement.text,\r\n                      width: copiedElement.width,\r\n                      rotation: copiedElement.rotation\r\n                    };\r\n                    let newName = this.state.selectedShapeName;\r\n\r\n                    this.setState(\r\n                      prevState => ({\r\n                        texts: [...prevState.texts, toPush]\r\n                      }),\r\n                      () => {\r\n                        this.setState(\r\n                          {\r\n                            selectedShapeName:\r\n                              \"text\" +\r\n                              (this.state.texts.length +\r\n                                this.state.textDeleteCount)\r\n                          },\r\n                          () => {\r\n                            console.log(this.state.selectedShapeName);\r\n                          }\r\n                        );\r\n                      }\r\n                    );\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }}\r\n          tabIndex=\"0\"\r\n          style={{ outline: \"none\" }}\r\n        >\r\n          <Stage\r\n            onClick={this.handleStageClick}\r\n            onMouseMove={this.handleMouseOver}\r\n            onWheel={event => this.handleWheel(event)}\r\n            height={window.innerHeight}\r\n            width={window.innerWidth}\r\n            ref=\"graphicStage\"\r\n          >\r\n            <Layer\r\n              scaleX={this.state.layerScale}\r\n              scaleY={this.state.layerScale}\r\n              x={this.state.layerX}\r\n              y={this.state.layerY}\r\n              height={window.innerHeight}\r\n              width={window.innerWidth}\r\n              draggable\r\n              onDragEnd={() => {\r\n                this.setState({\r\n                  layerX: this.refs.layer2.x(),\r\n                  layerY: this.refs.layer2.y()\r\n                });\r\n              }}\r\n              ref=\"layer2\"\r\n            >\r\n              <Rect\r\n                x={-5 * window.innerWidth}\r\n                y={-5 * window.innerHeight}\r\n                height={window.innerHeight * 10}\r\n                width={window.innerWidth * 10}\r\n                name=\"\"\r\n                id=\"ContainerRect\"\r\n              />\r\n\r\n              {this.state.rectangles.map(eachRect => {\r\n                return (\r\n                  <Rect\r\n                    onClick={() => {\r\n                      var that = this;\r\n                      if (eachRect.link !== undefined && eachRect.link !== \"\") {\r\n                        this.setState(\r\n                          {\r\n                            errMsg: \"Links will not be opened in create mode\"\r\n                          },\r\n                          () => {\r\n                            setTimeout(function() {\r\n                              that.setState({\r\n                                errMsg: \"\"\r\n                              });\r\n                            }, 1000);\r\n                          }\r\n                        );\r\n                      }\r\n                    }}\r\n                    onTransformStart={() => {\r\n                      this.setState({\r\n                        isTransforming: true\r\n                      });\r\n                      let rect = this.refs[eachRect.ref];\r\n                      rect.setAttr(\"lastRotation\", rect.rotation());\r\n                    }}\r\n                    onTransform={() => {\r\n                      let rect = this.refs[eachRect.ref];\r\n\r\n                      if (rect.attrs.lastRotation !== rect.rotation()) {\r\n                        this.state.arrows.map(eachArrow => {\r\n                          if (\r\n                            eachArrow.to &&\r\n                            eachArrow.to.name() === rect.name()\r\n                          ) {\r\n                            this.setState({\r\n                              errMsg:\r\n                                \"Rotating rects with connectors might skew things up!\"\r\n                            });\r\n                          }\r\n                          if (\r\n                            eachArrow.from &&\r\n                            eachArrow.from.name() === rect.name()\r\n                          ) {\r\n                            this.setState({\r\n                              errMsg:\r\n                                \"Rotating rects with connectors might skew things up!\"\r\n                            });\r\n                          }\r\n                        });\r\n                      }\r\n\r\n                      rect.setAttr(\"lastRotation\", rect.rotation());\r\n                    }}\r\n                    onTransformEnd={() => {\r\n                      this.setState({\r\n                        isTransforming: false\r\n                      });\r\n                      let rect = this.refs[eachRect.ref];\r\n                      this.setState(\r\n                        prevState => ({\r\n                          errMsg: \"\",\r\n                          rectangles: prevState.rectangles.map(eachRect =>\r\n                            eachRect.name === rect.attrs.name\r\n                              ? {\r\n                                  ...eachRect,\r\n                                  width: rect.width() * rect.scaleX(),\r\n                                  height: rect.height() * rect.scaleY(),\r\n                                  rotation: rect.rotation(),\r\n                                  x: rect.x(),\r\n                                  y: rect.y()\r\n                                }\r\n                              : eachRect\r\n                          )\r\n                        }),\r\n                        () => {\r\n                          this.forceUpdate();\r\n                        }\r\n                      );\r\n\r\n                      rect.setAttr(\"scaleX\", 1);\r\n                      rect.setAttr(\"scaleY\", 1);\r\n                    }}\r\n                    rotation={eachRect.rotation}\r\n                    ref={eachRect.ref}\r\n                    fill={eachRect.fill}\r\n                    name={eachRect.name}\r\n                    x={eachRect.x}\r\n                    y={eachRect.y}\r\n                    width={eachRect.width}\r\n                    height={eachRect.height}\r\n                    stroke={eachRect.stroke}\r\n                    strokeWidth={eachRect.strokeWidth}\r\n                    strokeScaleEnabled={false}\r\n                    draggable\r\n                    onDragMove={() => {\r\n                      this.state.arrows.map(eachArrow => {\r\n                        if (eachArrow.from !== undefined) {\r\n                          if (eachRect.name === eachArrow.from.attrs.name) {\r\n                            eachArrow.points = [\r\n                              eachRect.x,\r\n                              eachRect.y,\r\n                              eachArrow.points[2],\r\n                              eachArrow.points[3]\r\n                            ];\r\n                            this.forceUpdate();\r\n                          }\r\n                        }\r\n\r\n                        if (eachArrow.to !== undefined) {\r\n                          if (eachRect.name == eachArrow.to.attrs.name) {\r\n                            eachArrow.points = [\r\n                              eachArrow.points[0],\r\n                              eachArrow.points[1],\r\n                              eachRect.x,\r\n                              eachRect.y\r\n                            ];\r\n                            this.forceUpdate();\r\n                          }\r\n                        }\r\n                      });\r\n                    }}\r\n                    onDragEnd={event => {\r\n                      //cannot compare by name because currentSelected might not be the same\r\n                      //have to use ref, which appears to be overcomplicated\r\n                      var shape = this.refs[eachRect.ref];\r\n                      /*    this.state.rectangles.map(eachRect => {\r\n                          if (eachRect.name === shape.attrs.name) {\r\n                            shape.position({\r\n                              x: event.target.x(),\r\n                              y: event.target.y()\r\n                            });\r\n                          }\r\n                        });*/\r\n\r\n                      this.setState(prevState => ({\r\n                        rectangles: prevState.rectangles.map(eachRect =>\r\n                          eachRect.name === shape.attrs.name\r\n                            ? {\r\n                                ...eachRect,\r\n                                x: event.target.x(),\r\n                                y: event.target.y()\r\n                              }\r\n                            : eachRect\r\n                        )\r\n                      }));\r\n                    }}\r\n                  />\r\n                );\r\n              })}\r\n              {this.state.ellipses.map(eachEllipse => (\r\n                <Ellipse\r\n                  ref={eachEllipse.ref}\r\n                  name={eachEllipse.name}\r\n                  x={eachEllipse.x}\r\n                  y={eachEllipse.y}\r\n                  rotation={eachEllipse.rotation}\r\n                  radiusX={eachEllipse.radiusX}\r\n                  radiusY={eachEllipse.radiusY}\r\n                  fill={eachEllipse.fill}\r\n                  stroke={eachEllipse.stroke}\r\n                  strokeWidth={eachEllipse.strokeWidth}\r\n                  strokeScaleEnabled={false}\r\n                  onClick={() => {\r\n                    var that = this;\r\n                    if (\r\n                      eachEllipse.link !== undefined &&\r\n                      eachEllipse.link !== \"\"\r\n                    ) {\r\n                      this.setState(\r\n                        {\r\n                          errMsg: \"Links will not be opened in create mode\"\r\n                        },\r\n                        () => {\r\n                          setTimeout(function() {\r\n                            that.setState({\r\n                              errMsg: \"\"\r\n                            });\r\n                          }, 1000);\r\n                        }\r\n                      );\r\n                    }\r\n                  }}\r\n                  onTransformStart={() => {\r\n                    this.setState({ isTransforming: true });\r\n                    let ellipse = this.refs[eachEllipse.ref];\r\n                    ellipse.setAttr(\"lastRotation\", ellipse.rotation());\r\n                  }}\r\n                  onTransform={() => {\r\n                    let ellipse = this.refs[eachEllipse.ref];\r\n\r\n                    if (ellipse.attrs.lastRotation !== ellipse.rotation()) {\r\n                      this.state.arrows.map(eachArrow => {\r\n                        if (\r\n                          eachArrow.to &&\r\n                          eachArrow.to.name() === ellipse.name()\r\n                        ) {\r\n                          this.setState({\r\n                            errMsg:\r\n                              \"Rotating ellipses with connectors might skew things up!\"\r\n                          });\r\n                        }\r\n                        if (\r\n                          eachArrow.from &&\r\n                          eachArrow.from.name() === ellipse.name()\r\n                        ) {\r\n                          this.setState({\r\n                            errMsg:\r\n                              \"Rotating ellipses with connectors might skew things up!\"\r\n                          });\r\n                        }\r\n                      });\r\n                    }\r\n\r\n                    ellipse.setAttr(\"lastRotation\", ellipse.rotation());\r\n                  }}\r\n                  onTransformEnd={() => {\r\n                    this.setState({ isTransforming: false });\r\n                    let ellipse = this.refs[eachEllipse.ref];\r\n                    let scaleX = ellipse.scaleX(),\r\n                      scaleY = ellipse.scaleY();\r\n\r\n                    this.setState(prevState => ({\r\n                      errMsg: \"\",\r\n                      ellipses: prevState.ellipses.map(eachEllipse =>\r\n                        eachEllipse.name === ellipse.attrs.name\r\n                          ? {\r\n                              ...eachEllipse,\r\n\r\n                              radiusX: ellipse.radiusX() * ellipse.scaleX(),\r\n                              radiusY: ellipse.radiusY() * ellipse.scaleY(),\r\n                              rotation: ellipse.rotation(),\r\n                              x: ellipse.x(),\r\n                              y: ellipse.y()\r\n                            }\r\n                          : eachEllipse\r\n                      )\r\n                    }));\r\n\r\n                    ellipse.setAttr(\"scaleX\", 1);\r\n                    ellipse.setAttr(\"scaleY\", 1);\r\n                    this.forceUpdate();\r\n                  }}\r\n                  draggable\r\n                  onDragMove={() => {\r\n                    console.log(\r\n                      \"name of ellipse moving: \",\r\n                      eachEllipse.name,\r\n                      \"new x y\",\r\n                      eachEllipse.x,\r\n                      eachEllipse.y\r\n                    );\r\n                    this.state.arrows.map(eachArrow => {\r\n                      if (eachArrow.from !== undefined) {\r\n                        console.log(\"prevArrow: \", eachArrow.points);\r\n                        if (eachEllipse.name == eachArrow.from.attrs.name) {\r\n                          eachArrow.points = [\r\n                            eachEllipse.x,\r\n                            eachEllipse.y,\r\n                            eachArrow.points[2],\r\n                            eachArrow.points[3]\r\n                          ];\r\n                          this.forceUpdate();\r\n                          this.refs.graphicStage.draw();\r\n                        }\r\n                        console.log(\"new arrows:\", eachArrow.points);\r\n                      }\r\n\r\n                      if (eachArrow.to !== undefined) {\r\n                        if (eachEllipse.name === eachArrow.to.attrs.name) {\r\n                          eachArrow.points = [\r\n                            eachArrow.points[0],\r\n                            eachArrow.points[1],\r\n                            eachEllipse.x,\r\n                            eachEllipse.y\r\n                          ];\r\n                          this.forceUpdate();\r\n                          this.refs.graphicStage.draw();\r\n                        }\r\n                      }\r\n                    });\r\n                  }}\r\n                  onDragEnd={event => {\r\n                    //cannot compare by name because currentSelected might not be the same\r\n                    //have to use ref, which appears to be overcomplicated\r\n                    var shape = this.refs[eachEllipse.ref];\r\n\r\n                    this.setState(prevState => ({\r\n                      ellipses: prevState.ellipses.map(eachEllipse =>\r\n                        eachEllipse.name === shape.attrs.name\r\n                          ? {\r\n                              ...eachEllipse,\r\n                              x: event.target.x(),\r\n                              y: event.target.y()\r\n                            }\r\n                          : eachEllipse\r\n                      )\r\n                    }));\r\n\r\n                    this.refs.graphicStage.draw();\r\n                  }}\r\n                />\r\n              ))}\r\n              {this.state.stars.map(eachStar => (\r\n                <Star\r\n                  ref={eachStar.ref}\r\n                  name={eachStar.name}\r\n                  x={eachStar.x}\r\n                  y={eachStar.y}\r\n                  innerRadius={eachStar.innerRadius}\r\n                  outerRadius={eachStar.outerRadius}\r\n                  numPoints={eachStar.numPoints}\r\n                  stroke={eachStar.stroke}\r\n                  strokeWidth={eachStar.strokeWidth}\r\n                  fill={eachStar.fill}\r\n                  strokeScaleEnabled={false}\r\n                  rotation={eachStar.rotation}\r\n                  onClick={() => {\r\n                    var that = this;\r\n                    if (eachStar.link !== undefined && eachStar.link !== \"\") {\r\n                      this.setState(\r\n                        {\r\n                          errMsg: \"Links will not be opened in create mode\"\r\n                        },\r\n                        () => {\r\n                          setTimeout(function() {\r\n                            that.setState({\r\n                              errMsg: \"\"\r\n                            });\r\n                          }, 1000);\r\n                        }\r\n                      );\r\n                    }\r\n                  }}\r\n                  onTransformStart={() => {\r\n                    this.setState({ isTransforming: true });\r\n                  }}\r\n                  onTransformEnd={() => {\r\n                    this.setState({ isTransforming: false });\r\n                    let star = this.refs[eachStar.ref];\r\n                    let scaleX = star.scaleX(),\r\n                      scaleY = star.scaleY();\r\n\r\n                    this.setState(prevState => ({\r\n                      stars: prevState.stars.map(eachStar =>\r\n                        eachStar.name === star.attrs.name\r\n                          ? {\r\n                              ...eachStar,\r\n                              innerRadius: star.innerRadius() * star.scaleX(),\r\n                              outerRadius: star.outerRadius() * star.scaleX(),\r\n                              rotation: star.rotation(),\r\n                              x: star.x(),\r\n                              y: star.y()\r\n                            }\r\n                          : eachStar\r\n                      )\r\n                    }));\r\n                    star.setAttr(\"scaleX\", 1);\r\n                    star.setAttr(\"scaleY\", 1);\r\n                    this.forceUpdate();\r\n                  }}\r\n                  draggable\r\n                  onDragMove={() => {\r\n                    this.state.arrows.map(eachArrow => {\r\n                      if (eachArrow.from !== undefined) {\r\n                        if (eachStar.name == eachArrow.from.attrs.name) {\r\n                          eachArrow.points = [\r\n                            eachStar.x,\r\n                            eachStar.y,\r\n                            eachArrow.points[2],\r\n                            eachArrow.points[3]\r\n                          ];\r\n                          this.forceUpdate();\r\n                        }\r\n                      }\r\n\r\n                      if (eachArrow.to !== undefined) {\r\n                        if (eachStar.name === eachArrow.to.attrs.name) {\r\n                          eachArrow.points = [\r\n                            eachArrow.points[0],\r\n                            eachArrow.points[1],\r\n                            eachStar.x,\r\n                            eachStar.y\r\n                          ];\r\n                          this.forceUpdate();\r\n                        }\r\n                      }\r\n                    });\r\n                  }}\r\n                  onDragEnd={event => {\r\n                    //cannot compare by name because currentSelected might not be the same\r\n                    //have to use ref, which appears to be overcomplicated\r\n                    var shape = this.refs[eachStar.ref];\r\n\r\n                    this.setState(prevState => ({\r\n                      stars: prevState.stars.map(eachStar =>\r\n                        eachStar.name === shape.attrs.name\r\n                          ? {\r\n                              ...eachStar,\r\n                              x: event.target.x(),\r\n                              y: event.target.y()\r\n                            }\r\n                          : eachStar\r\n                      )\r\n                    }));\r\n                  }}\r\n                />\r\n              ))}\r\n              {this.state.texts.map(eachText => (\r\n                //perhaps this.state.texts only need to contain refs?\r\n                //so that we only need to store the refs to get more information\r\n                <Text\r\n                  textDecoration={eachText.link ? \"underline\" : \"\"}\r\n                  onTransformStart={() => {\r\n                    var currentText = this.refs[this.state.selectedShapeName];\r\n                    currentText.setAttr(\"lastRotation\", currentText.rotation());\r\n                  }}\r\n                  onTransform={() => {\r\n                    var currentText = this.refs[this.state.selectedShapeName];\r\n\r\n                    currentText.setAttr(\r\n                      \"width\",\r\n                      currentText.width() * currentText.scaleX()\r\n                    );\r\n                    currentText.setAttr(\"scaleX\", 1);\r\n\r\n                    currentText.draw();\r\n\r\n                    if (\r\n                      currentText.attrs.lastRotation !== currentText.rotation()\r\n                    ) {\r\n                      this.state.arrows.map(eachArrow => {\r\n                        if (\r\n                          eachArrow.to &&\r\n                          eachArrow.to.name() === currentText.name()\r\n                        ) {\r\n                          this.setState({\r\n                            errMsg:\r\n                              \"Rotating texts with connectors might skew things up!\"\r\n                          });\r\n                        }\r\n                        if (\r\n                          eachArrow.from &&\r\n                          eachArrow.from.name() === currentText.name()\r\n                        ) {\r\n                          this.setState({\r\n                            errMsg:\r\n                              \"Rotating texts with connectors might skew things up!\"\r\n                          });\r\n                        }\r\n                      });\r\n                    }\r\n\r\n                    currentText.setAttr(\"lastRotation\", currentText.rotation());\r\n                  }}\r\n                  onTransformEnd={() => {\r\n                    var currentText = this.refs[this.state.selectedShapeName];\r\n\r\n                    this.setState(prevState => ({\r\n                      errMsg: \"\",\r\n                      texts: prevState.texts.map(eachText =>\r\n                        eachText.name === this.state.selectedShapeName\r\n                          ? {\r\n                              ...eachText,\r\n                              width: currentText.width(),\r\n                              rotation: currentText.rotation(),\r\n                              textWidth: currentText.textWidth,\r\n                              textHeight: currentText.textHeight,\r\n                              x: currentText.x(),\r\n                              y: currentText.y()\r\n                            }\r\n                          : eachText\r\n                      )\r\n                    }));\r\n                    currentText.setAttr(\"scaleX\", 1);\r\n                    currentText.draw();\r\n                  }}\r\n                  link={eachText.link}\r\n                  width={eachText.width}\r\n                  fill={eachText.fill}\r\n                  name={eachText.name}\r\n                  ref={eachText.ref}\r\n                  rotation={eachText.rotation}\r\n                  fontFamily={eachText.fontFamily}\r\n                  fontSize={eachText.fontSize}\r\n                  x={eachText.x}\r\n                  y={eachText.y}\r\n                  text={eachText.text}\r\n                  draggable\r\n                  onDragMove={() => {\r\n                    this.state.arrows.map(eachArrow => {\r\n                      if (eachArrow.from !== undefined) {\r\n                        if (eachText.name === eachArrow.from.attrs.name) {\r\n                          eachArrow.points = [\r\n                            eachText.x,\r\n                            eachText.y,\r\n                            eachArrow.points[2],\r\n                            eachArrow.points[3]\r\n                          ];\r\n                          this.forceUpdate();\r\n                        }\r\n                      }\r\n\r\n                      if (eachArrow.to !== undefined) {\r\n                        if (eachText.name === eachArrow.to.attrs.name) {\r\n                          eachArrow.points = [\r\n                            eachArrow.points[0],\r\n                            eachArrow.points[1],\r\n                            eachText.x,\r\n                            eachText.y\r\n                          ];\r\n                          this.forceUpdate();\r\n                        }\r\n                      }\r\n                    });\r\n                  }}\r\n                  onDragEnd={event => {\r\n                    //cannot compare by name because currentSelected might not be the same\r\n                    //have to use ref, which appears to be overcomplicated\r\n                    var shape = this.refs[eachText.ref];\r\n\r\n                    this.setState(prevState => ({\r\n                      texts: prevState.texts.map(eachtext =>\r\n                        eachtext.name === shape.attrs.name\r\n                          ? {\r\n                              ...eachtext,\r\n                              x: event.target.x(),\r\n                              y: event.target.y()\r\n                            }\r\n                          : eachtext\r\n                      )\r\n                    }));\r\n                  }}\r\n                  onClick={() => {\r\n                    var that = this;\r\n                    if (eachText.link !== undefined && eachText.link !== \"\") {\r\n                      this.setState(\r\n                        {\r\n                          errMsg: \"Links will not be opened in create mode\"\r\n                        },\r\n                        () => {\r\n                          setTimeout(function() {\r\n                            that.setState({\r\n                              errMsg: \"\"\r\n                            });\r\n                          }, 1000);\r\n                        }\r\n                      );\r\n\r\n                      //var win = window.open(eachText.link, \"_blank\");\r\n                      //win.focus();\r\n                    }\r\n                  }}\r\n                  onDblClick={() => {\r\n                    // turn into textarea\r\n                    var stage = this.refs.graphicStage;\r\n                    var text = stage.findOne(\".\" + eachText.name);\r\n\r\n                    this.setState({\r\n                      textX: text.absolutePosition().x,\r\n                      textY: text.absolutePosition().y,\r\n                      textEditVisible: !this.state.textEditVisible,\r\n                      text: eachText.text,\r\n                      textNode: eachText,\r\n                      currentTextRef: eachText.ref,\r\n                      textareaWidth: text.textWidth,\r\n                      textareaHeight: text.textHeight,\r\n                      textareaFill: text.attrs.fill,\r\n                      textareaFontFamily: text.attrs.fontFamily,\r\n                      textareaFontSize: text.attrs.fontSize\r\n                    });\r\n                    let textarea = this.refs.textarea;\r\n                    textarea.focus();\r\n                    text.hide();\r\n                    var transformer = stage.findOne(\".transformer\");\r\n                    transformer.hide();\r\n                    this.refs.layer2.draw();\r\n                  }}\r\n                />\r\n              ))}\r\n              {this.state.arrows.map(eachArrow => {\r\n                if (!eachArrow.from && !eachArrow.to) {\r\n                  return (\r\n                    <Arrow\r\n                      ref={eachArrow.ref}\r\n                      name={eachArrow.name}\r\n                      points={[\r\n                        eachArrow.points[0],\r\n                        eachArrow.points[1],\r\n                        eachArrow.points[2],\r\n                        eachArrow.points[3]\r\n                      ]}\r\n                      stroke={eachArrow.stroke}\r\n                      fill={eachArrow.fill}\r\n                      draggable\r\n                      onDragEnd={event => {\r\n                        //set new points to current position\r\n\r\n                        //usually: state => star => x & y\r\n                        //now: state => arrow => attr => x & y\r\n\r\n                        let oldPoints = [\r\n                          eachArrow.points[0],\r\n                          eachArrow.points[1],\r\n                          eachArrow.points[2],\r\n                          eachArrow.points[3]\r\n                        ];\r\n\r\n                        let shiftX = this.refs[eachArrow.ref].attrs.x;\r\n                        let shiftY = this.refs[eachArrow.ref].attrs.y;\r\n\r\n                        let newPoints = [\r\n                          oldPoints[0] + shiftX,\r\n                          oldPoints[1] + shiftY,\r\n                          oldPoints[2] + shiftX,\r\n                          oldPoints[3] + shiftY\r\n                        ];\r\n\r\n                        this.refs[eachArrow.ref].position({ x: 0, y: 0 });\r\n                        this.refs.layer2.draw();\r\n\r\n                        this.setState(prevState => ({\r\n                          arrows: prevState.arrows.map(eachArr =>\r\n                            eachArr.name === eachArrow.name\r\n                              ? {\r\n                                  ...eachArr,\r\n                                  points: newPoints\r\n                                }\r\n                              : eachArr\r\n                          )\r\n                        }));\r\n                      }}\r\n                    />\r\n                  );\r\n                } else if (\r\n                  eachArrow.name === this.state.newArrowRef &&\r\n                  (eachArrow.from || eachArrow.to)\r\n                ) {\r\n                  return (\r\n                    <Connector\r\n                      name={eachArrow.name}\r\n                      from={eachArrow.from}\r\n                      to={eachArrow.to}\r\n                      arrowEndX={this.state.arrowEndX}\r\n                      arrowEndY={this.state.arrowEndY}\r\n                      current={true}\r\n                      stroke={eachArrow.stroke}\r\n                      fill={eachArrow.fill}\r\n                    />\r\n                  );\r\n                } else if (eachArrow.from || eachArrow.to) {\r\n                  //if arrow construction is completed\r\n                  return (\r\n                    <Connector\r\n                      name={eachArrow.name}\r\n                      from={eachArrow.from}\r\n                      to={eachArrow.to}\r\n                      points={eachArrow.points}\r\n                      current={false}\r\n                      stroke={eachArrow.stroke}\r\n                      fill={eachArrow.fill}\r\n                    />\r\n                  );\r\n                }\r\n              })}\r\n\r\n              {this.state.selectedShapeName.includes(\"text\") ? (\r\n                <TransformerComponent\r\n                  selectedShapeName={this.state.selectedShapeName}\r\n                />\r\n              ) : (\r\n                <TransformerComponent\r\n                  selectedShapeName={this.state.selectedShapeName}\r\n                />\r\n              )}\r\n            </Layer>\r\n\r\n            <Layer\r\n              height={window.innerHeight}\r\n              width={window.innerWidth}\r\n              ref=\"layer\"\r\n            >\r\n              <Toolbar\r\n                layer={this.refs.layer2}\r\n                rectName={\r\n                  this.state.rectangles.length + 1 + this.state.rectDeleteCount\r\n                }\r\n                ellipseName={\r\n                  this.state.ellipses.length + 1 + this.state.ellipseDeleteCount\r\n                }\r\n                starName={\r\n                  this.state.stars.length + 1 + this.state.starDeleteCount\r\n                }\r\n                textName={\r\n                  this.state.texts.length + 1 + this.state.textDeleteCount\r\n                }\r\n                newArrowOnDragEnd={toPush => {\r\n                  if (toPush.from !== undefined) {\r\n                    //  console.log(\"we are making a connector\");\r\n\r\n                    var transform = this.refs.layer2\r\n                      .getAbsoluteTransform()\r\n                      .copy();\r\n                    transform.invert();\r\n                    let uh = transform.point({\r\n                      x: toPush.x,\r\n                      y: toPush.y\r\n                    });\r\n                    toPush.x = uh.x;\r\n                    toPush.y = uh.y;\r\n\r\n                    var newArrow = {\r\n                      points: toPush.points,\r\n                      ref:\r\n                        \"arrow\" +\r\n                        (this.state.arrows.length +\r\n                          1 +\r\n                          this.state.arrowDeleteCount),\r\n                      name:\r\n                        \"arrow\" +\r\n                        (this.state.arrows.length +\r\n                          1 +\r\n                          this.state.arrowDeleteCount),\r\n                      from: toPush.from,\r\n                      stroke: toPush.stroke,\r\n                      strokeWidth: toPush.strokeWidth,\r\n                      fill: toPush.fill\r\n                    };\r\n\r\n                    //  console.log(newArrow);\r\n                    this.setState(prevState => ({\r\n                      arrows: [...prevState.arrows, newArrow],\r\n                      newArrowDropped: true,\r\n                      newArrowRef: newArrow.name,\r\n                      arrowEndX: toPush.x,\r\n                      arrowEndY: toPush.y\r\n                    }));\r\n                  } else {\r\n                    //  console.log(\"we are making just an aarrow\");\r\n                    var transform = this.refs.layer2\r\n                      .getAbsoluteTransform()\r\n                      .copy();\r\n                    transform.invert();\r\n                    let uh = transform.point({\r\n                      x: toPush.x,\r\n                      y: toPush.y\r\n                    });\r\n                    toPush.x = uh.x;\r\n                    toPush.y = uh.y;\r\n                    var newArrow = {\r\n                      points: [toPush.x, toPush.y, toPush.x, toPush.y],\r\n                      ref:\r\n                        \"arrow\" +\r\n                        (this.state.arrows.length +\r\n                          1 +\r\n                          this.state.arrowDeleteCount),\r\n                      name:\r\n                        \"arrow\" +\r\n                        (this.state.arrows.length +\r\n                          1 +\r\n                          this.state.arrowDeleteCount),\r\n                      from: toPush.from,\r\n                      stroke: toPush.stroke,\r\n                      strokeWidth: toPush.strokeWidth,\r\n                      fill: toPush.fill\r\n                    };\r\n\r\n                    this.setState(prevState => ({\r\n                      arrows: [...prevState.arrows, newArrow],\r\n                      newArrowDropped: true,\r\n                      newArrowRef: newArrow.name,\r\n                      arrowEndX: toPush.x,\r\n                      arrowEndY: toPush.y\r\n                    }));\r\n                  }\r\n\r\n                  //this.refs updates after forceUpdate (because arrow gets instantiated), might be risky in the future\r\n                  //only this.state.arrows.length because it was pushed earlier, cancelling the +1\r\n                }}\r\n                appendToRectangles={stuff => {\r\n                  var layer = this.refs.layer2;\r\n                  var toPush = stuff;\r\n                  var stage = this.refs.graphicStage;\r\n                  var transform = this.refs.layer2\r\n                    .getAbsoluteTransform()\r\n                    .copy();\r\n                  transform.invert();\r\n\r\n                  var pos = transform.point({\r\n                    x: toPush.x,\r\n                    y: toPush.y\r\n                  });\r\n\r\n                  if (layer.attrs.x !== null || layer.attrs.x !== undefined) {\r\n                    toPush.x = pos.x;\r\n                    toPush.y = pos.y;\r\n                  }\r\n\r\n                  this.setState(prevState => ({\r\n                    rectangles: [...prevState.rectangles, toPush],\r\n                    selectedShapeName: toPush.name\r\n                  }));\r\n                }}\r\n                appendToEllipses={stuff => {\r\n                  var layer = this.refs.layer2;\r\n                  var toPush = stuff;\r\n                  var stage = this.refs.graphicStage;\r\n                  var transform = this.refs.layer2\r\n                    .getAbsoluteTransform()\r\n                    .copy();\r\n                  transform.invert();\r\n\r\n                  var pos = transform.point({\r\n                    x: toPush.x,\r\n                    y: toPush.y\r\n                  });\r\n\r\n                  if (layer.attrs.x !== null || layer.attrs.x !== undefined) {\r\n                    toPush.x = pos.x;\r\n                    toPush.y = pos.y;\r\n                  }\r\n\r\n                  this.setState(prevState => ({\r\n                    ellipses: [...prevState.ellipses, toPush],\r\n                    selectedShapeName: toPush.name\r\n                  }));\r\n                }}\r\n                appendToStars={stuff => {\r\n                  var layer = this.refs.layer2;\r\n                  var toPush = stuff;\r\n                  var stage = this.refs.graphicStage;\r\n                  var transform = this.refs.layer2\r\n                    .getAbsoluteTransform()\r\n                    .copy();\r\n                  transform.invert();\r\n\r\n                  var pos = transform.point({\r\n                    x: toPush.x,\r\n                    y: toPush.y\r\n                  });\r\n\r\n                  if (layer.attrs.x !== null || layer.attrs.x !== undefined) {\r\n                    toPush.x = pos.x;\r\n                    toPush.y = pos.y;\r\n                  }\r\n                  this.setState(prevState => ({\r\n                    stars: [...prevState.stars, toPush],\r\n                    selectedShapeName: toPush.name\r\n                  }));\r\n                }}\r\n                appendToTexts={stuff => {\r\n                  var layer = this.refs.layer2;\r\n                  var toPush = stuff;\r\n                  var stage = this.refs.graphicStage;\r\n                  var transform = this.refs.layer2\r\n                    .getAbsoluteTransform()\r\n                    .copy();\r\n                  transform.invert();\r\n\r\n                  var pos = transform.point({\r\n                    x: toPush.x,\r\n                    y: toPush.y\r\n                  });\r\n\r\n                  if (layer.attrs.x !== null || layer.attrs.x !== undefined) {\r\n                    toPush.x = pos.x;\r\n                    toPush.y = pos.y;\r\n                  }\r\n\r\n                  this.setState(prevState => ({\r\n                    texts: [...prevState.texts, toPush]\r\n                  }));\r\n\r\n                  //we can also just get element by this.refs.toPush.ref\r\n\r\n                  //  let text = stage.findOne(\".\" + toPush.name);\r\n                  let text = this.refs[toPush.ref];\r\n                  //this.setState({firstTimeTextEditing: true});\r\n                  text.fire(\"dblclick\");\r\n                }}\r\n              />\r\n            </Layer>\r\n          </Stage>\r\n\r\n          <textarea\r\n            ref=\"textarea\"\r\n            id=\"textarea\"\r\n            value={this.state.text}\r\n            onChange={e => {\r\n              this.setState({\r\n                text: e.target.value,\r\n                shouldTextUpdate: false\r\n              });\r\n            }}\r\n            onKeyDown={e => {\r\n              if (e.keyCode === 13) {\r\n                this.setState({\r\n                  textEditVisible: false,\r\n                  shouldTextUpdate: true\r\n                });\r\n\r\n                // get the current textNode we are editing, get the name from there\r\n                //match name with elements in this.state.texts,\r\n                let node = this.refs[this.state.currentTextRef];\r\n                console.log(\"node width before set\", node.textWidth);\r\n                let name = node.attrs.name;\r\n                this.setState(\r\n                  prevState => ({\r\n                    selectedShapeName: name,\r\n                    texts: prevState.texts.map(eachText =>\r\n                      eachText.name === name\r\n                        ? {\r\n                            ...eachText,\r\n                            text: this.state.text\r\n                          }\r\n                        : eachText\r\n                    )\r\n                  }),\r\n                  () => {\r\n                    this.setState(prevState => ({\r\n                      texts: prevState.texts.map(eachText =>\r\n                        eachText.name === name\r\n                          ? {\r\n                              ...eachText,\r\n                              textWidth: node.textWidth,\r\n                              textHeight: node.textHeight\r\n                            }\r\n                          : eachText\r\n                      )\r\n                    }));\r\n                  }\r\n                );\r\n\r\n                node.show();\r\n                this.refs.graphicStage.findOne(\".transformer\").show();\r\n              }\r\n            }}\r\n            onBlur={() => {\r\n              this.setState({\r\n                textEditVisible: false,\r\n                shouldTextUpdate: true\r\n              });\r\n\r\n              // get the current textNode we are editing, get the name from there\r\n              //match name with elements in this.state.texts,\r\n\r\n              let node = this.refs.graphicStage.findOne(\r\n                \".\" + this.state.currentTextRef\r\n              );\r\n              let name = node.attrs.name;\r\n\r\n              this.setState(\r\n                prevState => ({\r\n                  selectedShapeName: name,\r\n                  texts: prevState.texts.map(eachText =>\r\n                    eachText.name === name\r\n                      ? {\r\n                          ...eachText,\r\n                          text: this.state.text\r\n                        }\r\n                      : eachText\r\n                  )\r\n                }),\r\n                () => {\r\n                  this.setState(prevState => ({\r\n                    texts: prevState.texts.map(eachText =>\r\n                      eachText.name === name\r\n                        ? {\r\n                            ...eachText,\r\n                            textWidth: node.textWidth,\r\n                            textHeight: node.textHeight\r\n                          }\r\n                        : eachText\r\n                    )\r\n                  }));\r\n                }\r\n              );\r\n              node.show();\r\n              this.refs.graphicStage.findOne(\".transformer\").show();\r\n              this.refs.graphicStage.draw();\r\n            }}\r\n            style={{\r\n              //set position, width, height, fontSize, overflow, lineHeight, color\r\n              display: this.state.textEditVisible ? \"block\" : \"none\",\r\n              position: \"absolute\",\r\n              top: this.state.textY + 80 + \"px\",\r\n              left: this.state.textX + \"px\",\r\n              width: \"300px\",\r\n              height: \"300px\",\r\n              overflow: \"hidden\",\r\n              fontSize: this.state.textareaFontSize,\r\n              fontFamily: this.state.textareaFontFamily,\r\n              color: this.state.textareaFill,\r\n              border: \"none\",\r\n              padding: \"0px\",\r\n              margin: \"0px\",\r\n              outline: \"none\",\r\n              resize: \"none\",\r\n              background: \"none\"\r\n            }}\r\n          />\r\n          <div className=\"errMsg\">{errDisplay}</div>\r\n        </div>\r\n      </React.Fragment>\r\n    );\r\n  }\r\n}\r\nconst mapStateToProps = state => ({\r\n  auth: state.auth\r\n});\r\n\r\nexport default Graphics;\r\n","import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport { CSSTransition } from \"react-transition-group\";\r\n\r\nimport \"./styles.css\";\r\nimport ColoredRect from \"./App.js\";\r\n\r\nclass FadeInAndOut extends React.Component {\r\n  constructor(...args) {\r\n    super(...args);\r\n    this.state = { show: false };\r\n\r\n    setInterval(() => {\r\n      this.setState({ show: !this.state.show });\r\n    }, 2000);\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div>\r\n        <a\r\n          onClick={() => {\r\n            this.setState({ show: !this.state.show });\r\n          }}\r\n          style={{ cursor: \"pointer\", padding: \"20px\" }}\r\n        >\r\n          Woah\r\n        </a>\r\n        <CSSTransition in={this.state.show} timeout={1200} classNames=\"base\">\r\n          <div>Hello World</div>\r\n        </CSSTransition>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nReactDOM.render(<ColoredRect />, document.getElementById(\"root\"));\r\n"],"sourceRoot":""}