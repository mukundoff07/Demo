{"map":"{\"version\":3,\"sources\":[\"D:\\\\Freelancing\\\\Diagram Maker with reactjs\\\\Konva-Diagram-Maker\\\\src\\\\Connector.jsx\",\"D:\\\\Freelancing\\\\Diagram Maker with reactjs\\\\Konva-Diagram-Maker\\\\src\\\\Toolbar.js\",\"D:\\\\Freelancing\\\\Diagram Maker with reactjs\\\\Konva-Diagram-Maker\\\\src\\\\App.js\",\"D:\\\\Freelancing\\\\Diagram Maker with reactjs\\\\Konva-Diagram-Maker\\\\src\\\\index.js\"],\"names\":[\"Connector\",\"getConnectorPoints\",\"stuff\",\"points\",\"from\",\"to\",\"point\",\"mouseX\",\"mouseY\",\"type\",\"attrs\",\"name\",\"includes\",\"dy\",\"y\",\"height\",\"dx\",\"x\",\"width\",\"angle\",\"Math\",\"atan2\",\"PI\",\"fromTextHeight\",\"textHeight\",\"fromTextWidth\",\"textWidth\",\"origin\",\"radiusX\",\"cos\",\"radiusY\",\"sin\",\"outerRadius\",\"toTextHeight\",\"toTextWidth\",\"dy1\",\"dx1\",\"console\",\"log\",\"endPoint\",\"this\",\"props\",\"current\",\"arrowEndX\",\"arrowEndY\",\"toSend\",\"react_default\",\"a\",\"createElement\",\"ReactKonva\",\"strokeWidth\",\"stroke\",\"fill\",\"Component\",\"ToolBar\",\"shadowBlur\",\"shadowColor\",\"Toolbar\",\"state\",\"arrowDraggable\",\"previousShape\",\"undefined\",\"count\",\"isDragging\",\"_this2\",\"Fragment\",\"layer\",\"Toolbar_ToolBar\",\"draggable\",\"ref\",\"onDragEnd\",\"e\",\"ellipseName\",\"target\",\"rotation\",\"appendToEllipses\",\"refs\",\"draggableEllipse\",\"position\",\"rectName\",\"useImage\",\"appendToRectangles\",\"draggableRect\",\"innerRadius\",\"numPoints\",\"starName\",\"appendToStars\",\"draggableStar\",\"fontSize\",\"text\",\"fontFamily\",\"textName\",\"draggableText\",\"appendToTexts\",\"onDragStart\",\"draggableArrow\",\"setAttr\",\"onDragMove\",\"pos\",\"getStage\",\"getPointerPosition\",\"shape\",\"getIntersection\",\"id\",\"draw\",\"setState\",\"event\",\"newArrowOnDragEnd\",\"arrow\",\"TransformerComponent\",\"checkNode\",\"stage\",\"transformer\",\"selectedShapeName\",\"selectedNode\",\"findOne\",\"node\",\"attachTo\",\"detach\",\"getLayer\",\"batchDraw\",\"_this\",\"boundBoxFunc\",\"oldBox\",\"newBox\",\"max\",\"enabledAnchors\",\"resizeEnabled\",\"rotateEnabled\",\"keepRatio\",\"React\",\"history\",\"historyStep\",\"Graphics\",\"Object\",\"classCallCheck\",\"possibleConstructorReturn\",\"getPrototypeOf\",\"call\",\"handleSave\",\"rects\",\"rectangles\",\"ellipses\",\"stars\",\"texts\",\"arrows\",\"JSON\",\"stringify\",\"saved\",\"arrows1\",\"forEach\",\"eachArrow\",\"roadmapId\",\"saving\",\"fetch\",\"method\",\"headers\",\"Content-Type\",\"body\",\"data\",\"then\",\"res\",\"userId\",\"auth\",\"user\",\"roadmapType\",\"json\",\"handleStageClick\",\"layer2\",\"graphicStage\",\"newArrowRef\",\"map\",\"handleMouseOver\",\"link\",\"document\",\"style\",\"cursor\",\"transform\",\"getAbsoluteTransform\",\"copy\",\"invert\",\"forceUpdate\",\"index\",\"indexOf\",\"currentArrow\",\"handleUndo\",\"isTransforming\",\"textEditVisible\",\"connectors\",\"redoing\",\"shapeIsGone\",\"handleRedo\",\"length\",\"next\",\"returnTo\",\"toReturn\",\"currentShapeName\",\"_ref\",\"eachRect\",\"eachEllipse\",\"eachStar\",\"eachText\",\"IsJsonString\",\"str\",\"parse\",\"layerX\",\"layerY\",\"layerScale\",\"errMsg\",\"currentTextRef\",\"shouldTextUpdate\",\"textX\",\"textY\",\"newArrowDropped\",\"newConnectorDropped\",\"lastFill\",\"alreadyCreated\",\"publishing\",\"title\",\"category\",\"description\",\"thumbnail\",\"isPasteDisabled\",\"ellipseDeleteCount\",\"starDeleteCount\",\"arrowDeleteCount\",\"textDeleteCount\",\"rectDeleteCount\",\"handleWheel\",\"bind\",\"assertThisInitialized\",\"evt\",\"preventDefault\",\"oldScale\",\"scaleX\",\"mousePointTo\",\"newScale\",\"deltaY\",\"scale\",\"prevProps\",\"prevState\",\"prevMainShapes\",\"currentMainShapes\",\"slice\",\"toAppend\",\"concat\",\"push\",\"_this3\",\"color\",\"gradient\",\"getContext\",\"createLinearGradient\",\"addColorStop\",\"errDisplay\",\"className\",\"onKeyDown\",\"ctrlKey\",\"keyCode\",\"that\",\"filter\",\"shiftKey\",\"copiedElement\",\"toPush\",\"toConsumableArray\",\"setTimeout\",\"tabIndex\",\"outline\",\"onClick\",\"onMouseMove\",\"onWheel\",\"window\",\"innerHeight\",\"innerWidth\",\"scaleY\",\"onTransformStart\",\"rect\",\"onTransform\",\"lastRotation\",\"onTransformEnd\",\"objectSpread\",\"strokeScaleEnabled\",\"ellipse\",\"star\",\"textDecoration\",\"currentText\",\"eachtext\",\"onDblClick\",\"absolutePosition\",\"textNode\",\"textareaWidth\",\"textareaHeight\",\"textareaFill\",\"textareaFontFamily\",\"textareaFontSize\",\"textarea\",\"focus\",\"hide\",\"src_Connector\",\"oldPoints\",\"shiftX\",\"shiftY\",\"newPoints\",\"eachArr\",\"App_TransformerComponent\",\"Toolbar_Toolbar\",\"uh\",\"newArrow\",\"fire\",\"value\",\"onChange\",\"show\",\"onBlur\",\"display\",\"top\",\"left\",\"overflow\",\"border\",\"padding\",\"margin\",\"resize\",\"background\",\"ReactDOM\",\"render\",\"App\",\"getElementById\"],\"mappings\":\"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\",\"sourcesContent\":[\"import React, { Component } from 'react'\\r\\nimport { Arrow } from 'react-konva'\\r\\nclass Connector extends Component {\\r\\n    /*******uses current position of two shapes to determine the points of an arrow\\r\\n     ******************************************************************************/\\r\\n\\r\\n    getConnectorPoints = stuff => {\\r\\n        var points = stuff.points\\r\\n        var from = stuff.from\\r\\n        var to = stuff.to\\r\\n        var mouseX = stuff.mouseX\\r\\n        var mouseY = stuff.mouseY\\r\\n        var point = { x: mouseX, y: mouseY }\\r\\n\\r\\n        if (stuff.type === 'FromAndTo') {\\r\\n            if (\\r\\n                to.attrs.name.includes('rect') &&\\r\\n                from.attrs.name.includes('rect')\\r\\n            ) {\\r\\n                //only works for rect because the calculation for origin is different for ellipse and rect\\r\\n                var dy =\\r\\n                    to.attrs.y +\\r\\n                    to.attrs.height / 2 -\\r\\n                    (from.attrs.y + from.attrs.height / 2)\\r\\n                var dx =\\r\\n                    to.attrs.x +\\r\\n                    to.attrs.width / 2 -\\r\\n                    (from.attrs.x + from.attrs.width / 2)\\r\\n                var theta = Math.atan2(dy, dx)\\r\\n                let angle = (theta / Math.PI) * 180\\r\\n\\r\\n                if (angle <= 45 && angle >= -45) {\\r\\n                    points[0] += from.attrs.width\\r\\n                    points[1] += from.attrs.height / 2\\r\\n                    points[3] += to.attrs.height / 2\\r\\n                } else if (angle > 45 && angle < 135) {\\r\\n                    points[0] += from.attrs.width / 2\\r\\n                    points[1] += from.attrs.height\\r\\n                    points[2] += to.attrs.width / 2\\r\\n                } else if (\\r\\n                    (angle > 135 && angle < 180) ||\\r\\n                    (angle > -180 && angle < -135)\\r\\n                ) {\\r\\n                    points[1] += from.attrs.height / 2\\r\\n                    points[2] += to.attrs.width\\r\\n                    points[3] += to.attrs.height / 2\\r\\n                } else if (angle < -45 && angle > -135) {\\r\\n                    points[0] += from.attrs.width / 2\\r\\n                    points[3] += to.attrs.height\\r\\n                    points[2] += to.attrs.width / 2\\r\\n                }\\r\\n            } else if (\\r\\n                to.attrs.name.includes('rect') &&\\r\\n                from.attrs.name.includes('text')\\r\\n            ) {\\r\\n                //only works for rect because the calculation for origin is different for ellipse and rect\\r\\n\\r\\n                let fromTextHeight = from.textHeight || from.attrs.textHeight\\r\\n                let fromTextWidth = from.textWidth || from.attrs.textWidth\\r\\n                dy =\\r\\n                    to.attrs.y +\\r\\n                    to.attrs.height / 2 -\\r\\n                    (from.attrs.y + fromTextHeight / 2)\\r\\n                dx =\\r\\n                    to.attrs.x +\\r\\n                    to.attrs.width / 2 -\\r\\n                    (from.attrs.x + fromTextWidth / 2)\\r\\n                theta = Math.atan2(dy, dx)\\r\\n                let angle = (theta / Math.PI) * 180\\r\\n\\r\\n                if (angle <= 45 && angle >= -45) {\\r\\n                    points[0] += fromTextWidth\\r\\n                    points[1] += fromTextHeight / 2\\r\\n                    points[3] += to.attrs.height / 2\\r\\n                } else if (angle > 45 && angle < 135) {\\r\\n                    points[0] += fromTextWidth / 2\\r\\n                    points[1] += fromTextHeight\\r\\n                    points[2] += to.attrs.width / 2\\r\\n                } else if (\\r\\n                    (angle > 135 && angle < 180) ||\\r\\n                    (angle > -180 && angle < -135)\\r\\n                ) {\\r\\n                    points[1] += fromTextHeight / 2\\r\\n                    points[2] += to.attrs.width\\r\\n                    points[3] += to.attrs.height / 2\\r\\n                } else if (angle < -45 && angle > -135) {\\r\\n                    points[0] += fromTextWidth / 2\\r\\n                    points[3] += to.attrs.height\\r\\n                    points[2] += to.attrs.width / 2\\r\\n                }\\r\\n            } else if (\\r\\n                to.attrs.name.includes('ellipse') &&\\r\\n                from.attrs.name.includes('ellipse')\\r\\n            ) {\\r\\n                //two ellipses\\r\\n                var origin = { x: from.attrs.x, y: from.attrs.y }\\r\\n                const dy = points[3] - points[1]\\r\\n                const dx = points[2] - points[0]\\r\\n                let angle = Math.atan2(-dy, dx)\\r\\n                points[0] += -from.attrs.radiusX * Math.cos(angle + Math.PI)\\r\\n                points[1] += from.attrs.radiusY * Math.sin(angle + Math.PI)\\r\\n                points[2] += to.attrs.radiusX * Math.cos(angle + Math.PI)\\r\\n                points[3] -= to.attrs.radiusY * Math.sin(angle + Math.PI)\\r\\n            } else if (\\r\\n                to.attrs.name.includes('star') &&\\r\\n                from.attrs.name.includes('star')\\r\\n            ) {\\r\\n                origin = { x: from.attrs.x, y: from.attrs.y }\\r\\n                dy = points[3] - points[1]\\r\\n                dx = points[2] - points[0]\\r\\n                let angle = Math.atan2(-dy, dx)\\r\\n                points[0] += -from.attrs.outerRadius * Math.cos(angle + Math.PI)\\r\\n                points[1] += from.attrs.outerRadius * Math.sin(angle + Math.PI)\\r\\n                points[2] += to.attrs.outerRadius * Math.cos(angle + Math.PI)\\r\\n                points[3] -= to.attrs.outerRadius * Math.sin(angle + Math.PI)\\r\\n            } else if (\\r\\n                to.attrs.name.includes('text') &&\\r\\n                from.attrs.name.includes('text')\\r\\n            ) {\\r\\n                let fromTextHeight = from.textHeight || from.attrs.textHeight\\r\\n                let fromTextWidth = from.textWidth || from.attrs.textWidth\\r\\n                let toTextHeight = to.textHeight || to.attrs.textHeight\\r\\n                let toTextWidth = to.textWidth || to.attrs.textWidth\\r\\n                dy =\\r\\n                    to.attrs.y +\\r\\n                    toTextHeight / 2 -\\r\\n                    (from.attrs.y + fromTextHeight / 2)\\r\\n                dx =\\r\\n                    to.attrs.x +\\r\\n                    toTextWidth / 2 -\\r\\n                    (from.attrs.x + fromTextWidth / 2)\\r\\n                theta = Math.atan2(dy, dx)\\r\\n                let angle = (theta / Math.PI) * 180\\r\\n\\r\\n                if (angle <= 45 && angle >= -45) {\\r\\n                    points[0] += fromTextWidth\\r\\n                    points[1] += fromTextHeight / 2\\r\\n                    points[3] += toTextHeight / 2\\r\\n                } else if (angle > 45 && angle < 135) {\\r\\n                    points[0] += fromTextWidth / 2\\r\\n                    points[1] += fromTextHeight\\r\\n                    points[2] += toTextWidth / 2\\r\\n                } else if (\\r\\n                    (angle > 135 && angle < 180) ||\\r\\n                    (angle > -180 && angle < -135)\\r\\n                ) {\\r\\n                    points[1] += fromTextHeight / 2\\r\\n                    points[2] += toTextWidth\\r\\n                    points[3] += toTextHeight / 2\\r\\n                } else if (angle < -45 && angle > -135) {\\r\\n                    points[0] += fromTextWidth / 2\\r\\n                    points[3] += toTextHeight\\r\\n                    points[2] += toTextWidth / 2\\r\\n                }\\r\\n            } else if (\\r\\n                from.attrs.name.includes('rect') &&\\r\\n                to.attrs.name.includes('ellipse')\\r\\n            ) {\\r\\n                //rect change\\r\\n                var dy1 = to.attrs.y + -(from.attrs.y + from.attrs.height / 2)\\r\\n                var dx1 = to.attrs.x + -(from.attrs.x + from.attrs.width / 2)\\r\\n\\r\\n                theta = Math.atan2(dy1, dx1)\\r\\n                var angle = (theta / Math.PI) * 180\\r\\n                if (angle <= -45 && angle >= -135) {\\r\\n                    //top\\r\\n                    points[0] += from.attrs.width / 2\\r\\n                } else if (angle > 45 && angle < 135) {\\r\\n                    //bottom\\r\\n                    points[0] += from.attrs.width / 2\\r\\n                    points[1] += from.attrs.height\\r\\n                } else if (\\r\\n                    (angle > 135 && angle < 180) ||\\r\\n                    (angle > -180 && angle < -135)\\r\\n                ) {\\r\\n                    //left\\r\\n                    points[1] += from.attrs.height / 2\\r\\n                } else if (angle > -45 && angle < 45) {\\r\\n                    points[0] += from.attrs.width\\r\\n                    points[1] += from.attrs.height / 2\\r\\n                }\\r\\n                //ellipse change\\r\\n                const dy = points[3] - points[1]\\r\\n                const dx = points[2] - points[0]\\r\\n                angle = Math.atan2(-dy, dx)\\r\\n                //      console.log(dy, dx);\\r\\n\\r\\n                points[2] += to.attrs.radiusX * Math.cos(angle + Math.PI)\\r\\n                points[3] -= to.attrs.radiusY * Math.sin(angle + Math.PI)\\r\\n            } else if (\\r\\n                from.attrs.name.includes('rect') &&\\r\\n                to.attrs.name.includes('star')\\r\\n            ) {\\r\\n                //rect change\\r\\n                dy1 = to.attrs.y + -(from.attrs.y + from.attrs.height / 2)\\r\\n                dx1 = to.attrs.x + -(from.attrs.x + from.attrs.width / 2)\\r\\n\\r\\n                theta = Math.atan2(dy1, dx1)\\r\\n                angle = (theta / Math.PI) * 180\\r\\n                if (angle <= -45 && angle >= -135) {\\r\\n                    //top\\r\\n                    points[0] += from.attrs.width / 2\\r\\n                } else if (angle > 45 && angle < 135) {\\r\\n                    //bottom\\r\\n                    points[0] += from.attrs.width / 2\\r\\n                    points[1] += from.attrs.height\\r\\n                } else if (\\r\\n                    (angle > 135 && angle < 180) ||\\r\\n                    (angle > -180 && angle < -135)\\r\\n                ) {\\r\\n                    //left\\r\\n                    points[1] += from.attrs.height / 2\\r\\n                } else if (angle > -45 && angle < 45) {\\r\\n                    points[0] += from.attrs.width\\r\\n                    points[1] += from.attrs.height / 2\\r\\n                }\\r\\n                //ellipse change\\r\\n                const dy = points[3] - points[1]\\r\\n                const dx = points[2] - points[0]\\r\\n                angle = Math.atan2(-dy, dx)\\r\\n                //      console.log(dy, dx);\\r\\n\\r\\n                points[2] += to.attrs.outerRadius * Math.cos(angle + Math.PI)\\r\\n                points[3] -= to.attrs.outerRadius * Math.sin(angle + Math.PI)\\r\\n            } else if (\\r\\n                from.attrs.name.includes('rect') &&\\r\\n                to.attrs.name.includes('text')\\r\\n            ) {\\r\\n                //only works for rect because the calculation for origin is different for ellipse and rect\\r\\n                let toTextHeight = to.textHeight || to.attrs.textHeight\\r\\n                let toTextWidth = to.textWidth || to.attrs.textWidth\\r\\n                console.log(to)\\r\\n                dy =\\r\\n                    to.attrs.y +\\r\\n                    toTextHeight / 2 -\\r\\n                    (from.attrs.y + from.attrs.height / 2)\\r\\n                dx =\\r\\n                    to.attrs.x +\\r\\n                    toTextWidth / 2 -\\r\\n                    (from.attrs.x + from.attrs.width / 2)\\r\\n                var theta = Math.atan2(dy, dx)\\r\\n                let angle = (theta / Math.PI) * 180\\r\\n\\r\\n                /*  console.log(\\r\\n                    'from rect and to text',\\r\\n                    'angle: ',\\r\\n                    angle,\\r\\n                    'from',\\r\\n                    from,\\r\\n                    'to',\\r\\n                    to\\r\\n                )*/\\r\\n\\r\\n                if (angle <= 45 && angle >= -45) {\\r\\n                    points[0] += from.attrs.width\\r\\n                    points[1] += from.attrs.height / 2\\r\\n                    points[3] += toTextHeight / 2\\r\\n                } else if (angle > 45 && angle < 135) {\\r\\n                    points[0] += from.attrs.width / 2\\r\\n                    points[1] += from.attrs.height\\r\\n                    points[2] += toTextWidth / 2\\r\\n                } else if (\\r\\n                    (angle > 135 && angle < 180) ||\\r\\n                    (angle > -180 && angle < -135)\\r\\n                ) {\\r\\n                    points[1] += from.attrs.height / 2\\r\\n                    points[2] += toTextWidth\\r\\n                    points[3] += toTextHeight / 2\\r\\n                } else if (angle < -45 && angle > -135) {\\r\\n                    points[0] += from.attrs.width / 2\\r\\n                    points[3] += toTextHeight\\r\\n                    points[2] += toTextWidth / 2\\r\\n                }\\r\\n            } else if (\\r\\n                from.attrs.name.includes('ellipse') &&\\r\\n                to.attrs.name.includes('rect')\\r\\n            ) {\\r\\n                //rect change\\r\\n                dy1 = to.attrs.y + to.attrs.height / 2 - from.attrs.y\\r\\n                dx1 = to.attrs.x + to.attrs.width / 2 - from.attrs.x\\r\\n\\r\\n                theta = Math.atan2(dy1, dx1)\\r\\n                angle = (theta / Math.PI) * 180\\r\\n\\r\\n                if (angle <= -45 && angle >= -135) {\\r\\n                    //top\\r\\n                    points[2] += to.attrs.width / 2\\r\\n                    points[3] += to.attrs.height\\r\\n                } else if (angle > 45 && angle < 135) {\\r\\n                    //bottom\\r\\n                    points[2] += to.attrs.width / 2\\r\\n                } else if (\\r\\n                    (angle > 135 && angle < 180) ||\\r\\n                    (angle > -180 && angle < -135)\\r\\n                ) {\\r\\n                    //left\\r\\n                    points[2] += to.attrs.width\\r\\n                    points[3] += to.attrs.height / 2\\r\\n                } else if (angle > -45 && angle < 45) {\\r\\n                    points[3] += to.attrs.height / 2\\r\\n                }\\r\\n                //ellipse change\\r\\n                const dy = points[3] - points[1]\\r\\n                const dx = points[2] - points[0]\\r\\n                angle = Math.atan2(-dy, dx)\\r\\n                //      console.log(dy, dx);\\r\\n\\r\\n                points[0] -= from.attrs.radiusX * Math.cos(angle + Math.PI)\\r\\n                points[1] += from.attrs.radiusY * Math.sin(angle + Math.PI)\\r\\n            } else if (\\r\\n                from.attrs.name.includes('ellipse') &&\\r\\n                to.attrs.name.includes('text')\\r\\n            ) {\\r\\n                let toTextHeight = to.textHeight || to.attrs.textHeight\\r\\n                let toTextWidth = to.textWidth || to.attrs.textWidth\\r\\n                //rect change\\r\\n                dy1 = to.attrs.y + toTextHeight / 2 - from.attrs.y\\r\\n                dx1 = to.attrs.x + toTextWidth / 2 - from.attrs.x\\r\\n\\r\\n                theta = Math.atan2(dy1, dx1)\\r\\n                angle = (theta / Math.PI) * 180\\r\\n\\r\\n                if (angle <= -45 && angle >= -135) {\\r\\n                    //top\\r\\n                    points[2] += toTextWidth / 2\\r\\n                    points[3] += toTextHeight\\r\\n                } else if (angle > 45 && angle < 135) {\\r\\n                    //bottom\\r\\n                    points[2] += toTextWidth / 2\\r\\n                } else if (\\r\\n                    (angle > 135 && angle < 180) ||\\r\\n                    (angle > -180 && angle < -135)\\r\\n                ) {\\r\\n                    //left\\r\\n                    points[2] += toTextWidth\\r\\n                    points[3] += toTextHeight / 2\\r\\n                } else if (angle > -45 && angle < 45) {\\r\\n                    points[3] += toTextHeight / 2\\r\\n                }\\r\\n                //ellipse change\\r\\n                const dy = points[3] - points[1]\\r\\n                const dx = points[2] - points[0]\\r\\n                angle = Math.atan2(-dy, dx)\\r\\n                //      console.log(dy, dx);\\r\\n\\r\\n                points[0] -= from.attrs.radiusX * Math.cos(angle + Math.PI)\\r\\n                points[1] += from.attrs.radiusY * Math.sin(angle + Math.PI)\\r\\n\\r\\n                console.log(\\r\\n                    'new points',\\r\\n                    points,\\r\\n                    'from',\\r\\n                    from,\\r\\n                    'from coord',\\r\\n                    from.attrs\\r\\n                )\\r\\n            } else if (\\r\\n                from.attrs.name.includes('ellipse') &&\\r\\n                to.attrs.name.includes('star')\\r\\n            ) {\\r\\n                //two ellipses\\r\\n                origin = { x: from.attrs.x, y: from.attrs.y }\\r\\n                const dy = points[3] - points[1]\\r\\n                const dx = points[2] - points[0]\\r\\n                let angle = Math.atan2(-dy, dx)\\r\\n                points[0] += -from.attrs.radiusX * Math.cos(angle + Math.PI)\\r\\n                points[1] += from.attrs.radiusY * Math.sin(angle + Math.PI)\\r\\n                points[2] += to.attrs.outerRadius * Math.cos(angle + Math.PI)\\r\\n                points[3] -= to.attrs.outerRadius * Math.sin(angle + Math.PI)\\r\\n            } else if (\\r\\n                from.attrs.name.includes('star') &&\\r\\n                to.attrs.name.includes('ellipse')\\r\\n            ) {\\r\\n                //two ellipses\\r\\n                origin = { x: from.attrs.x, y: from.attrs.y }\\r\\n                const dy = points[3] - points[1]\\r\\n                const dx = points[2] - points[0]\\r\\n                let angle = Math.atan2(-dy, dx)\\r\\n                points[0] += -from.attrs.outerRadius * Math.cos(angle + Math.PI)\\r\\n                points[1] += from.attrs.outerRadius * Math.sin(angle + Math.PI)\\r\\n                points[2] += to.attrs.radiusX * Math.cos(angle + Math.PI)\\r\\n                points[3] -= to.attrs.radiusY * Math.sin(angle + Math.PI)\\r\\n            } else if (\\r\\n                from.attrs.name.includes('star') &&\\r\\n                to.attrs.name.includes('rect')\\r\\n            ) {\\r\\n                //two ellipses\\r\\n                dy1 = to.attrs.y + to.attrs.width / 2 - from.attrs.y\\r\\n                dx1 = to.attrs.x + to.attrs.width / 2 - from.attrs.x\\r\\n\\r\\n                theta = Math.atan2(dy1, dx1)\\r\\n                angle = (theta / Math.PI) * 180\\r\\n\\r\\n                if (angle <= -45 && angle >= -135) {\\r\\n                    //top\\r\\n                    points[2] += to.attrs.width / 2\\r\\n                    points[3] += to.attrs.height\\r\\n                } else if (angle > 45 && angle < 135) {\\r\\n                    //bottom\\r\\n                    points[2] += to.attrs.width / 2\\r\\n                } else if (\\r\\n                    (angle > 135 && angle < 180) ||\\r\\n                    (angle > -180 && angle < -135)\\r\\n                ) {\\r\\n                    //left\\r\\n                    points[2] += to.attrs.width\\r\\n                    points[3] += to.attrs.height / 2\\r\\n                } else if (angle > -45 && angle < 45) {\\r\\n                    points[3] += to.attrs.width / 2\\r\\n                }\\r\\n                //ellipse change\\r\\n                const dy = points[3] - points[1]\\r\\n                const dx = points[2] - points[0]\\r\\n                angle = Math.atan2(-dy, dx)\\r\\n                //      console.log(dy, dx);\\r\\n\\r\\n                points[0] -= from.attrs.outerRadius * Math.cos(angle + Math.PI)\\r\\n                points[1] += from.attrs.outerRadius * Math.sin(angle + Math.PI)\\r\\n            } else if (\\r\\n                from.attrs.name.includes('star') &&\\r\\n                to.attrs.name.includes('text')\\r\\n            ) {\\r\\n                let toTextHeight = to.textHeight || to.attrs.textHeight\\r\\n                let toTextWidth = to.textWidth || to.attrs.textWidth\\r\\n                //two ellipses\\r\\n                dy1 = to.attrs.y + toTextHeight / 2 - from.attrs.y\\r\\n                dx1 = to.attrs.x + toTextWidth / 2 - from.attrs.x\\r\\n\\r\\n                theta = Math.atan2(dy1, dx1)\\r\\n                angle = (theta / Math.PI) * 180\\r\\n\\r\\n                if (angle <= -45 && angle >= -135) {\\r\\n                    //top\\r\\n                    points[2] += toTextWidth / 2\\r\\n                    points[3] += toTextHeight\\r\\n                } else if (angle > 45 && angle < 135) {\\r\\n                    //bottom\\r\\n                    points[2] += toTextWidth / 2\\r\\n                } else if (\\r\\n                    (angle > 135 && angle < 180) ||\\r\\n                    (angle > -180 && angle < -135)\\r\\n                ) {\\r\\n                    //left\\r\\n                    points[2] += toTextWidth\\r\\n                    points[3] += toTextHeight / 2\\r\\n                } else if (angle > -45 && angle < 45) {\\r\\n                    points[3] += toTextHeight / 2\\r\\n                }\\r\\n                //ellipse change\\r\\n                const dy = points[3] - points[1]\\r\\n                const dx = points[2] - points[0]\\r\\n                angle = Math.atan2(-dy, dx)\\r\\n                //      console.log(dy, dx);\\r\\n\\r\\n                points[0] -= from.attrs.outerRadius * Math.cos(angle + Math.PI)\\r\\n                points[1] += from.attrs.outerRadius * Math.sin(angle + Math.PI)\\r\\n            } else if (\\r\\n                from.attrs.name.includes('text') &&\\r\\n                to.attrs.name.includes('star')\\r\\n            ) {\\r\\n                let fromTextHeight = from.textHeight || from.attrs.textHeight\\r\\n                let fromTextWidth = from.textWidth || from.attrs.textWidth\\r\\n                //rect change\\r\\n                dy1 = to.attrs.y + -(from.attrs.y + fromTextHeight / 2)\\r\\n                dx1 = to.attrs.x + -(from.attrs.x + fromTextWidth / 2)\\r\\n\\r\\n                theta = Math.atan2(dy1, dx1)\\r\\n                angle = (theta / Math.PI) * 180\\r\\n                if (angle <= -45 && angle >= -135) {\\r\\n                    //top\\r\\n                    points[0] += fromTextWidth / 2\\r\\n                } else if (angle > 45 && angle < 135) {\\r\\n                    //bottom\\r\\n                    points[0] += fromTextWidth / 2\\r\\n                    points[1] += fromTextHeight\\r\\n                } else if (\\r\\n                    (angle > 135 && angle < 180) ||\\r\\n                    (angle > -180 && angle < -135)\\r\\n                ) {\\r\\n                    //left\\r\\n                    points[1] += fromTextHeight / 2\\r\\n                } else if (angle > -45 && angle < 45) {\\r\\n                    points[0] += fromTextWidth\\r\\n                    points[1] += fromTextHeight / 2\\r\\n                }\\r\\n                //ellipse change\\r\\n                const dy = points[3] - points[1]\\r\\n                const dx = points[2] - points[0]\\r\\n                angle = Math.atan2(-dy, dx)\\r\\n                //      console.log(dy, dx);\\r\\n\\r\\n                points[2] += to.attrs.outerRadius * Math.cos(angle + Math.PI)\\r\\n                points[3] -= to.attrs.outerRadius * Math.sin(angle + Math.PI)\\r\\n            } else if (\\r\\n                from.attrs.name.includes('text') &&\\r\\n                to.attrs.name.includes('ellipse')\\r\\n            ) {\\r\\n                let fromTextHeight = from.textHeight || from.attrs.textHeight\\r\\n                let fromTextWidth = from.textWidth || from.attrs.textWidth\\r\\n                //rect change\\r\\n                dy1 = to.attrs.y + -(from.attrs.y + fromTextHeight / 2)\\r\\n                dx1 = to.attrs.x + -(from.attrs.x + fromTextWidth / 2)\\r\\n\\r\\n                theta = Math.atan2(dy1, dx1)\\r\\n                angle = (theta / Math.PI) * 180\\r\\n                if (angle <= -45 && angle >= -135) {\\r\\n                    //top\\r\\n                    points[0] += fromTextWidth / 2\\r\\n                } else if (angle > 45 && angle < 135) {\\r\\n                    //bottom\\r\\n                    points[0] += fromTextWidth / 2\\r\\n                    points[1] += fromTextHeight\\r\\n                } else if (\\r\\n                    (angle > 135 && angle < 180) ||\\r\\n                    (angle > -180 && angle < -135)\\r\\n                ) {\\r\\n                    //left\\r\\n                    points[1] += fromTextHeight / 2\\r\\n                } else if (angle > -45 && angle < 45) {\\r\\n                    points[0] += fromTextWidth\\r\\n                    points[1] += fromTextHeight / 2\\r\\n                }\\r\\n                //ellipse change\\r\\n                const dy = points[3] - points[1]\\r\\n                const dx = points[2] - points[0]\\r\\n                angle = Math.atan2(-dy, dx)\\r\\n                //      console.log(dy, dx);\\r\\n\\r\\n                points[2] += to.attrs.radiusX * Math.cos(angle + Math.PI)\\r\\n                points[3] -= to.attrs.radiusY * Math.sin(angle + Math.PI)\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (stuff.type === 'onlyFrom') {\\r\\n            if (from.attrs.name.includes('rect')) {\\r\\n                origin = {\\r\\n                    x: from.attrs.x + from.attrs.width / 2,\\r\\n                    y: from.attrs.y + from.attrs.height / 2\\r\\n                }\\r\\n                dy = point.y - origin.y\\r\\n                dx = point.x - origin.x\\r\\n                theta = Math.atan2(dy, dx)\\r\\n                angle = (theta / Math.PI) * 180\\r\\n                if (angle <= -45 && angle >= -135) {\\r\\n                    //top\\r\\n                    points[0] += from.attrs.width / 2\\r\\n                } else if (angle > 45 && angle < 135) {\\r\\n                    //bottom\\r\\n                    points[0] += from.attrs.width / 2\\r\\n                    points[1] += from.attrs.height\\r\\n                } else if (\\r\\n                    (angle > 135 && angle < 180) ||\\r\\n                    (angle > -180 && angle < -135)\\r\\n                ) {\\r\\n                    //left\\r\\n                    points[1] += from.attrs.height / 2\\r\\n                } else if (angle > -45 && angle < 45) {\\r\\n                    points[0] += from.attrs.width\\r\\n                    points[1] += from.attrs.height / 2\\r\\n                }\\r\\n            } else if (from.attrs.name.includes('ellipse')) {\\r\\n                origin = {\\r\\n                    x: from.attrs.x,\\r\\n                    y: from.attrs.y\\r\\n                }\\r\\n\\r\\n                const dy = points[3] - points[1]\\r\\n                const dx = points[2] - points[0]\\r\\n                let angle = Math.atan2(-dy, dx)\\r\\n\\r\\n                //  console.log(\\\"we messing with a ellipse\\\", points, angle, from);\\r\\n\\r\\n                points[0] += -from.attrs.radiusX * Math.cos(angle + Math.PI)\\r\\n                points[1] += from.attrs.radiusY * Math.sin(angle + Math.PI)\\r\\n            } else if (from.attrs.name.includes('star')) {\\r\\n                origin = { x: from.attrs.x, y: from.attrs.y }\\r\\n                const dy = points[3] - points[1]\\r\\n                const dx = points[2] - points[0]\\r\\n                let angle = Math.atan2(-dy, dx)\\r\\n\\r\\n                //  console.log(\\\"we messing with a ellipse\\\", points, angle, from);\\r\\n\\r\\n                points[0] += -from.attrs.outerRadius * Math.cos(angle + Math.PI)\\r\\n                points[1] += from.attrs.outerRadius * Math.sin(angle + Math.PI)\\r\\n            } else if (from.attrs.name.includes('text')) {\\r\\n                let fromTextHeight = from.textHeight || from.attrs.textHeight\\r\\n                let fromTextWidth = from.textWidth || from.attrs.textWidth\\r\\n\\r\\n                origin = {\\r\\n                    x: from.attrs.x + fromTextWidth / 2,\\r\\n                    y: from.attrs.y + fromTextWidth / 2\\r\\n                }\\r\\n                dy = point.y - origin.y\\r\\n                dx = point.x - origin.x\\r\\n                theta = Math.atan2(dy, dx)\\r\\n                angle = (theta / Math.PI) * 180\\r\\n\\r\\n                if (angle <= -45 && angle >= -135) {\\r\\n                    //top\\r\\n                    points[0] += fromTextWidth / 2\\r\\n                } else if (angle > 45 && angle < 135) {\\r\\n                    //bottom\\r\\n                    points[0] += fromTextWidth / 2\\r\\n                    points[1] += fromTextHeight\\r\\n                } else if (\\r\\n                    (angle > 135 && angle < 180) ||\\r\\n                    (angle > -180 && angle < -135)\\r\\n                ) {\\r\\n                    //left\\r\\n                    points[1] += fromTextHeight / 2\\r\\n                } else if (angle > -45 && angle < 45) {\\r\\n                    points[0] += fromTextWidth\\r\\n                    points[1] += fromTextHeight / 2\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        if (stuff.type === 'onlyTo') {\\r\\n            if (to.attrs.name.includes('rect')) {\\r\\n                var endPoint = { x: points[0], y: points[1] }\\r\\n                origin = {\\r\\n                    x: to.attrs.x + to.attrs.width / 2,\\r\\n                    y: to.attrs.y + to.attrs.height / 2\\r\\n                }\\r\\n\\r\\n                dy = endPoint.y - origin.y\\r\\n                dx = endPoint.x - origin.x\\r\\n                theta = Math.atan2(dy, dx)\\r\\n                angle = (theta / Math.PI) * 180\\r\\n\\r\\n                if (angle > 45 && angle < 135) {\\r\\n                    points[2] += to.attrs.width / 2\\r\\n                    points[3] += to.attrs.height\\r\\n                } else if (\\r\\n                    (angle > 135 && angle < 180) ||\\r\\n                    (angle > -180 && angle < -135)\\r\\n                ) {\\r\\n                    points[3] += to.attrs.height / 2\\r\\n                } else if (angle > -135 && angle < -45) {\\r\\n                    points[2] += to.attrs.width / 2\\r\\n                } else {\\r\\n                    points[2] += to.attrs.width\\r\\n                    points[3] += to.attrs.height / 2\\r\\n                }\\r\\n            } else if (to.attrs.name.includes('ellipse')) {\\r\\n                const dy = points[3] - points[1]\\r\\n                const dx = points[2] - points[0]\\r\\n                let angle = Math.atan2(-dy, dx)\\r\\n                //      console.log(dy, dx);\\r\\n\\r\\n                points[2] += to.attrs.radiusX * Math.cos(angle + Math.PI)\\r\\n                points[3] -= to.attrs.radiusY * Math.sin(angle + Math.PI)\\r\\n            } else if (to.attrs.name.includes('star')) {\\r\\n                const dy = points[3] - points[1]\\r\\n                const dx = points[2] - points[0]\\r\\n                let angle = Math.atan2(-dy, dx)\\r\\n                //      console.log(dy, dx);\\r\\n\\r\\n                points[2] += to.attrs.outerRadius * Math.cos(angle + Math.PI)\\r\\n                points[3] -= to.attrs.outerRadius * Math.sin(angle + Math.PI)\\r\\n            } else if (to.attrs.name.includes('text')) {\\r\\n                let toTextHeight = to.textHeight || to.attrs.textHeight\\r\\n                let toTextWidth = to.textWidth || to.attrs.textWidth\\r\\n\\r\\n                endPoint = { x: points[0], y: points[1] }\\r\\n                origin = {\\r\\n                    x: to.attrs.x + toTextWidth / 2,\\r\\n                    y: to.attrs.y + toTextWidth / 2\\r\\n                }\\r\\n\\r\\n                dy = endPoint.y - origin.y\\r\\n                dx = endPoint.x - origin.x\\r\\n                theta = Math.atan2(dy, dx)\\r\\n                angle = (theta / Math.PI) * 180\\r\\n\\r\\n                if (angle > 45 && angle < 135) {\\r\\n                    points[2] += toTextWidth / 2\\r\\n                    points[3] += toTextHeight\\r\\n                } else if (\\r\\n                    (angle > 135 && angle < 180) ||\\r\\n                    (angle > -180 && angle < -135)\\r\\n                ) {\\r\\n                    points[3] += toTextHeight / 2\\r\\n                } else if (angle > -135 && angle < -45) {\\r\\n                    points[2] += toTextWidth / 2\\r\\n                } else {\\r\\n                    points[2] += toTextHeight\\r\\n                    points[3] += toTextHeight / 2\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return points\\r\\n    }\\r\\n\\r\\n    render() {\\r\\n        var points = null\\r\\n\\r\\n        if (this.props.current) {\\r\\n            if (this.props.from) {\\r\\n                points = [\\r\\n                    this.props.from.attrs.x,\\r\\n                    this.props.from.attrs.y,\\r\\n                    this.props.arrowEndX,\\r\\n                    this.props.arrowEndY\\r\\n                ]\\r\\n                let stuff = {\\r\\n                    points: points,\\r\\n                    from: this.props.from,\\r\\n                    mouseX: this.props.arrowEndX,\\r\\n                    mouseY: this.props.arrowEndY,\\r\\n                    type: 'onlyFrom'\\r\\n                }\\r\\n                points = this.getConnectorPoints(stuff)\\r\\n            }\\r\\n        }\\r\\n        if (this.props.current === false) {\\r\\n            if (this.props.from && this.props.to) {\\r\\n                points = [\\r\\n                    this.props.from.attrs.x,\\r\\n                    this.props.from.attrs.y,\\r\\n                    this.props.to.attrs.x,\\r\\n                    this.props.to.attrs.y\\r\\n                ]\\r\\n\\r\\n                let toSend = {\\r\\n                    points: points,\\r\\n                    from: this.props.from,\\r\\n                    to: this.props.to,\\r\\n                    type: 'FromAndTo'\\r\\n                }\\r\\n\\r\\n                points = this.getConnectorPoints(toSend)\\r\\n\\r\\n                //get connector points\\r\\n            } else if (this.props.from) {\\r\\n                points = [\\r\\n                    this.props.from.attrs.x,\\r\\n                    this.props.from.attrs.y,\\r\\n                    this.props.points[2],\\r\\n                    this.props.points[3]\\r\\n                ]\\r\\n\\r\\n                let stuff = {\\r\\n                    points: points,\\r\\n                    from: this.props.from,\\r\\n                    mouseX: this.props.points[2],\\r\\n                    mouseY: this.props.points[3],\\r\\n                    type: 'onlyFrom'\\r\\n                }\\r\\n                points = this.getConnectorPoints(stuff)\\r\\n            } else if (this.props.to) {\\r\\n                points = [\\r\\n                    this.props.points[0],\\r\\n                    this.props.points[1],\\r\\n                    this.props.to.attrs.x,\\r\\n                    this.props.to.attrs.y\\r\\n                ]\\r\\n\\r\\n                let stuff = {\\r\\n                    points: points,\\r\\n                    to: this.props.to,\\r\\n                    type: 'onlyTo',\\r\\n                    mouseX: this.props.to.attrs.x,\\r\\n                    mouseY: this.props.to.attrs.y\\r\\n                }\\r\\n                points = this.getConnectorPoints(stuff)\\r\\n            }\\r\\n        }\\r\\n        return (\\r\\n            <Arrow\\r\\n                name={this.props.name}\\r\\n                points={points}\\r\\n                strokeWidth={1.5}\\r\\n                stroke={this.props.stroke}\\r\\n                fill={this.props.fill}\\r\\n            />\\r\\n        )\\r\\n    }\\r\\n}\\r\\n\\r\\nexport default Connector\\r\\n\",\"import React, { Component } from 'react'\\r\\n\\r\\nimport { Rect, Ellipse, Star, Text, Arrow } from 'react-konva'\\r\\n//at start, two same rectangles at one place\\r\\n//at the end of drag, note the x and y of the dragged rectangle, append it to GraphicsMain\\r\\n//return the dragged rectangle to original\\r\\n\\r\\nconst ToolBar = () => (\\r\\n    <Rect\\r\\n        y={80}\\r\\n        width={77.5}\\r\\n        height={355}\\r\\n        fill=\\\"white\\\"\\r\\n        shadowBlur={5}\\r\\n        shadowColor=\\\"black\\\"\\r\\n    />\\r\\n)\\r\\n\\r\\nexport default class Toolbar extends Component {\\r\\n    state = {\\r\\n        arrowDraggable: false,\\r\\n        previousShape: undefined,\\r\\n        count: 0,\\r\\n        isDragging: false\\r\\n    }\\r\\n    render() {\\r\\n        return (\\r\\n            <React.Fragment>\\r\\n                {this.props.layer ? (\\r\\n                    <React.Fragment>\\r\\n                        <ToolBar />\\r\\n                        <Ellipse\\r\\n                            radiusX={20}\\r\\n                            radiusY={20}\\r\\n                            stroke=\\\"black\\\"\\r\\n                            strokeWidth={1.5}\\r\\n                            x={37.5}\\r\\n                            y={125}\\r\\n                        />\\r\\n                        <Ellipse\\r\\n                            radiusX={20}\\r\\n                            radiusY={20}\\r\\n                            stroke=\\\"black\\\"\\r\\n                            strokeWidth={1.5}\\r\\n                            x={37.5}\\r\\n                            y={125}\\r\\n                            draggable\\r\\n                            ref=\\\"draggableEllipse\\\"\\r\\n                            onDragEnd={e => {\\r\\n                                //add the rectangle to parent\\r\\n                                let name = 'ellipse' + this.props.ellipseName\\r\\n                                let toSend = {\\r\\n                                    x: e.target.x(),\\r\\n                                    y: e.target.y(),\\r\\n                                    radiusX: 20,\\r\\n                                    radiusY: 20,\\r\\n                                    stroke: 'black',\\r\\n                                    strokeWidth: 1.5,\\r\\n                                    name: name,\\r\\n                                    fill: 'white',\\r\\n                                    ref: name,\\r\\n                                    rotation: 0\\r\\n                                }\\r\\n                                this.props.appendToEllipses(toSend)\\r\\n\\r\\n                                var ellipse = this.refs.draggableEllipse\\r\\n\\r\\n                                ellipse.position({\\r\\n                                    x: 37.5,\\r\\n                                    y: 125\\r\\n                                })\\r\\n                            }}\\r\\n                        />\\r\\n                        <Rect\\r\\n                            width={35}\\r\\n                            height={35}\\r\\n                            stroke=\\\"black\\\"\\r\\n                            strokeWidth={1.5}\\r\\n                            x={20}\\r\\n                            y={180}\\r\\n                            fill=\\\"white\\\"\\r\\n                        />\\r\\n                        <Rect\\r\\n                            width={35}\\r\\n                            height={35}\\r\\n                            stroke=\\\"black\\\"\\r\\n                            strokeWidth={1.5}\\r\\n                            x={20}\\r\\n                            y={180}\\r\\n                            draggable\\r\\n                            fill=\\\"white\\\"\\r\\n                            ref=\\\"draggableRect\\\"\\r\\n                            onDragEnd={e => {\\r\\n                                //add the rectangle to parent\\r\\n                                let name = 'rectangle' + this.props.rectName\\r\\n                                let toSend = {\\r\\n                                    x: e.target.x(),\\r\\n                                    y: e.target.y(),\\r\\n                                    width: 35,\\r\\n                                    height: 35,\\r\\n                                    stroke: 'black',\\r\\n                                    strokeWidth: 1.5,\\r\\n                                    rotation: 0,\\r\\n                                    name: name,\\r\\n                                    ref: name,\\r\\n                                    fill: 'white',\\r\\n                                    useImage: false\\r\\n                                }\\r\\n                                this.props.appendToRectangles(toSend)\\r\\n\\r\\n                                var rect = this.refs.draggableRect\\r\\n\\r\\n                                rect.position({\\r\\n                                    x: 20,\\r\\n                                    y: 180\\r\\n                                })\\r\\n                            }}\\r\\n                        />\\r\\n                        <Star\\r\\n                            innerRadius={8}\\r\\n                            outerRadius={20}\\r\\n                            numPoints={5}\\r\\n                            stroke=\\\"black\\\"\\r\\n                            strokeWidth={1.5}\\r\\n                            x={37.5}\\r\\n                            y={270}\\r\\n                            fill=\\\"white\\\"\\r\\n                        />\\r\\n                        <Star\\r\\n                            innerRadius={8}\\r\\n                            outerRadius={20}\\r\\n                            numPoints={5}\\r\\n                            stroke=\\\"black\\\"\\r\\n                            strokeWidth={1.5}\\r\\n                            x={37.5}\\r\\n                            y={270}\\r\\n                            draggable\\r\\n                            ref=\\\"draggableStar\\\"\\r\\n                            onDragEnd={e => {\\r\\n                                //add the rectangle to parent\\r\\n                                let name = 'star' + this.props.starName\\r\\n                                let toSend = {\\r\\n                                    x: e.target.x(),\\r\\n                                    y: e.target.y(),\\r\\n                                    innerRadius: 8,\\r\\n                                    outerRadius: 20,\\r\\n                                    numPoints: 5,\\r\\n                                    stroke: 'black',\\r\\n                                    strokeWidth: 1.5,\\r\\n                                    name: name,\\r\\n                                    fill: 'white',\\r\\n                                    ref: name,\\r\\n                                    rotation: 0\\r\\n                                }\\r\\n                                this.props.appendToStars(toSend)\\r\\n\\r\\n                                var star = this.refs.draggableStar\\r\\n\\r\\n                                star.position({\\r\\n                                    x: 37.5,\\r\\n                                    y: 270\\r\\n                                })\\r\\n                            }}\\r\\n                        />\\r\\n                        <Text\\r\\n                            fontSize={40}\\r\\n                            text=\\\"T\\\"\\r\\n                            fontFamily=\\\"Belgrano\\\"\\r\\n                            x={24}\\r\\n                            y={320}\\r\\n                        />\\r\\n                        <Text\\r\\n                            fontSize={40}\\r\\n                            text=\\\"T\\\"\\r\\n                            fontFamily=\\\"Belgrano\\\"\\r\\n                            x={24}\\r\\n                            y={320}\\r\\n                            draggable\\r\\n                            ref=\\\"draggableText\\\"\\r\\n                            onDragEnd={e => {\\r\\n                                //add the rectangle to parent\\r\\n                                let name = 'text' + this.props.textName\\r\\n                                let ref = 'text' + this.props.textName\\r\\n                                let toSend = {\\r\\n                                    x: e.target.x(),\\r\\n                                    y: e.target.y(),\\r\\n                                    fontSize: 25,\\r\\n                                    fontFamily: 'Belgrano',\\r\\n                                    ref: ref,\\r\\n                                    name: name,\\r\\n                                    text: '',\\r\\n                                    fill: 'black',\\r\\n                                    width: 300,\\r\\n                                    height: 25,\\r\\n                                    rotation: 0,\\r\\n                                    textWidth: this.refs.draggableText\\r\\n                                        .textWidth,\\r\\n                                    textHeight: this.refs.draggableText\\r\\n                                        .textHeight\\r\\n                                }\\r\\n                                console.log('tosend', toSend)\\r\\n                                this.props.appendToTexts(toSend)\\r\\n\\r\\n                                var text = this.refs.draggableText\\r\\n\\r\\n                                text.position({\\r\\n                                    x: 24,\\r\\n                                    y: 320\\r\\n                                })\\r\\n                            }}\\r\\n                        />\\r\\n                        <Arrow\\r\\n                            points={[20, 400, 50, 400]}\\r\\n                            fill=\\\"black\\\"\\r\\n                            stroke=\\\"black\\\"\\r\\n                        />\\r\\n                        <Arrow\\r\\n                            points={[20, 400, 50, 400]}\\r\\n                            fill=\\\"black\\\"\\r\\n                            stroke=\\\"black\\\"\\r\\n                            ref=\\\"draggableArrow\\\"\\r\\n                            name=\\\"draggableArrow\\\"\\r\\n                            draggable\\r\\n                            onDragStart={() => {\\r\\n                                this.refs.draggableArrow.setAttr('fill', 'grey')\\r\\n                                this.refs.draggableArrow.setAttr(\\r\\n                                    'stroke',\\r\\n                                    'grey'\\r\\n                                )\\r\\n                            }}\\r\\n                            onDragMove={() => {\\r\\n                                var pos = this.props.layer\\r\\n                                    .getStage()\\r\\n                                    .getPointerPosition()\\r\\n                                var shape = this.props.layer.getIntersection(\\r\\n                                    pos\\r\\n                                )\\r\\n\\r\\n                                //after first frame\\r\\n                                if (\\r\\n                                    this.state.previousShape !== undefined &&\\r\\n                                    this.state.previousShape !== null\\r\\n                                )\\r\\n                                    if (this.state.previousShape !== shape) {\\r\\n                                        //arrow entered a new shape\\r\\n\\r\\n                                        //the shape we left gets its original color back\\r\\n                                        if (\\r\\n                                            this.state.previousShape.attrs\\r\\n                                                .id !== 'ContainerRect' &&\\r\\n                                            !this.state.previousShape.attrs.name.includes(\\r\\n                                                'arrow'\\r\\n                                            )\\r\\n                                        ) {\\r\\n                                            this.refs.draggableArrow.setAttr(\\r\\n                                                'fill',\\r\\n                                                'black'\\r\\n                                            )\\r\\n                                            this.refs.draggableArrow.setAttr(\\r\\n                                                'stroke',\\r\\n                                                'black'\\r\\n                                            )\\r\\n                                        }\\r\\n                                    }\\r\\n                                    //if arrow is moving in a single shape\\r\\n                                    else if (\\r\\n                                        this.state.previousShape.attrs.id !==\\r\\n                                            'ContainerRect' &&\\r\\n                                        !shape.attrs.name.includes('arrow')\\r\\n                                    ) {\\r\\n                                        //if it the first time the shapes are same, set shape to blue, store the original color\\r\\n                                        this.refs.draggableArrow.setAttr(\\r\\n                                            'fill',\\r\\n                                            '#ccf5ff'\\r\\n                                        )\\r\\n                                        this.refs.draggableArrow.setAttr(\\r\\n                                            'stroke',\\r\\n                                            '#ccf5ff'\\r\\n                                        )\\r\\n                                    }\\r\\n\\r\\n                                this.props.layer.draw()\\r\\n\\r\\n                                this.setState({ previousShape: shape })\\r\\n                            }}\\r\\n                            onDragEnd={event => {\\r\\n                                var pos = this.props.layer\\r\\n                                    .getStage()\\r\\n                                    .getPointerPosition()\\r\\n                                var shape = this.props.layer.getIntersection(\\r\\n                                    pos\\r\\n                                )\\r\\n\\r\\n                                //shape is not containerRect, which means we are on a shape\\r\\n                                if (\\r\\n                                    shape &&\\r\\n                                    shape.attrs.id === undefined &&\\r\\n                                    !shape.attrs.name.includes('arrow')\\r\\n                                ) {\\r\\n                                    let toSend = {\\r\\n                                        x: pos.x,\\r\\n                                        y: pos.y,\\r\\n                                        points: [20, 475, 60, 475],\\r\\n                                        from: shape,\\r\\n                                        stroke: 'black',\\r\\n                                        strokeWidth: '1.5',\\r\\n                                        fill: 'black'\\r\\n                                    }\\r\\n                                    console.log('from shape', shape)\\r\\n                                    this.props.newArrowOnDragEnd(toSend)\\r\\n                                } else {\\r\\n                                    let toSend = {\\r\\n                                        x: pos.x,\\r\\n                                        y: pos.y,\\r\\n                                        points: [20, 475, 60, 475],\\r\\n                                        stroke: 'black',\\r\\n                                        strokeWidth: '1.5',\\r\\n                                        fill: 'black'\\r\\n                                    }\\r\\n\\r\\n                                    this.props.newArrowOnDragEnd(toSend)\\r\\n                                }\\r\\n\\r\\n                                //if shape is not arrow nor the containerRect then we make a connector instead\\r\\n\\r\\n                                //onDragEnd = dropping arrow down, create a new arrow with 2 same points at the dropped location\\r\\n                                //create new arrow in Graphics.js\\r\\n                                //from there, fire onMouseMove over the entire stage\\r\\n                                //the arrow's points should be the first point onDragEnd and the second should be the current\\r\\n                                //mouse position determined by onMouseMove event in stage\\r\\n                                var arrow = this.refs.draggableArrow\\r\\n                                arrow.position({ x: 0, y: 0 })\\r\\n                                arrow.setAttr('fill', 'black')\\r\\n                                arrow.setAttr('stroke', 'black')\\r\\n\\r\\n                                arrow.draw()\\r\\n                            }}\\r\\n                        />\\r\\n                    </React.Fragment>\\r\\n                ) : null}\\r\\n            </React.Fragment>\\r\\n        )\\r\\n    }\\r\\n}\\r\\n\",\"import React, { Component } from \\\"react\\\";\\r\\n\\r\\nimport {\\r\\n  Stage,\\r\\n  Layer,\\r\\n  Rect,\\r\\n  Transformer,\\r\\n  Ellipse,\\r\\n  Star,\\r\\n  Text,\\r\\n  Arrow\\r\\n} from \\\"react-konva\\\";\\r\\nimport Connector from \\\"./Connector.jsx\\\";\\r\\nimport Toolbar from \\\"./Toolbar.js\\\";\\r\\n\\r\\nimport \\\"./Graphics.css\\\";\\r\\n\\r\\nclass TransformerComponent extends React.Component {\\r\\n  componentDidMount() {\\r\\n    this.checkNode();\\r\\n  }\\r\\n  componentDidUpdate() {\\r\\n    this.checkNode();\\r\\n  }\\r\\n  checkNode() {\\r\\n    const stage = this.transformer.getStage();\\r\\n\\r\\n    const { selectedShapeName } = this.props;\\r\\n    if (selectedShapeName === \\\"\\\") {\\r\\n      this.transformer.detach();\\r\\n      return;\\r\\n    }\\r\\n    const selectedNode = stage.findOne(\\\".\\\" + selectedShapeName);\\r\\n    if (selectedNode === this.transformer.node()) {\\r\\n      return;\\r\\n    }\\r\\n\\r\\n    if (selectedNode) {\\r\\n      this.transformer.attachTo(selectedNode);\\r\\n    } else {\\r\\n      this.transformer.detach();\\r\\n    }\\r\\n    this.transformer.getLayer().batchDraw();\\r\\n  }\\r\\n  render() {\\r\\n    if (this.props.selectedShapeName.includes(\\\"text\\\")) {\\r\\n      var stuff = (\\r\\n        <Transformer\\r\\n          ref={node => {\\r\\n            this.transformer = node;\\r\\n          }}\\r\\n          name=\\\"transformer\\\"\\r\\n          boundBoxFunc={(oldBox, newBox) => {\\r\\n            newBox.width = Math.max(30, newBox.width);\\r\\n            return newBox;\\r\\n          }}\\r\\n          enabledAnchors={[\\\"middle-left\\\", \\\"middle-right\\\"]}\\r\\n        />\\r\\n      );\\r\\n    } else if (this.props.selectedShapeName.includes(\\\"star\\\")) {\\r\\n      var stuff = (\\r\\n        <Transformer\\r\\n          ref={node => {\\r\\n            this.transformer = node;\\r\\n          }}\\r\\n          name=\\\"transformer\\\"\\r\\n          enabledAnchors={[\\r\\n            \\\"top-left\\\",\\r\\n            \\\"top-right\\\",\\r\\n            \\\"bottom-left\\\",\\r\\n            \\\"bottom-right\\\"\\r\\n          ]}\\r\\n        />\\r\\n      );\\r\\n    } else if (this.props.selectedShapeName.includes(\\\"arrow\\\")) {\\r\\n      var stuff = (\\r\\n        <Transformer\\r\\n          ref={node => {\\r\\n            this.transformer = node;\\r\\n          }}\\r\\n          name=\\\"transformer\\\"\\r\\n          resizeEnabled={false}\\r\\n          rotateEnabled={false}\\r\\n        />\\r\\n      );\\r\\n    } else {\\r\\n      var stuff = (\\r\\n        <Transformer\\r\\n          ref={node => {\\r\\n            this.transformer = node;\\r\\n          }}\\r\\n          name=\\\"transformer\\\"\\r\\n          keepRatio={true}\\r\\n        />\\r\\n      );\\r\\n    }\\r\\n    return stuff;\\r\\n  }\\r\\n}\\r\\n\\r\\nvar history = [];\\r\\nvar historyStep = 0;\\r\\n\\r\\nclass Graphics extends Component {\\r\\n  constructor(props) {\\r\\n    super(props);\\r\\n\\r\\n    this.state = {\\r\\n      layerX: 0,\\r\\n      layerY: 0,\\r\\n      layerScale: 1,\\r\\n      selectedShapeName: \\\"\\\",\\r\\n      errMsg: \\\"\\\",\\r\\n      rectangles: [],\\r\\n      ellipses: [],\\r\\n      stars: [],\\r\\n      texts: [],\\r\\n      arrows: [],\\r\\n      connectors: [],\\r\\n      currentTextRef: \\\"\\\",\\r\\n      shouldTextUpdate: true,\\r\\n      textX: 0,\\r\\n      textY: 0,\\r\\n      textEditVisible: false,\\r\\n      arrowDraggable: false,\\r\\n      newArrowRef: \\\"\\\",\\r\\n      count: 0,\\r\\n      newArrowDropped: false,\\r\\n      newConnectorDropped: false,\\r\\n      arrowEndX: 0,\\r\\n      arrowEndY: 0,\\r\\n      isTransforming: false,\\r\\n      lastFill: null,\\r\\n\\r\\n      saving: null,\\r\\n      saved: [],\\r\\n      roadmapId: null,\\r\\n      alreadyCreated: false,\\r\\n      publishing: false,\\r\\n      title: \\\"\\\",\\r\\n      category: \\\"\\\",\\r\\n      description: \\\"\\\",\\r\\n      thumbnail: \\\"\\\",\\r\\n      isPasteDisabled: false,\\r\\n      ellipseDeleteCount: 0,\\r\\n      starDeleteCount: 0,\\r\\n      arrowDeleteCount: 0,\\r\\n      textDeleteCount: 0,\\r\\n      rectDeleteCount: 0\\r\\n    };\\r\\n\\r\\n    this.handleWheel = this.handleWheel.bind(this);\\r\\n\\r\\n  }\\r\\n\\r\\n  handleSave = () => {\\r\\n    const rects = this.state.rectangles,\\r\\n      ellipses = this.state.ellipses,\\r\\n      stars = this.state.stars,\\r\\n      texts = this.state.texts,\\r\\n      arrows = this.state.arrows;\\r\\n    if (\\r\\n      JSON.stringify(this.state.saved) !==\\r\\n      JSON.stringify([rects, ellipses, stars, texts, arrows])\\r\\n    ) {\\r\\n      this.setState({ saved: [rects, ellipses, stars, texts, arrows] });\\r\\n\\r\\n      let arrows1 = this.state.arrows;\\r\\n      arrows1.forEach(eachArrow => {\\r\\n        //for \\\"from & to of each arrow\\\"\\r\\n        if (eachArrow.from && eachArrow.from.attrs) {\\r\\n          if (eachArrow.from.attrs.name.includes(\\\"text\\\")) {\\r\\n            eachArrow.from.textWidth = eachArrow.from.textWidth;\\r\\n\\r\\n            eachArrow.from.textHeight = eachArrow.from.textHeight;\\r\\n          }\\r\\n        }\\r\\n        if (eachArrow.to && eachArrow.to.attrs) {\\r\\n          if (eachArrow.to.attrs.name.includes(\\\"text\\\")) {\\r\\n            eachArrow.to.attrs.textWidth = eachArrow.to.textWidth;\\r\\n            eachArrow.to.attrs.textHeight = eachArrow.to.textHeight;\\r\\n          }\\r\\n        }\\r\\n      });\\r\\n\\r\\n      if (this.state.roadmapId) {\\r\\n        //if draft already exists\\r\\n        this.setState({ saving: true });\\r\\n        fetch(\\\"/api/roadmap/modifyDraftDB\\\", {\\r\\n          method: \\\"POST\\\",\\r\\n          headers: { \\\"Content-Type\\\": \\\"application/json\\\" },\\r\\n          body: JSON.stringify({\\r\\n            roadmapId: this.state.roadmapId,\\r\\n\\r\\n            data: {\\r\\n              rects: rects,\\r\\n              ellipses: ellipses,\\r\\n              stars: stars,\\r\\n              texts: texts,\\r\\n              arrows: arrows1\\r\\n            }\\r\\n          })\\r\\n        }).then(res => {\\r\\n          this.setState({ saving: false });\\r\\n        });\\r\\n      } else {\\r\\n        //if first time pressing sav\\r\\n        this.setState({ saving: true });\\r\\n        fetch(\\\"/api/roadmap/saveRoadmapToDB\\\", {\\r\\n          method: \\\"POST\\\",\\r\\n          headers: { \\\"Content-Type\\\": \\\"application/json\\\" },\\r\\n          body: JSON.stringify({\\r\\n            userId: this.props.auth.user.id,\\r\\n            roadmapType: \\\"draft\\\",\\r\\n            data: {\\r\\n              rects: rects,\\r\\n              ellipses: ellipses,\\r\\n              stars: stars,\\r\\n              texts: texts,\\r\\n              arrows: arrows\\r\\n            }\\r\\n          })\\r\\n        }).then(res =>\\r\\n          res.json().then(data => {\\r\\n            this.setState({ saving: false });\\r\\n            this.setState({ roadmapId: data.roadmapId });\\r\\n          })\\r\\n        );\\r\\n      }\\r\\n    }\\r\\n  };\\r\\n\\r\\n  handleStageClick = e => {\\r\\n    var pos = this.refs.layer2.getStage().getPointerPosition();\\r\\n    var shape = this.refs.layer2.getIntersection(pos);\\r\\n\\r\\n    console.log(\\\"texts\\\", this.state.texts);\\r\\n\\r\\n    if (\\r\\n      shape !== null &&\\r\\n      shape.name() !== undefined &&\\r\\n      shape !== undefined &&\\r\\n      shape.name() !== undefined\\r\\n    ) {\\r\\n      this.setState(\\r\\n        {\\r\\n          selectedShapeName: shape.name()\\r\\n        },\\r\\n        () => {\\r\\n          this.refs.graphicStage.draw();\\r\\n        }\\r\\n      );\\r\\n    }\\r\\n\\r\\n    //arrow logic\\r\\n    if (this.state.newArrowRef !== \\\"\\\") {\\r\\n      if (this.state.previousShape) {\\r\\n        if (this.state.previousShape.attrs.id !== \\\"ContainerRect\\\") {\\r\\n          //console.log(this.refs.graphicStage.findOne(\\\".\\\" + this.state.newArrowRef));\\r\\n          //\\r\\n\\r\\n          this.state.arrows.map(eachArrow => {\\r\\n            if (eachArrow.name === this.state.newArrowRef) {\\r\\n              eachArrow.to = this.state.previousShape;\\r\\n            }\\r\\n          });\\r\\n\\r\\n          //console.log(newConnector, this.state.newArrowRef);\\r\\n          //newConnector.setAttr(\\\"to\\\", this.state.previousShape);\\r\\n          //console.log(newConnector);\\r\\n        }\\r\\n      }\\r\\n\\r\\n      //handle connector more\\r\\n      //if the currentArrow ref has a from, and that e.target.attrs.id isn't containerRect,\\r\\n      //then find the current shape with stage find name and then yeah\\r\\n      this.state.arrows.map(eachArrow => {\\r\\n        if (eachArrow.name === this.state.newArrowRef) {\\r\\n          eachArrow.fill = \\\"black\\\";\\r\\n          eachArrow.stroke = \\\"black\\\";\\r\\n        }\\r\\n      });\\r\\n      //arrow logic, there's e.evt.pageX, pageY\\r\\n      this.setState({\\r\\n        arrowDraggable: false,\\r\\n        newArrowRef: \\\"\\\"\\r\\n      });\\r\\n    }\\r\\n  };\\r\\n  handleMouseOver = event => {\\r\\n    //get the currennt arrow ref and modify its position by filtering & pushing again\\r\\n    //console.log(\\\"lastFill: \\\", this.state.lastFill);\\r\\n    var pos = this.refs.graphicStage.getPointerPosition();\\r\\n    var shape = this.refs.graphicStage.getIntersection(pos);\\r\\n\\r\\n    if (shape && shape.attrs.link) {\\r\\n      document.body.style.cursor = \\\"pointer\\\";\\r\\n    } else {\\r\\n      document.body.style.cursor = \\\"default\\\";\\r\\n    }\\r\\n\\r\\n    //if we are moving an arrow\\r\\n    if (this.state.newArrowRef !== \\\"\\\") {\\r\\n      //filling color logic:\\r\\n\\r\\n      var transform = this.refs.layer2.getAbsoluteTransform().copy();\\r\\n      transform.invert();\\r\\n\\r\\n      pos = transform.point(pos);\\r\\n      this.setState({ arrowEndX: pos.x, arrowEndY: pos.y });\\r\\n      //last non arrow object\\r\\n      if (shape && shape.attrs && shape.attrs.name != undefined) {\\r\\n        //  console.log(shape);\\r\\n        if (!shape.attrs.name.includes(\\\"arrow\\\")) {\\r\\n          //after first frame\\r\\n          if (this.state.previousShape)\\r\\n            if (this.state.previousShape !== shape) {\\r\\n              //arrow entered a new shape\\r\\n\\r\\n              //set current arrow to blue\\r\\n              if (this.state.previousShape.attrs.id !== \\\"ContainerRect\\\") {\\r\\n                this.state.arrows.map(eachArrow => {\\r\\n                  if (eachArrow.name === this.state.newArrowRef) {\\r\\n                    eachArrow.fill = \\\"black\\\";\\r\\n                    eachArrow.stroke = \\\"black\\\";\\r\\n                  }\\r\\n                });\\r\\n                this.forceUpdate();\\r\\n              } else {\\r\\n                this.state.arrows.map(eachArrow => {\\r\\n                  if (eachArrow.name === this.state.newArrowRef) {\\r\\n                    eachArrow.fill = \\\"#ccf5ff\\\";\\r\\n                    eachArrow.stroke = \\\"#ccf5ff\\\";\\r\\n                  }\\r\\n                });\\r\\n                this.forceUpdate();\\r\\n              }\\r\\n            }\\r\\n          //if arrow is moving in a single shape\\r\\n        }\\r\\n\\r\\n        if (!shape.attrs.name.includes(\\\"arrow\\\")) {\\r\\n          this.setState({ previousShape: shape });\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n    var arrows = this.state.arrows;\\r\\n\\r\\n    arrows.map(eachArrow => {\\r\\n      if (eachArrow.name === this.state.newArrowRef) {\\r\\n        var index = arrows.indexOf(eachArrow);\\r\\n        let currentArrow = eachArrow;\\r\\n        currentArrow.points = [\\r\\n          currentArrow.points[0],\\r\\n          currentArrow.points[1],\\r\\n          pos.x,\\r\\n          pos.y\\r\\n          /*  event.evt.pageY -\\r\\n            document.getElementById(\\\"NavBar\\\").getBoundingClientRect().height */\\r\\n        ];\\r\\n\\r\\n        this.state.arrows[index] = currentArrow;\\r\\n      }\\r\\n    });\\r\\n  };\\r\\n  handleWheel(event) {\\r\\n    if (\\r\\n      this.state.rectangles.length === 0 &&\\r\\n      this.state.ellipses.length === 0 &&\\r\\n      this.state.stars.length === 0 &&\\r\\n      this.state.texts.length === 0 &&\\r\\n      this.state.arrows.length === 0\\r\\n    ) {\\r\\n    } else {\\r\\n      event.evt.preventDefault();\\r\\n      const scaleBy = 1.2;\\r\\n      const stage = this.refs.graphicStage;\\r\\n      const layer = this.refs.layer2;\\r\\n      const oldScale = layer.scaleX();\\r\\n      const mousePointTo = {\\r\\n        x:\\r\\n          stage.getPointerPosition().x / oldScale -\\r\\n          this.state.layerX / oldScale,\\r\\n        y:\\r\\n          stage.getPointerPosition().y / oldScale - this.state.layerY / oldScale\\r\\n      };\\r\\n\\r\\n      const newScale =\\r\\n        event.evt.deltaY < 0 ? oldScale * scaleBy : oldScale / scaleBy;\\r\\n\\r\\n      layer.scale({ x: newScale, y: newScale });\\r\\n\\r\\n      /*  console.log(\\r\\n        oldScale,\\r\\n        mousePointTo,\\r\\n        stage.getPointerPosition().x,\\r\\n        stage.getPointerPosition().y\\r\\n      );\\r\\n    */\\r\\n      this.setState({\\r\\n        layerScale: newScale,\\r\\n        layerX:\\r\\n          -(mousePointTo.x - stage.getPointerPosition().x / newScale) *\\r\\n          newScale,\\r\\n        layerY:\\r\\n          -(mousePointTo.y - stage.getPointerPosition().y / newScale) * newScale\\r\\n      });\\r\\n    }\\r\\n  }\\r\\n  componentDidUpdate(prevProps, prevState) {\\r\\n    let prevMainShapes = [\\r\\n      prevState.rectangles,\\r\\n      prevState.ellipses,\\r\\n      prevState.stars,\\r\\n      prevState.arrows,\\r\\n      prevState.connectors,\\r\\n      prevState.texts\\r\\n    ];\\r\\n    let currentMainShapes = [\\r\\n      this.state.rectangles,\\r\\n      this.state.ellipses,\\r\\n      this.state.stars,\\r\\n      this.state.arrows,\\r\\n      this.state.connectors,\\r\\n      this.state.texts\\r\\n    ];\\r\\n\\r\\n    if (!this.state.redoing && !this.state.isTransforming)\\r\\n      if (JSON.stringify(this.state) !== JSON.stringify(prevState)) {\\r\\n        if (\\r\\n          JSON.stringify(prevMainShapes) !== JSON.stringify(currentMainShapes)\\r\\n        ) {\\r\\n          //if text shouldn't update, don't append to  history\\r\\n          if (this.state.shouldTextUpdate) {\\r\\n            var uh = history;\\r\\n            history = uh.slice(0, historyStep + 1);\\r\\n            //console.log(\\\"sliced\\\", history);\\r\\n            var toAppend = this.state;\\r\\n            history = history.concat(toAppend);\\r\\n            //console.log(\\\"new\\\", history);\\r\\n            historyStep += 1;\\r\\n            //console.log(history, historyStep, history[historyStep]);\\r\\n          }\\r\\n        }\\r\\n      } else {\\r\\n        //console.log(\\\"compoenntDidUpdate but attrs didn't change\\\");\\r\\n      }\\r\\n    this.state.redoing = false;\\r\\n  }\\r\\n\\r\\n  handleUndo = () => {\\r\\n    if (!this.state.isTransforming) {\\r\\n      if (!this.state.textEditVisible) {\\r\\n        if (historyStep === 0) {\\r\\n          return;\\r\\n        }\\r\\n        historyStep -= 1;\\r\\n\\r\\n        this.setState(\\r\\n          {\\r\\n            rectangles: history[historyStep].rectangles,\\r\\n            arrows: history[historyStep].arrows,\\r\\n            ellipses: history[historyStep].ellipses,\\r\\n            stars: history[historyStep].stars,\\r\\n            texts: history[historyStep].texts,\\r\\n            connectors: history[historyStep].connectors,\\r\\n            redoing: true,\\r\\n            selectedShapeName: this.shapeIsGone(history[historyStep])\\r\\n              ? \\\"\\\"\\r\\n              : this.state.selectedShapeName\\r\\n          },\\r\\n          () => {\\r\\n            this.refs.graphicStage.draw();\\r\\n          }\\r\\n        );\\r\\n      }\\r\\n    }\\r\\n  };\\r\\n\\r\\n  handleRedo = () => {\\r\\n    if (historyStep === history.length - 1) {\\r\\n      return;\\r\\n    }\\r\\n    historyStep += 1;\\r\\n    const next = history[historyStep];\\r\\n    this.setState(\\r\\n      {\\r\\n        rectangles: next.rectangles,\\r\\n        arrows: next.arrows,\\r\\n        ellipses: next.ellipses,\\r\\n        stars: next.stars,\\r\\n        texts: next.texts,\\r\\n        redoing: true,\\r\\n        selectedShapeName: this.shapeIsGone(history[historyStep])\\r\\n          ? \\\"\\\"\\r\\n          : this.state.selectedShapeName\\r\\n      },\\r\\n      () => {\\r\\n        this.forceUpdate();\\r\\n      }\\r\\n    );\\r\\n  };\\r\\n\\r\\n  shapeIsGone = returnTo => {\\r\\n    var toReturn = true;\\r\\n    let currentShapeName = this.state.selectedShapeName;\\r\\n    let [rectangles, ellipses, stars, arrows, texts] = [\\r\\n      returnTo.rectangles,\\r\\n      returnTo.ellipses,\\r\\n      returnTo.stars,\\r\\n      returnTo.arrows,\\r\\n\\r\\n      returnTo.texts\\r\\n    ];\\r\\n    rectangles.map(eachRect => {\\r\\n      if (eachRect.name === currentShapeName) {\\r\\n        toReturn = false;\\r\\n      }\\r\\n    });\\r\\n    ellipses.map(eachEllipse => {\\r\\n      if (eachEllipse.name === currentShapeName) {\\r\\n        toReturn = false;\\r\\n      }\\r\\n    });\\r\\n    stars.map(eachStar => {\\r\\n      if (eachStar.name === currentShapeName) {\\r\\n        toReturn = false;\\r\\n      }\\r\\n    });\\r\\n    arrows.map(eachArrow => {\\r\\n      if (eachArrow.name === currentShapeName) {\\r\\n        toReturn = false;\\r\\n      }\\r\\n    });\\r\\n\\r\\n    texts.map(eachText => {\\r\\n      if (eachText.name === currentShapeName) {\\r\\n        toReturn = false;\\r\\n      }\\r\\n    });\\r\\n\\r\\n    return toReturn;\\r\\n  };\\r\\n  IsJsonString = str => {\\r\\n    try {\\r\\n      JSON.parse(str);\\r\\n    } catch (e) {\\r\\n      return false;\\r\\n    }\\r\\n    return true;\\r\\n  };\\r\\n\\r\\n  async componentDidMount() {\\r\\n    history.push(this.state);\\r\\n    this.setState({ selectedShapeName: \\\"\\\" });\\r\\n\\r\\n\\r\\n\\r\\n    //if draft\\r\\n\\r\\n  }\\r\\n\\r\\n  render() {\\r\\n    let saveText;\\r\\n\\r\\n    let saving = this.state.saving;\\r\\n    if (saving !== null) {\\r\\n      if (saving) {\\r\\n        saveText = <div style={{ color: \\\"white\\\" }}>Saving</div>;\\r\\n      } else {\\r\\n        saveText = <div style={{ color: \\\"white\\\" }}>Saved</div>;\\r\\n      }\\r\\n    }\\r\\n\\r\\n    const canvas = document.createElement(\\\"canvas\\\");\\r\\n    const ctx = canvas.getContext(\\\"2d\\\");\\r\\n\\r\\n    var gradient = ctx.createLinearGradient(0, 0, 100, 100);\\r\\n    gradient.addColorStop(0.0, \\\"red\\\");\\r\\n    gradient.addColorStop(1 / 6, \\\"orange\\\");\\r\\n    gradient.addColorStop(2 / 6, \\\"yellow\\\");\\r\\n    gradient.addColorStop(3 / 6, \\\"green\\\");\\r\\n    gradient.addColorStop(4 / 6, \\\"aqua\\\");\\r\\n    gradient.addColorStop(5 / 6, \\\"blue\\\");\\r\\n    gradient.addColorStop(1.0, \\\"purple\\\");\\r\\n\\r\\n    const errMsg = this.state.errMsg;\\r\\n    let errDisplay;\\r\\n    if (errMsg !== \\\"\\\") {\\r\\n      errDisplay = (\\r\\n        <div className=\\\"errMsginner\\\">\\r\\n          <span style={{ color: \\\"white\\\" }}>\\r\\n            {errMsg !== \\\"\\\" ? errMsg : null}\\r\\n          </span>\\r\\n        </div>\\r\\n      );\\r\\n    } else {\\r\\n    }\\r\\n\\r\\n    const countryOptions = [\\r\\n      { key: \\\"1\\\", value: \\\"Machine Learning\\\", text: \\\"Machine Learning\\\" },\\r\\n      { key: \\\"2\\\", value: \\\"Computer Science\\\", text: \\\"Computer Science\\\" },\\r\\n      {\\r\\n        key: \\\"3\\\",\\r\\n        value: \\\"Software Engineering\\\",\\r\\n        text: \\\"Software Engineering\\\"\\r\\n      },\\r\\n      { key: \\\"12\\\", value: \\\"Technology\\\", text: \\\"Technology\\\" },\\r\\n      { key: \\\"4\\\", value: \\\"Engineering\\\", text: \\\"Engineering\\\" },\\r\\n\\r\\n      {\\r\\n        key: \\\"6\\\",\\r\\n        value: \\\"Sciences and Mathematics\\\",\\r\\n        text: \\\"Sciences and Mathematics\\\"\\r\\n      },\\r\\n      {\\r\\n        key: \\\"7\\\",\\r\\n        value: \\\"Law, Economics and Social Sciences\\\",\\r\\n        text: \\\"Law, Economics and Social Sciences\\\"\\r\\n      },\\r\\n      { key: \\\"8\\\", value: \\\"Humanities\\\", text: \\\"Humanities\\\" },\\r\\n      {\\r\\n        key: \\\"9\\\",\\r\\n        value: \\\"Linguistics and Cultural Studies\\\",\\r\\n        text: \\\"Linguistics and Cultural Studies\\\"\\r\\n      },\\r\\n      { key: \\\"10\\\", value: \\\"Art and Music\\\", text: \\\"Art and Music\\\" },\\r\\n      { key: \\\"11\\\", value: \\\"Lifestyle\\\", text: \\\"Lifestyle\\\" },\\r\\n      {\\r\\n        key: \\\"13\\\",\\r\\n        value: \\\"Others\\\",\\r\\n        text: \\\"Others\\\"\\r\\n      }\\r\\n    ];\\r\\n\\r\\n    return (\\r\\n      <React.Fragment>\\r\\n        <div\\r\\n          onKeyDown={event => {\\r\\n            const x = 88,\\r\\n              deleteKey = 46,\\r\\n              copy = 67,\\r\\n              paste = 86,\\r\\n              z = 90,\\r\\n              y = 89;\\r\\n\\r\\n            if (\\r\\n              ((event.ctrlKey && event.keyCode === x) ||\\r\\n                event.keyCode === deleteKey) &&\\r\\n              !this.state.isPasteDisabled\\r\\n            ) {\\r\\n              if (this.state.selectedShapeName !== \\\"\\\") {\\r\\n                var that = this;\\r\\n                //delete it from the state too\\r\\n                let name = this.state.selectedShapeName;\\r\\n                let rectDeleted = false,\\r\\n                  ellipseDeleted = false,\\r\\n                  starDeleted = false,\\r\\n                  arrowDeleted = false,\\r\\n                  textDeleted = false;\\r\\n\\r\\n                var rects = this.state.rectangles.filter(function(eachRect) {\\r\\n                  if (eachRect.name === name) {\\r\\n                    that.setState({\\r\\n                      rectDeleteCount: that.state.rectDeleteCount + 1\\r\\n                    });\\r\\n                  }\\r\\n                  return eachRect.name !== name;\\r\\n                });\\r\\n\\r\\n                var ellipses = this.state.ellipses.filter(function(eachRect) {\\r\\n                  if (eachRect.name === name) {\\r\\n                    that.setState({\\r\\n                      ellipseDeleteCount: that.state.ellipseDeleteCount + 1\\r\\n                    });\\r\\n                  }\\r\\n                  return eachRect.name !== name;\\r\\n                });\\r\\n\\r\\n                var stars = this.state.stars.filter(function(eachRect) {\\r\\n                  if (eachRect.name === name) {\\r\\n                    that.setState({\\r\\n                      starDeleteCount: that.state.starDeleteCount + 1\\r\\n                    });\\r\\n                  }\\r\\n                  return eachRect.name !== name;\\r\\n                });\\r\\n\\r\\n                var arrows = this.state.arrows.filter(function(eachRect) {\\r\\n                  if (eachRect.name === name) {\\r\\n                    that.setState({\\r\\n                      arrowDeleteCount: that.state.arrowDeleteCount + 1\\r\\n                    });\\r\\n                  }\\r\\n                  return eachRect.name !== name;\\r\\n                });\\r\\n\\r\\n                var texts = this.state.texts.filter(function(eachRect) {\\r\\n                  if (eachRect.name === name) {\\r\\n                    that.setState({\\r\\n                      textDeleteCount: that.state.textDeleteCount + 1\\r\\n                    });\\r\\n                  }\\r\\n                  return eachRect.name !== name;\\r\\n                });\\r\\n\\r\\n                this.setState({\\r\\n                  rectangles: rects,\\r\\n                  ellipses: ellipses,\\r\\n                  stars: stars,\\r\\n                  arrows: arrows,\\r\\n                  texts: texts,\\r\\n                  selectedShapeName: \\\"\\\"\\r\\n                });\\r\\n              }\\r\\n            } else if (event.shiftKey && event.ctrlKey && event.keyCode === z) {\\r\\n              this.handleRedo();\\r\\n            } else if (event.ctrlKey && event.keyCode === z) {\\r\\n              this.handleUndo();\\r\\n            } else if (event.ctrlKey && event.keyCode === y) {\\r\\n              this.handleRedo();\\r\\n            } else if (event.ctrlKey && event.keyCode === copy) {\\r\\n              if (this.state.selectedShapeName !== \\\"\\\") {\\r\\n                //find it\\r\\n                let name = this.state.selectedShapeName;\\r\\n                let copiedElement = null;\\r\\n                if (name.includes(\\\"rect\\\")) {\\r\\n                  copiedElement = this.state.rectangles.filter(function(\\r\\n                    eachRect\\r\\n                  ) {\\r\\n                    return eachRect.name === name;\\r\\n                  });\\r\\n                } else if (name.includes(\\\"ellipse\\\")) {\\r\\n                  copiedElement = this.state.ellipses.filter(function(\\r\\n                    eachRect\\r\\n                  ) {\\r\\n                    return eachRect.name === name;\\r\\n                  });\\r\\n                } else if (name.includes(\\\"star\\\")) {\\r\\n                  copiedElement = this.state.stars.filter(function(eachRect) {\\r\\n                    return eachRect.name === name;\\r\\n                  });\\r\\n                } else if (name.includes(\\\"text\\\")) {\\r\\n                  copiedElement = this.state.texts.filter(function(eachRect) {\\r\\n                    return eachRect.name === name;\\r\\n                  });\\r\\n                } else if (name.includes(\\\"arrow\\\")) {\\r\\n                  copiedElement = this.state.arrows.filter(function(eachRect) {\\r\\n                    return eachRect.name === name;\\r\\n                  });\\r\\n                }\\r\\n\\r\\n                this.setState({ copiedElement: copiedElement }, () => {\\r\\n                  console.log(\\\"copied ele\\\", this.state.copiedElement);\\r\\n                });\\r\\n              }\\r\\n            } else if (\\r\\n              event.ctrlKey &&\\r\\n              event.keyCode === paste &&\\r\\n              !this.state.isPasteDisabled\\r\\n            ) {\\r\\n              let copiedElement = this.state.copiedElement[0];\\r\\n              console.log(copiedElement);\\r\\n              var length;\\r\\n              if (copiedElement) {\\r\\n                if (copiedElement.attrs) {\\r\\n                } else {\\r\\n                  if (copiedElement.name.includes(\\\"rectangle\\\")) {\\r\\n                    length =\\r\\n                      this.state.rectangles.length +\\r\\n                      1 +\\r\\n                      this.state.rectDeleteCount;\\r\\n                    var toPush = {\\r\\n                      x: copiedElement.x + 10,\\r\\n                      y: copiedElement.y + 10,\\r\\n                      width: copiedElement.width,\\r\\n                      height: copiedElement.height,\\r\\n                      stroke: copiedElement.stroke,\\r\\n                      strokeWidth: copiedElement.strokeWidth,\\r\\n                      name:\\r\\n                        \\\"rectangle\\\" +\\r\\n                        (this.state.rectangles.length +\\r\\n                          this.state.rectDeleteCount +\\r\\n                          1),\\r\\n                      ref:\\r\\n                        \\\"rectangle\\\" +\\r\\n                        (this.state.rectangles.length +\\r\\n                          this.state.rectDeleteCount +\\r\\n                          1),\\r\\n                      fill: copiedElement.fill,\\r\\n                      useImage: copiedElement.useImage,\\r\\n                      link: copiedElement.link,\\r\\n                      rotation: copiedElement.rotation\\r\\n                    };\\r\\n                    let newName = this.state.selectedShapeName;\\r\\n\\r\\n                    this.setState(\\r\\n                      prevState => ({\\r\\n                        rectangles: [...prevState.rectangles, toPush]\\r\\n                      }),\\r\\n                      () => {\\r\\n                        this.setState({\\r\\n                          selectedShapeName:\\r\\n                            \\\"rectangle\\\" + this.state.rectangles.length\\r\\n                        });\\r\\n                      }\\r\\n                    );\\r\\n                  } else if (copiedElement.name.includes(\\\"arrow\\\")) {\\r\\n                    length =\\r\\n                      this.state.arrows.length +\\r\\n                      1 +\\r\\n                      this.state.arrowDeleteCount;\\r\\n\\r\\n                    if (copiedElement.to || copiedElement.from) {\\r\\n                      this.setState(\\r\\n                        {\\r\\n                          errMsg: \\\"Connectors cannot be pasted\\\"\\r\\n                        },\\r\\n                        () => {\\r\\n                          var that = this;\\r\\n                          setTimeout(function() {\\r\\n                            that.setState({\\r\\n                              errMsg: \\\"\\\"\\r\\n                            });\\r\\n                          }, 1000);\\r\\n                        }\\r\\n                      );\\r\\n                    } else {\\r\\n                      var toPush = {\\r\\n                        points: [\\r\\n                          copiedElement.points[0] + 30,\\r\\n                          copiedElement.points[1] + 30,\\r\\n                          copiedElement.points[2] + 30,\\r\\n                          copiedElement.points[3] + 30\\r\\n                        ],\\r\\n                        fill: copiedElement.fill,\\r\\n                        link: copiedElement.link,\\r\\n                        stroke: copiedElement.stroke,\\r\\n                        strokeWidth: copiedElement.strokeWidth,\\r\\n                        name:\\r\\n                          \\\"arrow\\\" +\\r\\n                          (this.state.arrows.length +\\r\\n                            1 +\\r\\n                            this.state.arrowDeleteCount),\\r\\n                        ref:\\r\\n                          \\\"arrow\\\" +\\r\\n                          (this.state.arrows.length +\\r\\n                            1 +\\r\\n                            this.state.arrowDeleteCount),\\r\\n                        rotation: copiedElement.rotation\\r\\n                      };\\r\\n\\r\\n                      let newName = this.state.selectedShapeName;\\r\\n\\r\\n                      this.setState(\\r\\n                        prevState => ({\\r\\n                          arrows: [...prevState.arrows, toPush]\\r\\n                        }),\\r\\n                        () => {\\r\\n                          this.setState({\\r\\n                            selectedShapeName:\\r\\n                              \\\"arrow\\\" + this.state.arrows.length\\r\\n                          });\\r\\n                        }\\r\\n                      );\\r\\n                    }\\r\\n                  } else if (copiedElement.name.includes(\\\"ellipse\\\")) {\\r\\n                    length =\\r\\n                      this.state.ellipses.length +\\r\\n                      1 +\\r\\n                      this.state.ellipseDeleteCount;\\r\\n                    var toPush = {\\r\\n                      x: copiedElement.x + 10,\\r\\n                      y: copiedElement.y + 10,\\r\\n                      radiusX: copiedElement.radiusX,\\r\\n                      radiusY: copiedElement.radiusY,\\r\\n                      stroke: copiedElement.stroke,\\r\\n                      strokeWidth: copiedElement.strokeWidth,\\r\\n                      name:\\r\\n                        \\\"ellipse\\\" +\\r\\n                        (this.state.ellipses.length +\\r\\n                          1 +\\r\\n                          this.state.ellipseDeleteCount),\\r\\n                      ref:\\r\\n                        \\\"ellipse\\\" +\\r\\n                        (this.state.ellipses.length +\\r\\n                          1 +\\r\\n                          this.state.ellipseDeleteCount),\\r\\n                      fill: copiedElement.fill,\\r\\n                      link: copiedElement.link,\\r\\n                      useImage: copiedElement.useImage,\\r\\n                      rotation: copiedElement.rotation\\r\\n                    };\\r\\n                    let newName = this.state.selectedShapeName;\\r\\n\\r\\n                    this.setState(\\r\\n                      prevState => ({\\r\\n                        ellipses: [...prevState.ellipses, toPush]\\r\\n                      }),\\r\\n                      () => {\\r\\n                        this.setState({\\r\\n                          selectedShapeName:\\r\\n                            \\\"ellipse\\\" + this.state.ellipses.length\\r\\n                        });\\r\\n                      }\\r\\n                    );\\r\\n                  } else if (copiedElement.name.includes(\\\"star\\\")) {\\r\\n                    length =\\r\\n                      this.state.stars.length + 1 + this.state.starDeleteCount;\\r\\n                    var toPush = {\\r\\n                      x: copiedElement.x + 10,\\r\\n                      y: copiedElement.y + 10,\\r\\n                      link: copiedElement.link,\\r\\n                      innerRadius: copiedElement.innerRadius,\\r\\n                      outerRadius: copiedElement.outerRadius,\\r\\n                      stroke: copiedElement.stroke,\\r\\n                      strokeWidth: copiedElement.strokeWidth,\\r\\n                      name:\\r\\n                        \\\"star\\\" +\\r\\n                        (this.state.stars.length +\\r\\n                          1 +\\r\\n                          this.state.starDeleteCount),\\r\\n                      ref:\\r\\n                        \\\"star\\\" +\\r\\n                        (this.state.stars.length +\\r\\n                          1 +\\r\\n                          this.state.starDeleteCount),\\r\\n                      fill: copiedElement.fill,\\r\\n                      useImage: copiedElement.useImage,\\r\\n                      rotation: copiedElement.rotation\\r\\n                    };\\r\\n                    let newName = this.state.selectedShapeName;\\r\\n\\r\\n                    this.setState(\\r\\n                      prevState => ({\\r\\n                        stars: [...prevState.stars, toPush]\\r\\n                      }),\\r\\n                      () => {\\r\\n                        this.setState({\\r\\n                          selectedShapeName: \\\"star\\\" + this.state.stars.length\\r\\n                        });\\r\\n                      }\\r\\n                    );\\r\\n                  } else if (copiedElement.name.includes(\\\"text\\\")) {\\r\\n                    length =\\r\\n                      this.state.texts.length + 1 + this.state.textDeleteCount;\\r\\n                    var toPush = {\\r\\n                      x: copiedElement.x + 10,\\r\\n                      y: copiedElement.y + 10,\\r\\n                      link: copiedElement.link,\\r\\n\\r\\n                      name:\\r\\n                        \\\"text\\\" +\\r\\n                        (this.state.texts.length +\\r\\n                          1 +\\r\\n                          this.state.textDeleteCount),\\r\\n                      ref:\\r\\n                        \\\"text\\\" +\\r\\n                        (this.state.texts.length +\\r\\n                          1 +\\r\\n                          this.state.textDeleteCount),\\r\\n                      fill: copiedElement.fill,\\r\\n                      fontSize: copiedElement.fontSize,\\r\\n                      fontFamily: copiedElement.fontFamily,\\r\\n                      useImage: copiedElement.useImage,\\r\\n                      text: copiedElement.text,\\r\\n                      width: copiedElement.width,\\r\\n                      rotation: copiedElement.rotation\\r\\n                    };\\r\\n                    let newName = this.state.selectedShapeName;\\r\\n\\r\\n                    this.setState(\\r\\n                      prevState => ({\\r\\n                        texts: [...prevState.texts, toPush]\\r\\n                      }),\\r\\n                      () => {\\r\\n                        this.setState(\\r\\n                          {\\r\\n                            selectedShapeName:\\r\\n                              \\\"text\\\" +\\r\\n                              (this.state.texts.length +\\r\\n                                this.state.textDeleteCount)\\r\\n                          },\\r\\n                          () => {\\r\\n                            console.log(this.state.selectedShapeName);\\r\\n                          }\\r\\n                        );\\r\\n                      }\\r\\n                    );\\r\\n                  }\\r\\n                }\\r\\n              }\\r\\n            }\\r\\n          }}\\r\\n          tabIndex=\\\"0\\\"\\r\\n          style={{ outline: \\\"none\\\" }}\\r\\n        >\\r\\n          <Stage\\r\\n            onClick={this.handleStageClick}\\r\\n            onMouseMove={this.handleMouseOver}\\r\\n            onWheel={event => this.handleWheel(event)}\\r\\n            height={window.innerHeight}\\r\\n            width={window.innerWidth}\\r\\n            ref=\\\"graphicStage\\\"\\r\\n          >\\r\\n            <Layer\\r\\n              scaleX={this.state.layerScale}\\r\\n              scaleY={this.state.layerScale}\\r\\n              x={this.state.layerX}\\r\\n              y={this.state.layerY}\\r\\n              height={window.innerHeight}\\r\\n              width={window.innerWidth}\\r\\n              draggable\\r\\n              onDragEnd={() => {\\r\\n                this.setState({\\r\\n                  layerX: this.refs.layer2.x(),\\r\\n                  layerY: this.refs.layer2.y()\\r\\n                });\\r\\n              }}\\r\\n              ref=\\\"layer2\\\"\\r\\n            >\\r\\n              <Rect\\r\\n                x={-5 * window.innerWidth}\\r\\n                y={-5 * window.innerHeight}\\r\\n                height={window.innerHeight * 10}\\r\\n                width={window.innerWidth * 10}\\r\\n                name=\\\"\\\"\\r\\n                id=\\\"ContainerRect\\\"\\r\\n              />\\r\\n\\r\\n              {this.state.rectangles.map(eachRect => {\\r\\n                return (\\r\\n                  <Rect\\r\\n                    onClick={() => {\\r\\n                      var that = this;\\r\\n                      if (eachRect.link !== undefined && eachRect.link !== \\\"\\\") {\\r\\n                        this.setState(\\r\\n                          {\\r\\n                            errMsg: \\\"Links will not be opened in create mode\\\"\\r\\n                          },\\r\\n                          () => {\\r\\n                            setTimeout(function() {\\r\\n                              that.setState({\\r\\n                                errMsg: \\\"\\\"\\r\\n                              });\\r\\n                            }, 1000);\\r\\n                          }\\r\\n                        );\\r\\n                      }\\r\\n                    }}\\r\\n                    onTransformStart={() => {\\r\\n                      this.setState({\\r\\n                        isTransforming: true\\r\\n                      });\\r\\n                      let rect = this.refs[eachRect.ref];\\r\\n                      rect.setAttr(\\\"lastRotation\\\", rect.rotation());\\r\\n                    }}\\r\\n                    onTransform={() => {\\r\\n                      let rect = this.refs[eachRect.ref];\\r\\n\\r\\n                      if (rect.attrs.lastRotation !== rect.rotation()) {\\r\\n                        this.state.arrows.map(eachArrow => {\\r\\n                          if (\\r\\n                            eachArrow.to &&\\r\\n                            eachArrow.to.name() === rect.name()\\r\\n                          ) {\\r\\n                            this.setState({\\r\\n                              errMsg:\\r\\n                                \\\"Rotating rects with connectors might skew things up!\\\"\\r\\n                            });\\r\\n                          }\\r\\n                          if (\\r\\n                            eachArrow.from &&\\r\\n                            eachArrow.from.name() === rect.name()\\r\\n                          ) {\\r\\n                            this.setState({\\r\\n                              errMsg:\\r\\n                                \\\"Rotating rects with connectors might skew things up!\\\"\\r\\n                            });\\r\\n                          }\\r\\n                        });\\r\\n                      }\\r\\n\\r\\n                      rect.setAttr(\\\"lastRotation\\\", rect.rotation());\\r\\n                    }}\\r\\n                    onTransformEnd={() => {\\r\\n                      this.setState({\\r\\n                        isTransforming: false\\r\\n                      });\\r\\n                      let rect = this.refs[eachRect.ref];\\r\\n                      this.setState(\\r\\n                        prevState => ({\\r\\n                          errMsg: \\\"\\\",\\r\\n                          rectangles: prevState.rectangles.map(eachRect =>\\r\\n                            eachRect.name === rect.attrs.name\\r\\n                              ? {\\r\\n                                  ...eachRect,\\r\\n                                  width: rect.width() * rect.scaleX(),\\r\\n                                  height: rect.height() * rect.scaleY(),\\r\\n                                  rotation: rect.rotation(),\\r\\n                                  x: rect.x(),\\r\\n                                  y: rect.y()\\r\\n                                }\\r\\n                              : eachRect\\r\\n                          )\\r\\n                        }),\\r\\n                        () => {\\r\\n                          this.forceUpdate();\\r\\n                        }\\r\\n                      );\\r\\n\\r\\n                      rect.setAttr(\\\"scaleX\\\", 1);\\r\\n                      rect.setAttr(\\\"scaleY\\\", 1);\\r\\n                    }}\\r\\n                    rotation={eachRect.rotation}\\r\\n                    ref={eachRect.ref}\\r\\n                    fill={eachRect.fill}\\r\\n                    name={eachRect.name}\\r\\n                    x={eachRect.x}\\r\\n                    y={eachRect.y}\\r\\n                    width={eachRect.width}\\r\\n                    height={eachRect.height}\\r\\n                    stroke={eachRect.stroke}\\r\\n                    strokeWidth={eachRect.strokeWidth}\\r\\n                    strokeScaleEnabled={false}\\r\\n                    draggable\\r\\n                    onDragMove={() => {\\r\\n                      this.state.arrows.map(eachArrow => {\\r\\n                        if (eachArrow.from !== undefined) {\\r\\n                          if (eachRect.name === eachArrow.from.attrs.name) {\\r\\n                            eachArrow.points = [\\r\\n                              eachRect.x,\\r\\n                              eachRect.y,\\r\\n                              eachArrow.points[2],\\r\\n                              eachArrow.points[3]\\r\\n                            ];\\r\\n                            this.forceUpdate();\\r\\n                          }\\r\\n                        }\\r\\n\\r\\n                        if (eachArrow.to !== undefined) {\\r\\n                          if (eachRect.name == eachArrow.to.attrs.name) {\\r\\n                            eachArrow.points = [\\r\\n                              eachArrow.points[0],\\r\\n                              eachArrow.points[1],\\r\\n                              eachRect.x,\\r\\n                              eachRect.y\\r\\n                            ];\\r\\n                            this.forceUpdate();\\r\\n                          }\\r\\n                        }\\r\\n                      });\\r\\n                    }}\\r\\n                    onDragEnd={event => {\\r\\n                      //cannot compare by name because currentSelected might not be the same\\r\\n                      //have to use ref, which appears to be overcomplicated\\r\\n                      var shape = this.refs[eachRect.ref];\\r\\n                      /*    this.state.rectangles.map(eachRect => {\\r\\n                          if (eachRect.name === shape.attrs.name) {\\r\\n                            shape.position({\\r\\n                              x: event.target.x(),\\r\\n                              y: event.target.y()\\r\\n                            });\\r\\n                          }\\r\\n                        });*/\\r\\n\\r\\n                      this.setState(prevState => ({\\r\\n                        rectangles: prevState.rectangles.map(eachRect =>\\r\\n                          eachRect.name === shape.attrs.name\\r\\n                            ? {\\r\\n                                ...eachRect,\\r\\n                                x: event.target.x(),\\r\\n                                y: event.target.y()\\r\\n                              }\\r\\n                            : eachRect\\r\\n                        )\\r\\n                      }));\\r\\n                    }}\\r\\n                  />\\r\\n                );\\r\\n              })}\\r\\n              {this.state.ellipses.map(eachEllipse => (\\r\\n                <Ellipse\\r\\n                  ref={eachEllipse.ref}\\r\\n                  name={eachEllipse.name}\\r\\n                  x={eachEllipse.x}\\r\\n                  y={eachEllipse.y}\\r\\n                  rotation={eachEllipse.rotation}\\r\\n                  radiusX={eachEllipse.radiusX}\\r\\n                  radiusY={eachEllipse.radiusY}\\r\\n                  fill={eachEllipse.fill}\\r\\n                  stroke={eachEllipse.stroke}\\r\\n                  strokeWidth={eachEllipse.strokeWidth}\\r\\n                  strokeScaleEnabled={false}\\r\\n                  onClick={() => {\\r\\n                    var that = this;\\r\\n                    if (\\r\\n                      eachEllipse.link !== undefined &&\\r\\n                      eachEllipse.link !== \\\"\\\"\\r\\n                    ) {\\r\\n                      this.setState(\\r\\n                        {\\r\\n                          errMsg: \\\"Links will not be opened in create mode\\\"\\r\\n                        },\\r\\n                        () => {\\r\\n                          setTimeout(function() {\\r\\n                            that.setState({\\r\\n                              errMsg: \\\"\\\"\\r\\n                            });\\r\\n                          }, 1000);\\r\\n                        }\\r\\n                      );\\r\\n                    }\\r\\n                  }}\\r\\n                  onTransformStart={() => {\\r\\n                    this.setState({ isTransforming: true });\\r\\n                    let ellipse = this.refs[eachEllipse.ref];\\r\\n                    ellipse.setAttr(\\\"lastRotation\\\", ellipse.rotation());\\r\\n                  }}\\r\\n                  onTransform={() => {\\r\\n                    let ellipse = this.refs[eachEllipse.ref];\\r\\n\\r\\n                    if (ellipse.attrs.lastRotation !== ellipse.rotation()) {\\r\\n                      this.state.arrows.map(eachArrow => {\\r\\n                        if (\\r\\n                          eachArrow.to &&\\r\\n                          eachArrow.to.name() === ellipse.name()\\r\\n                        ) {\\r\\n                          this.setState({\\r\\n                            errMsg:\\r\\n                              \\\"Rotating ellipses with connectors might skew things up!\\\"\\r\\n                          });\\r\\n                        }\\r\\n                        if (\\r\\n                          eachArrow.from &&\\r\\n                          eachArrow.from.name() === ellipse.name()\\r\\n                        ) {\\r\\n                          this.setState({\\r\\n                            errMsg:\\r\\n                              \\\"Rotating ellipses with connectors might skew things up!\\\"\\r\\n                          });\\r\\n                        }\\r\\n                      });\\r\\n                    }\\r\\n\\r\\n                    ellipse.setAttr(\\\"lastRotation\\\", ellipse.rotation());\\r\\n                  }}\\r\\n                  onTransformEnd={() => {\\r\\n                    this.setState({ isTransforming: false });\\r\\n                    let ellipse = this.refs[eachEllipse.ref];\\r\\n                    let scaleX = ellipse.scaleX(),\\r\\n                      scaleY = ellipse.scaleY();\\r\\n\\r\\n                    this.setState(prevState => ({\\r\\n                      errMsg: \\\"\\\",\\r\\n                      ellipses: prevState.ellipses.map(eachEllipse =>\\r\\n                        eachEllipse.name === ellipse.attrs.name\\r\\n                          ? {\\r\\n                              ...eachEllipse,\\r\\n\\r\\n                              radiusX: ellipse.radiusX() * ellipse.scaleX(),\\r\\n                              radiusY: ellipse.radiusY() * ellipse.scaleY(),\\r\\n                              rotation: ellipse.rotation(),\\r\\n                              x: ellipse.x(),\\r\\n                              y: ellipse.y()\\r\\n                            }\\r\\n                          : eachEllipse\\r\\n                      )\\r\\n                    }));\\r\\n\\r\\n                    ellipse.setAttr(\\\"scaleX\\\", 1);\\r\\n                    ellipse.setAttr(\\\"scaleY\\\", 1);\\r\\n                    this.forceUpdate();\\r\\n                  }}\\r\\n                  draggable\\r\\n                  onDragMove={() => {\\r\\n                    console.log(\\r\\n                      \\\"name of ellipse moving: \\\",\\r\\n                      eachEllipse.name,\\r\\n                      \\\"new x y\\\",\\r\\n                      eachEllipse.x,\\r\\n                      eachEllipse.y\\r\\n                    );\\r\\n                    this.state.arrows.map(eachArrow => {\\r\\n                      if (eachArrow.from !== undefined) {\\r\\n                        console.log(\\\"prevArrow: \\\", eachArrow.points);\\r\\n                        if (eachEllipse.name == eachArrow.from.attrs.name) {\\r\\n                          eachArrow.points = [\\r\\n                            eachEllipse.x,\\r\\n                            eachEllipse.y,\\r\\n                            eachArrow.points[2],\\r\\n                            eachArrow.points[3]\\r\\n                          ];\\r\\n                          this.forceUpdate();\\r\\n                          this.refs.graphicStage.draw();\\r\\n                        }\\r\\n                        console.log(\\\"new arrows:\\\", eachArrow.points);\\r\\n                      }\\r\\n\\r\\n                      if (eachArrow.to !== undefined) {\\r\\n                        if (eachEllipse.name === eachArrow.to.attrs.name) {\\r\\n                          eachArrow.points = [\\r\\n                            eachArrow.points[0],\\r\\n                            eachArrow.points[1],\\r\\n                            eachEllipse.x,\\r\\n                            eachEllipse.y\\r\\n                          ];\\r\\n                          this.forceUpdate();\\r\\n                          this.refs.graphicStage.draw();\\r\\n                        }\\r\\n                      }\\r\\n                    });\\r\\n                  }}\\r\\n                  onDragEnd={event => {\\r\\n                    //cannot compare by name because currentSelected might not be the same\\r\\n                    //have to use ref, which appears to be overcomplicated\\r\\n                    var shape = this.refs[eachEllipse.ref];\\r\\n\\r\\n                    this.setState(prevState => ({\\r\\n                      ellipses: prevState.ellipses.map(eachEllipse =>\\r\\n                        eachEllipse.name === shape.attrs.name\\r\\n                          ? {\\r\\n                              ...eachEllipse,\\r\\n                              x: event.target.x(),\\r\\n                              y: event.target.y()\\r\\n                            }\\r\\n                          : eachEllipse\\r\\n                      )\\r\\n                    }));\\r\\n\\r\\n                    this.refs.graphicStage.draw();\\r\\n                  }}\\r\\n                />\\r\\n              ))}\\r\\n              {this.state.stars.map(eachStar => (\\r\\n                <Star\\r\\n                  ref={eachStar.ref}\\r\\n                  name={eachStar.name}\\r\\n                  x={eachStar.x}\\r\\n                  y={eachStar.y}\\r\\n                  innerRadius={eachStar.innerRadius}\\r\\n                  outerRadius={eachStar.outerRadius}\\r\\n                  numPoints={eachStar.numPoints}\\r\\n                  stroke={eachStar.stroke}\\r\\n                  strokeWidth={eachStar.strokeWidth}\\r\\n                  fill={eachStar.fill}\\r\\n                  strokeScaleEnabled={false}\\r\\n                  rotation={eachStar.rotation}\\r\\n                  onClick={() => {\\r\\n                    var that = this;\\r\\n                    if (eachStar.link !== undefined && eachStar.link !== \\\"\\\") {\\r\\n                      this.setState(\\r\\n                        {\\r\\n                          errMsg: \\\"Links will not be opened in create mode\\\"\\r\\n                        },\\r\\n                        () => {\\r\\n                          setTimeout(function() {\\r\\n                            that.setState({\\r\\n                              errMsg: \\\"\\\"\\r\\n                            });\\r\\n                          }, 1000);\\r\\n                        }\\r\\n                      );\\r\\n                    }\\r\\n                  }}\\r\\n                  onTransformStart={() => {\\r\\n                    this.setState({ isTransforming: true });\\r\\n                  }}\\r\\n                  onTransformEnd={() => {\\r\\n                    this.setState({ isTransforming: false });\\r\\n                    let star = this.refs[eachStar.ref];\\r\\n                    let scaleX = star.scaleX(),\\r\\n                      scaleY = star.scaleY();\\r\\n\\r\\n                    this.setState(prevState => ({\\r\\n                      stars: prevState.stars.map(eachStar =>\\r\\n                        eachStar.name === star.attrs.name\\r\\n                          ? {\\r\\n                              ...eachStar,\\r\\n                              innerRadius: star.innerRadius() * star.scaleX(),\\r\\n                              outerRadius: star.outerRadius() * star.scaleX(),\\r\\n                              rotation: star.rotation(),\\r\\n                              x: star.x(),\\r\\n                              y: star.y()\\r\\n                            }\\r\\n                          : eachStar\\r\\n                      )\\r\\n                    }));\\r\\n                    star.setAttr(\\\"scaleX\\\", 1);\\r\\n                    star.setAttr(\\\"scaleY\\\", 1);\\r\\n                    this.forceUpdate();\\r\\n                  }}\\r\\n                  draggable\\r\\n                  onDragMove={() => {\\r\\n                    this.state.arrows.map(eachArrow => {\\r\\n                      if (eachArrow.from !== undefined) {\\r\\n                        if (eachStar.name == eachArrow.from.attrs.name) {\\r\\n                          eachArrow.points = [\\r\\n                            eachStar.x,\\r\\n                            eachStar.y,\\r\\n                            eachArrow.points[2],\\r\\n                            eachArrow.points[3]\\r\\n                          ];\\r\\n                          this.forceUpdate();\\r\\n                        }\\r\\n                      }\\r\\n\\r\\n                      if (eachArrow.to !== undefined) {\\r\\n                        if (eachStar.name === eachArrow.to.attrs.name) {\\r\\n                          eachArrow.points = [\\r\\n                            eachArrow.points[0],\\r\\n                            eachArrow.points[1],\\r\\n                            eachStar.x,\\r\\n                            eachStar.y\\r\\n                          ];\\r\\n                          this.forceUpdate();\\r\\n                        }\\r\\n                      }\\r\\n                    });\\r\\n                  }}\\r\\n                  onDragEnd={event => {\\r\\n                    //cannot compare by name because currentSelected might not be the same\\r\\n                    //have to use ref, which appears to be overcomplicated\\r\\n                    var shape = this.refs[eachStar.ref];\\r\\n\\r\\n                    this.setState(prevState => ({\\r\\n                      stars: prevState.stars.map(eachStar =>\\r\\n                        eachStar.name === shape.attrs.name\\r\\n                          ? {\\r\\n                              ...eachStar,\\r\\n                              x: event.target.x(),\\r\\n                              y: event.target.y()\\r\\n                            }\\r\\n                          : eachStar\\r\\n                      )\\r\\n                    }));\\r\\n                  }}\\r\\n                />\\r\\n              ))}\\r\\n              {this.state.texts.map(eachText => (\\r\\n                //perhaps this.state.texts only need to contain refs?\\r\\n                //so that we only need to store the refs to get more information\\r\\n                <Text\\r\\n                  textDecoration={eachText.link ? \\\"underline\\\" : \\\"\\\"}\\r\\n                  onTransformStart={() => {\\r\\n                    var currentText = this.refs[this.state.selectedShapeName];\\r\\n                    currentText.setAttr(\\\"lastRotation\\\", currentText.rotation());\\r\\n                  }}\\r\\n                  onTransform={() => {\\r\\n                    var currentText = this.refs[this.state.selectedShapeName];\\r\\n\\r\\n                    currentText.setAttr(\\r\\n                      \\\"width\\\",\\r\\n                      currentText.width() * currentText.scaleX()\\r\\n                    );\\r\\n                    currentText.setAttr(\\\"scaleX\\\", 1);\\r\\n\\r\\n                    currentText.draw();\\r\\n\\r\\n                    if (\\r\\n                      currentText.attrs.lastRotation !== currentText.rotation()\\r\\n                    ) {\\r\\n                      this.state.arrows.map(eachArrow => {\\r\\n                        if (\\r\\n                          eachArrow.to &&\\r\\n                          eachArrow.to.name() === currentText.name()\\r\\n                        ) {\\r\\n                          this.setState({\\r\\n                            errMsg:\\r\\n                              \\\"Rotating texts with connectors might skew things up!\\\"\\r\\n                          });\\r\\n                        }\\r\\n                        if (\\r\\n                          eachArrow.from &&\\r\\n                          eachArrow.from.name() === currentText.name()\\r\\n                        ) {\\r\\n                          this.setState({\\r\\n                            errMsg:\\r\\n                              \\\"Rotating texts with connectors might skew things up!\\\"\\r\\n                          });\\r\\n                        }\\r\\n                      });\\r\\n                    }\\r\\n\\r\\n                    currentText.setAttr(\\\"lastRotation\\\", currentText.rotation());\\r\\n                  }}\\r\\n                  onTransformEnd={() => {\\r\\n                    var currentText = this.refs[this.state.selectedShapeName];\\r\\n\\r\\n                    this.setState(prevState => ({\\r\\n                      errMsg: \\\"\\\",\\r\\n                      texts: prevState.texts.map(eachText =>\\r\\n                        eachText.name === this.state.selectedShapeName\\r\\n                          ? {\\r\\n                              ...eachText,\\r\\n                              width: currentText.width(),\\r\\n                              rotation: currentText.rotation(),\\r\\n                              textWidth: currentText.textWidth,\\r\\n                              textHeight: currentText.textHeight,\\r\\n                              x: currentText.x(),\\r\\n                              y: currentText.y()\\r\\n                            }\\r\\n                          : eachText\\r\\n                      )\\r\\n                    }));\\r\\n                    currentText.setAttr(\\\"scaleX\\\", 1);\\r\\n                    currentText.draw();\\r\\n                  }}\\r\\n                  link={eachText.link}\\r\\n                  width={eachText.width}\\r\\n                  fill={eachText.fill}\\r\\n                  name={eachText.name}\\r\\n                  ref={eachText.ref}\\r\\n                  rotation={eachText.rotation}\\r\\n                  fontFamily={eachText.fontFamily}\\r\\n                  fontSize={eachText.fontSize}\\r\\n                  x={eachText.x}\\r\\n                  y={eachText.y}\\r\\n                  text={eachText.text}\\r\\n                  draggable\\r\\n                  onDragMove={() => {\\r\\n                    this.state.arrows.map(eachArrow => {\\r\\n                      if (eachArrow.from !== undefined) {\\r\\n                        if (eachText.name === eachArrow.from.attrs.name) {\\r\\n                          eachArrow.points = [\\r\\n                            eachText.x,\\r\\n                            eachText.y,\\r\\n                            eachArrow.points[2],\\r\\n                            eachArrow.points[3]\\r\\n                          ];\\r\\n                          this.forceUpdate();\\r\\n                        }\\r\\n                      }\\r\\n\\r\\n                      if (eachArrow.to !== undefined) {\\r\\n                        if (eachText.name === eachArrow.to.attrs.name) {\\r\\n                          eachArrow.points = [\\r\\n                            eachArrow.points[0],\\r\\n                            eachArrow.points[1],\\r\\n                            eachText.x,\\r\\n                            eachText.y\\r\\n                          ];\\r\\n                          this.forceUpdate();\\r\\n                        }\\r\\n                      }\\r\\n                    });\\r\\n                  }}\\r\\n                  onDragEnd={event => {\\r\\n                    //cannot compare by name because currentSelected might not be the same\\r\\n                    //have to use ref, which appears to be overcomplicated\\r\\n                    var shape = this.refs[eachText.ref];\\r\\n\\r\\n                    this.setState(prevState => ({\\r\\n                      texts: prevState.texts.map(eachtext =>\\r\\n                        eachtext.name === shape.attrs.name\\r\\n                          ? {\\r\\n                              ...eachtext,\\r\\n                              x: event.target.x(),\\r\\n                              y: event.target.y()\\r\\n                            }\\r\\n                          : eachtext\\r\\n                      )\\r\\n                    }));\\r\\n                  }}\\r\\n                  onClick={() => {\\r\\n                    var that = this;\\r\\n                    if (eachText.link !== undefined && eachText.link !== \\\"\\\") {\\r\\n                      this.setState(\\r\\n                        {\\r\\n                          errMsg: \\\"Links will not be opened in create mode\\\"\\r\\n                        },\\r\\n                        () => {\\r\\n                          setTimeout(function() {\\r\\n                            that.setState({\\r\\n                              errMsg: \\\"\\\"\\r\\n                            });\\r\\n                          }, 1000);\\r\\n                        }\\r\\n                      );\\r\\n\\r\\n                      //var win = window.open(eachText.link, \\\"_blank\\\");\\r\\n                      //win.focus();\\r\\n                    }\\r\\n                  }}\\r\\n                  onDblClick={() => {\\r\\n                    // turn into textarea\\r\\n                    var stage = this.refs.graphicStage;\\r\\n                    var text = stage.findOne(\\\".\\\" + eachText.name);\\r\\n\\r\\n                    this.setState({\\r\\n                      textX: text.absolutePosition().x,\\r\\n                      textY: text.absolutePosition().y,\\r\\n                      textEditVisible: !this.state.textEditVisible,\\r\\n                      text: eachText.text,\\r\\n                      textNode: eachText,\\r\\n                      currentTextRef: eachText.ref,\\r\\n                      textareaWidth: text.textWidth,\\r\\n                      textareaHeight: text.textHeight,\\r\\n                      textareaFill: text.attrs.fill,\\r\\n                      textareaFontFamily: text.attrs.fontFamily,\\r\\n                      textareaFontSize: text.attrs.fontSize\\r\\n                    });\\r\\n                    let textarea = this.refs.textarea;\\r\\n                    textarea.focus();\\r\\n                    text.hide();\\r\\n                    var transformer = stage.findOne(\\\".transformer\\\");\\r\\n                    transformer.hide();\\r\\n                    this.refs.layer2.draw();\\r\\n                  }}\\r\\n                />\\r\\n              ))}\\r\\n              {this.state.arrows.map(eachArrow => {\\r\\n                if (!eachArrow.from && !eachArrow.to) {\\r\\n                  return (\\r\\n                    <Arrow\\r\\n                      ref={eachArrow.ref}\\r\\n                      name={eachArrow.name}\\r\\n                      points={[\\r\\n                        eachArrow.points[0],\\r\\n                        eachArrow.points[1],\\r\\n                        eachArrow.points[2],\\r\\n                        eachArrow.points[3]\\r\\n                      ]}\\r\\n                      stroke={eachArrow.stroke}\\r\\n                      fill={eachArrow.fill}\\r\\n                      draggable\\r\\n                      onDragEnd={event => {\\r\\n                        //set new points to current position\\r\\n\\r\\n                        //usually: state => star => x & y\\r\\n                        //now: state => arrow => attr => x & y\\r\\n\\r\\n                        let oldPoints = [\\r\\n                          eachArrow.points[0],\\r\\n                          eachArrow.points[1],\\r\\n                          eachArrow.points[2],\\r\\n                          eachArrow.points[3]\\r\\n                        ];\\r\\n\\r\\n                        let shiftX = this.refs[eachArrow.ref].attrs.x;\\r\\n                        let shiftY = this.refs[eachArrow.ref].attrs.y;\\r\\n\\r\\n                        let newPoints = [\\r\\n                          oldPoints[0] + shiftX,\\r\\n                          oldPoints[1] + shiftY,\\r\\n                          oldPoints[2] + shiftX,\\r\\n                          oldPoints[3] + shiftY\\r\\n                        ];\\r\\n\\r\\n                        this.refs[eachArrow.ref].position({ x: 0, y: 0 });\\r\\n                        this.refs.layer2.draw();\\r\\n\\r\\n                        this.setState(prevState => ({\\r\\n                          arrows: prevState.arrows.map(eachArr =>\\r\\n                            eachArr.name === eachArrow.name\\r\\n                              ? {\\r\\n                                  ...eachArr,\\r\\n                                  points: newPoints\\r\\n                                }\\r\\n                              : eachArr\\r\\n                          )\\r\\n                        }));\\r\\n                      }}\\r\\n                    />\\r\\n                  );\\r\\n                } else if (\\r\\n                  eachArrow.name === this.state.newArrowRef &&\\r\\n                  (eachArrow.from || eachArrow.to)\\r\\n                ) {\\r\\n                  return (\\r\\n                    <Connector\\r\\n                      name={eachArrow.name}\\r\\n                      from={eachArrow.from}\\r\\n                      to={eachArrow.to}\\r\\n                      arrowEndX={this.state.arrowEndX}\\r\\n                      arrowEndY={this.state.arrowEndY}\\r\\n                      current={true}\\r\\n                      stroke={eachArrow.stroke}\\r\\n                      fill={eachArrow.fill}\\r\\n                    />\\r\\n                  );\\r\\n                } else if (eachArrow.from || eachArrow.to) {\\r\\n                  //if arrow construction is completed\\r\\n                  return (\\r\\n                    <Connector\\r\\n                      name={eachArrow.name}\\r\\n                      from={eachArrow.from}\\r\\n                      to={eachArrow.to}\\r\\n                      points={eachArrow.points}\\r\\n                      current={false}\\r\\n                      stroke={eachArrow.stroke}\\r\\n                      fill={eachArrow.fill}\\r\\n                    />\\r\\n                  );\\r\\n                }\\r\\n              })}\\r\\n\\r\\n              {this.state.selectedShapeName.includes(\\\"text\\\") ? (\\r\\n                <TransformerComponent\\r\\n                  selectedShapeName={this.state.selectedShapeName}\\r\\n                />\\r\\n              ) : (\\r\\n                <TransformerComponent\\r\\n                  selectedShapeName={this.state.selectedShapeName}\\r\\n                />\\r\\n              )}\\r\\n            </Layer>\\r\\n\\r\\n            <Layer\\r\\n              height={window.innerHeight}\\r\\n              width={window.innerWidth}\\r\\n              ref=\\\"layer\\\"\\r\\n            >\\r\\n              <Toolbar\\r\\n                layer={this.refs.layer2}\\r\\n                rectName={\\r\\n                  this.state.rectangles.length + 1 + this.state.rectDeleteCount\\r\\n                }\\r\\n                ellipseName={\\r\\n                  this.state.ellipses.length + 1 + this.state.ellipseDeleteCount\\r\\n                }\\r\\n                starName={\\r\\n                  this.state.stars.length + 1 + this.state.starDeleteCount\\r\\n                }\\r\\n                textName={\\r\\n                  this.state.texts.length + 1 + this.state.textDeleteCount\\r\\n                }\\r\\n                newArrowOnDragEnd={toPush => {\\r\\n                  if (toPush.from !== undefined) {\\r\\n                    //  console.log(\\\"we are making a connector\\\");\\r\\n\\r\\n                    var transform = this.refs.layer2\\r\\n                      .getAbsoluteTransform()\\r\\n                      .copy();\\r\\n                    transform.invert();\\r\\n                    let uh = transform.point({\\r\\n                      x: toPush.x,\\r\\n                      y: toPush.y\\r\\n                    });\\r\\n                    toPush.x = uh.x;\\r\\n                    toPush.y = uh.y;\\r\\n\\r\\n                    var newArrow = {\\r\\n                      points: toPush.points,\\r\\n                      ref:\\r\\n                        \\\"arrow\\\" +\\r\\n                        (this.state.arrows.length +\\r\\n                          1 +\\r\\n                          this.state.arrowDeleteCount),\\r\\n                      name:\\r\\n                        \\\"arrow\\\" +\\r\\n                        (this.state.arrows.length +\\r\\n                          1 +\\r\\n                          this.state.arrowDeleteCount),\\r\\n                      from: toPush.from,\\r\\n                      stroke: toPush.stroke,\\r\\n                      strokeWidth: toPush.strokeWidth,\\r\\n                      fill: toPush.fill\\r\\n                    };\\r\\n\\r\\n                    //  console.log(newArrow);\\r\\n                    this.setState(prevState => ({\\r\\n                      arrows: [...prevState.arrows, newArrow],\\r\\n                      newArrowDropped: true,\\r\\n                      newArrowRef: newArrow.name,\\r\\n                      arrowEndX: toPush.x,\\r\\n                      arrowEndY: toPush.y\\r\\n                    }));\\r\\n                  } else {\\r\\n                    //  console.log(\\\"we are making just an aarrow\\\");\\r\\n                    var transform = this.refs.layer2\\r\\n                      .getAbsoluteTransform()\\r\\n                      .copy();\\r\\n                    transform.invert();\\r\\n                    let uh = transform.point({\\r\\n                      x: toPush.x,\\r\\n                      y: toPush.y\\r\\n                    });\\r\\n                    toPush.x = uh.x;\\r\\n                    toPush.y = uh.y;\\r\\n                    var newArrow = {\\r\\n                      points: [toPush.x, toPush.y, toPush.x, toPush.y],\\r\\n                      ref:\\r\\n                        \\\"arrow\\\" +\\r\\n                        (this.state.arrows.length +\\r\\n                          1 +\\r\\n                          this.state.arrowDeleteCount),\\r\\n                      name:\\r\\n                        \\\"arrow\\\" +\\r\\n                        (this.state.arrows.length +\\r\\n                          1 +\\r\\n                          this.state.arrowDeleteCount),\\r\\n                      from: toPush.from,\\r\\n                      stroke: toPush.stroke,\\r\\n                      strokeWidth: toPush.strokeWidth,\\r\\n                      fill: toPush.fill\\r\\n                    };\\r\\n\\r\\n                    this.setState(prevState => ({\\r\\n                      arrows: [...prevState.arrows, newArrow],\\r\\n                      newArrowDropped: true,\\r\\n                      newArrowRef: newArrow.name,\\r\\n                      arrowEndX: toPush.x,\\r\\n                      arrowEndY: toPush.y\\r\\n                    }));\\r\\n                  }\\r\\n\\r\\n                  //this.refs updates after forceUpdate (because arrow gets instantiated), might be risky in the future\\r\\n                  //only this.state.arrows.length because it was pushed earlier, cancelling the +1\\r\\n                }}\\r\\n                appendToRectangles={stuff => {\\r\\n                  var layer = this.refs.layer2;\\r\\n                  var toPush = stuff;\\r\\n                  var stage = this.refs.graphicStage;\\r\\n                  var transform = this.refs.layer2\\r\\n                    .getAbsoluteTransform()\\r\\n                    .copy();\\r\\n                  transform.invert();\\r\\n\\r\\n                  var pos = transform.point({\\r\\n                    x: toPush.x,\\r\\n                    y: toPush.y\\r\\n                  });\\r\\n\\r\\n                  if (layer.attrs.x !== null || layer.attrs.x !== undefined) {\\r\\n                    toPush.x = pos.x;\\r\\n                    toPush.y = pos.y;\\r\\n                  }\\r\\n\\r\\n                  this.setState(prevState => ({\\r\\n                    rectangles: [...prevState.rectangles, toPush],\\r\\n                    selectedShapeName: toPush.name\\r\\n                  }));\\r\\n                }}\\r\\n                appendToEllipses={stuff => {\\r\\n                  var layer = this.refs.layer2;\\r\\n                  var toPush = stuff;\\r\\n                  var stage = this.refs.graphicStage;\\r\\n                  var transform = this.refs.layer2\\r\\n                    .getAbsoluteTransform()\\r\\n                    .copy();\\r\\n                  transform.invert();\\r\\n\\r\\n                  var pos = transform.point({\\r\\n                    x: toPush.x,\\r\\n                    y: toPush.y\\r\\n                  });\\r\\n\\r\\n                  if (layer.attrs.x !== null || layer.attrs.x !== undefined) {\\r\\n                    toPush.x = pos.x;\\r\\n                    toPush.y = pos.y;\\r\\n                  }\\r\\n\\r\\n                  this.setState(prevState => ({\\r\\n                    ellipses: [...prevState.ellipses, toPush],\\r\\n                    selectedShapeName: toPush.name\\r\\n                  }));\\r\\n                }}\\r\\n                appendToStars={stuff => {\\r\\n                  var layer = this.refs.layer2;\\r\\n                  var toPush = stuff;\\r\\n                  var stage = this.refs.graphicStage;\\r\\n                  var transform = this.refs.layer2\\r\\n                    .getAbsoluteTransform()\\r\\n                    .copy();\\r\\n                  transform.invert();\\r\\n\\r\\n                  var pos = transform.point({\\r\\n                    x: toPush.x,\\r\\n                    y: toPush.y\\r\\n                  });\\r\\n\\r\\n                  if (layer.attrs.x !== null || layer.attrs.x !== undefined) {\\r\\n                    toPush.x = pos.x;\\r\\n                    toPush.y = pos.y;\\r\\n                  }\\r\\n                  this.setState(prevState => ({\\r\\n                    stars: [...prevState.stars, toPush],\\r\\n                    selectedShapeName: toPush.name\\r\\n                  }));\\r\\n                }}\\r\\n                appendToTexts={stuff => {\\r\\n                  var layer = this.refs.layer2;\\r\\n                  var toPush = stuff;\\r\\n                  var stage = this.refs.graphicStage;\\r\\n                  var transform = this.refs.layer2\\r\\n                    .getAbsoluteTransform()\\r\\n                    .copy();\\r\\n                  transform.invert();\\r\\n\\r\\n                  var pos = transform.point({\\r\\n                    x: toPush.x,\\r\\n                    y: toPush.y\\r\\n                  });\\r\\n\\r\\n                  if (layer.attrs.x !== null || layer.attrs.x !== undefined) {\\r\\n                    toPush.x = pos.x;\\r\\n                    toPush.y = pos.y;\\r\\n                  }\\r\\n\\r\\n                  this.setState(prevState => ({\\r\\n                    texts: [...prevState.texts, toPush]\\r\\n                  }));\\r\\n\\r\\n                  //we can also just get element by this.refs.toPush.ref\\r\\n\\r\\n                  //  let text = stage.findOne(\\\".\\\" + toPush.name);\\r\\n                  let text = this.refs[toPush.ref];\\r\\n                  //this.setState({firstTimeTextEditing: true});\\r\\n                  text.fire(\\\"dblclick\\\");\\r\\n                }}\\r\\n              />\\r\\n            </Layer>\\r\\n          </Stage>\\r\\n\\r\\n          <textarea\\r\\n            ref=\\\"textarea\\\"\\r\\n            id=\\\"textarea\\\"\\r\\n            value={this.state.text}\\r\\n            onChange={e => {\\r\\n              this.setState({\\r\\n                text: e.target.value,\\r\\n                shouldTextUpdate: false\\r\\n              });\\r\\n            }}\\r\\n            onKeyDown={e => {\\r\\n              if (e.keyCode === 13) {\\r\\n                this.setState({\\r\\n                  textEditVisible: false,\\r\\n                  shouldTextUpdate: true\\r\\n                });\\r\\n\\r\\n                // get the current textNode we are editing, get the name from there\\r\\n                //match name with elements in this.state.texts,\\r\\n                let node = this.refs[this.state.currentTextRef];\\r\\n                console.log(\\\"node width before set\\\", node.textWidth);\\r\\n                let name = node.attrs.name;\\r\\n                this.setState(\\r\\n                  prevState => ({\\r\\n                    selectedShapeName: name,\\r\\n                    texts: prevState.texts.map(eachText =>\\r\\n                      eachText.name === name\\r\\n                        ? {\\r\\n                            ...eachText,\\r\\n                            text: this.state.text\\r\\n                          }\\r\\n                        : eachText\\r\\n                    )\\r\\n                  }),\\r\\n                  () => {\\r\\n                    this.setState(prevState => ({\\r\\n                      texts: prevState.texts.map(eachText =>\\r\\n                        eachText.name === name\\r\\n                          ? {\\r\\n                              ...eachText,\\r\\n                              textWidth: node.textWidth,\\r\\n                              textHeight: node.textHeight\\r\\n                            }\\r\\n                          : eachText\\r\\n                      )\\r\\n                    }));\\r\\n                  }\\r\\n                );\\r\\n\\r\\n                node.show();\\r\\n                this.refs.graphicStage.findOne(\\\".transformer\\\").show();\\r\\n              }\\r\\n            }}\\r\\n            onBlur={() => {\\r\\n              this.setState({\\r\\n                textEditVisible: false,\\r\\n                shouldTextUpdate: true\\r\\n              });\\r\\n\\r\\n              // get the current textNode we are editing, get the name from there\\r\\n              //match name with elements in this.state.texts,\\r\\n\\r\\n              let node = this.refs.graphicStage.findOne(\\r\\n                \\\".\\\" + this.state.currentTextRef\\r\\n              );\\r\\n              let name = node.attrs.name;\\r\\n\\r\\n              this.setState(\\r\\n                prevState => ({\\r\\n                  selectedShapeName: name,\\r\\n                  texts: prevState.texts.map(eachText =>\\r\\n                    eachText.name === name\\r\\n                      ? {\\r\\n                          ...eachText,\\r\\n                          text: this.state.text\\r\\n                        }\\r\\n                      : eachText\\r\\n                  )\\r\\n                }),\\r\\n                () => {\\r\\n                  this.setState(prevState => ({\\r\\n                    texts: prevState.texts.map(eachText =>\\r\\n                      eachText.name === name\\r\\n                        ? {\\r\\n                            ...eachText,\\r\\n                            textWidth: node.textWidth,\\r\\n                            textHeight: node.textHeight\\r\\n                          }\\r\\n                        : eachText\\r\\n                    )\\r\\n                  }));\\r\\n                }\\r\\n              );\\r\\n              node.show();\\r\\n              this.refs.graphicStage.findOne(\\\".transformer\\\").show();\\r\\n              this.refs.graphicStage.draw();\\r\\n            }}\\r\\n            style={{\\r\\n              //set position, width, height, fontSize, overflow, lineHeight, color\\r\\n              display: this.state.textEditVisible ? \\\"block\\\" : \\\"none\\\",\\r\\n              position: \\\"absolute\\\",\\r\\n              top: this.state.textY + 80 + \\\"px\\\",\\r\\n              left: this.state.textX + \\\"px\\\",\\r\\n              width: \\\"300px\\\",\\r\\n              height: \\\"300px\\\",\\r\\n              overflow: \\\"hidden\\\",\\r\\n              fontSize: this.state.textareaFontSize,\\r\\n              fontFamily: this.state.textareaFontFamily,\\r\\n              color: this.state.textareaFill,\\r\\n              border: \\\"none\\\",\\r\\n              padding: \\\"0px\\\",\\r\\n              margin: \\\"0px\\\",\\r\\n              outline: \\\"none\\\",\\r\\n              resize: \\\"none\\\",\\r\\n              background: \\\"none\\\"\\r\\n            }}\\r\\n          />\\r\\n          <div className=\\\"errMsg\\\">{errDisplay}</div>\\r\\n        </div>\\r\\n      </React.Fragment>\\r\\n    );\\r\\n  }\\r\\n}\\r\\nconst mapStateToProps = state => ({\\r\\n  auth: state.auth\\r\\n});\\r\\n\\r\\nexport default Graphics;\\r\\n\",\"import React from \\\"react\\\";\\r\\nimport ReactDOM from \\\"react-dom\\\";\\r\\nimport { CSSTransition } from \\\"react-transition-group\\\";\\r\\n\\r\\nimport \\\"./styles.css\\\";\\r\\nimport ColoredRect from \\\"./App.js\\\";\\r\\n\\r\\nclass FadeInAndOut extends React.Component {\\r\\n  constructor(...args) {\\r\\n    super(...args);\\r\\n    this.state = { show: false };\\r\\n\\r\\n    setInterval(() => {\\r\\n      this.setState({ show: !this.state.show });\\r\\n    }, 2000);\\r\\n  }\\r\\n\\r\\n  render() {\\r\\n    return (\\r\\n      <div>\\r\\n        <a\\r\\n          onClick={() => {\\r\\n            this.setState({ show: !this.state.show });\\r\\n          }}\\r\\n          style={{ cursor: \\\"pointer\\\", padding: \\\"20px\\\" }}\\r\\n        >\\r\\n          Woah\\r\\n        </a>\\r\\n        <CSSTransition in={this.state.show} timeout={1200} classNames=\\\"base\\\">\\r\\n          <div>Hello World</div>\\r\\n        </CSSTransition>\\r\\n      </div>\\r\\n    );\\r\\n  }\\r\\n}\\r\\n\\r\\nReactDOM.render(<ColoredRect />, document.getElementById(\\\"root\\\"));\\r\\n\"]}","code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[0],{101:function(t,e,a){\"use strict\";a.r(e);var r=a(10),s=a(11),n=a(13),i=a(12),o=a(14),l=a(0),h=a.n(l),c=a(21),d=a.n(c),f=a(103),u=(a(44),a(8)),p=a(9),m=a(25),g=a.n(m),x=a(37),y=a(17),w=a(5),S=function(t){function e(){var t,a;Object(r.a)(this,e);for(var s=arguments.length,o=new Array(s),l=0;l<s;l++)o[l]=arguments[l];return(a=Object(n.a)(this,(t=Object(i.a)(e)).call.apply(t,[this].concat(o)))).getConnectorPoints=function(t){var e=t.points,a=t.from,r=t.to,s=t.mouseX,n=t.mouseY;if(\"FromAndTo\"===t.type)if(r.attrs.name.includes(\"rect\")&&a.attrs.name.includes(\"rect\")){var i=r.attrs.y+r.attrs.height/2-(a.attrs.y+a.attrs.height/2),o=r.attrs.x+r.attrs.width/2-(a.attrs.x+a.attrs.width/2),l=Math.atan2(i,o)/Math.PI*180;l<=45&&l>=-45?(e[0]+=a.attrs.width,e[1]+=a.attrs.height/2,e[3]+=r.attrs.height/2):l>45&&l<135?(e[0]+=a.attrs.width/2,e[1]+=a.attrs.height,e[2]+=r.attrs.width/2):l>135&&l<180||l>-180&&l<-135?(e[1]+=a.attrs.height/2,e[2]+=r.attrs.width,e[3]+=r.attrs.height/2):l<-45&&l>-135&&(e[0]+=a.attrs.width/2,e[3]+=r.attrs.height,e[2]+=r.attrs.width/2)}else if(r.attrs.name.includes(\"rect\")&&a.attrs.name.includes(\"text\")){var h=a.textHeight||a.attrs.textHeight,c=a.textWidth||a.attrs.textWidth;i=r.attrs.y+r.attrs.height/2-(a.attrs.y+h/2),o=r.attrs.x+r.attrs.width/2-(a.attrs.x+c/2);var d=Math.atan2(i,o)/Math.PI*180;d<=45&&d>=-45?(e[0]+=c,e[1]+=h/2,e[3]+=r.attrs.height/2):d>45&&d<135?(e[0]+=c/2,e[1]+=h,e[2]+=r.attrs.width/2):d>135&&d<180||d>-180&&d<-135?(e[1]+=h/2,e[2]+=r.attrs.width,e[3]+=r.attrs.height/2):d<-45&&d>-135&&(e[0]+=c/2,e[3]+=r.attrs.height,e[2]+=r.attrs.width/2)}else if(r.attrs.name.includes(\"ellipse\")&&a.attrs.name.includes(\"ellipse\")){var f={x:a.attrs.x,y:a.attrs.y},u=e[3]-e[1],p=e[2]-e[0],m=Math.atan2(-u,p);e[0]+=-a.attrs.radiusX*Math.cos(m+Math.PI),e[1]+=a.attrs.radiusY*Math.sin(m+Math.PI),e[2]+=r.attrs.radiusX*Math.cos(m+Math.PI),e[3]-=r.attrs.radiusY*Math.sin(m+Math.PI)}else if(r.attrs.name.includes(\"star\")&&a.attrs.name.includes(\"star\")){f={x:a.attrs.x,y:a.attrs.y},i=e[3]-e[1],o=e[2]-e[0];var g=Math.atan2(-i,o);e[0]+=-a.attrs.outerRadius*Math.cos(g+Math.PI),e[1]+=a.attrs.outerRadius*Math.sin(g+Math.PI),e[2]+=r.attrs.outerRadius*Math.cos(g+Math.PI),e[3]-=r.attrs.outerRadius*Math.sin(g+Math.PI)}else if(r.attrs.name.includes(\"text\")&&a.attrs.name.includes(\"text\")){var x=a.textHeight||a.attrs.textHeight,y=a.textWidth||a.attrs.textWidth,w=r.textHeight||r.attrs.textHeight,S=r.textWidth||r.attrs.textWidth;i=r.attrs.y+w/2-(a.attrs.y+x/2),o=r.attrs.x+S/2-(a.attrs.x+y/2);var v=Math.atan2(i,o)/Math.PI*180;v<=45&&v>=-45?(e[0]+=y,e[1]+=x/2,e[3]+=w/2):v>45&&v<135?(e[0]+=y/2,e[1]+=x,e[2]+=S/2):v>135&&v<180||v>-180&&v<-135?(e[1]+=x/2,e[2]+=S,e[3]+=w/2):v<-45&&v>-135&&(e[0]+=y/2,e[3]+=w,e[2]+=S/2)}else if(a.attrs.name.includes(\"rect\")&&r.attrs.name.includes(\"ellipse\")){var k=r.attrs.y+-(a.attrs.y+a.attrs.height/2),M=r.attrs.x+-(a.attrs.x+a.attrs.width/2),b=Math.atan2(k,M)/Math.PI*180;b<=-45&&b>=-135?e[0]+=a.attrs.width/2:b>45&&b<135?(e[0]+=a.attrs.width/2,e[1]+=a.attrs.height):b>135&&b<180||b>-180&&b<-135?e[1]+=a.attrs.height/2:b>-45&&b<45&&(e[0]+=a.attrs.width,e[1]+=a.attrs.height/2);var E=e[3]-e[1],P=e[2]-e[0];b=Math.atan2(-E,P),e[2]+=r.attrs.radiusX*Math.cos(b+Math.PI),e[3]-=r.attrs.radiusY*Math.sin(b+Math.PI)}else if(a.attrs.name.includes(\"rect\")&&r.attrs.name.includes(\"star\")){k=r.attrs.y+-(a.attrs.y+a.attrs.height/2),M=r.attrs.x+-(a.attrs.x+a.attrs.width/2),(b=Math.atan2(k,M)/Math.PI*180)<=-45&&b>=-135?e[0]+=a.attrs.width/2:b>45&&b<135?(e[0]+=a.attrs.width/2,e[1]+=a.attrs.height):b>135&&b<180||b>-180&&b<-135?e[1]+=a.attrs.height/2:b>-45&&b<45&&(e[0]+=a.attrs.width,e[1]+=a.attrs.height/2);var R=e[3]-e[1],C=e[2]-e[0];b=Math.atan2(-R,C),e[2]+=r.attrs.outerRadius*Math.cos(b+Math.PI),e[3]-=r.attrs.outerRadius*Math.sin(b+Math.PI)}else if(a.attrs.name.includes(\"rect\")&&r.attrs.name.includes(\"text\")){var D=r.textHeight||r.attrs.textHeight,I=r.textWidth||r.attrs.textWidth;console.log(r),i=r.attrs.y+D/2-(a.attrs.y+a.attrs.height/2),o=r.attrs.x+I/2-(a.attrs.x+a.attrs.width/2);var T=Math.atan2(i,o)/Math.PI*180;T<=45&&T>=-45?(e[0]+=a.attrs.width,e[1]+=a.attrs.height/2,e[3]+=D/2):T>45&&T<135?(e[0]+=a.attrs.width/2,e[1]+=a.attrs.height,e[2]+=I/2):T>135&&T<180||T>-180&&T<-135?(e[1]+=a.attrs.height/2,e[2]+=I,e[3]+=D/2):T<-45&&T>-135&&(e[0]+=a.attrs.width/2,e[3]+=D,e[2]+=I/2)}else if(a.attrs.name.includes(\"ellipse\")&&r.attrs.name.includes(\"rect\")){k=r.attrs.y+r.attrs.height/2-a.attrs.y,M=r.attrs.x+r.attrs.width/2-a.attrs.x,(b=Math.atan2(k,M)/Math.PI*180)<=-45&&b>=-135?(e[2]+=r.attrs.width/2,e[3]+=r.attrs.height):b>45&&b<135?e[2]+=r.attrs.width/2:b>135&&b<180||b>-180&&b<-135?(e[2]+=r.attrs.width,e[3]+=r.attrs.height/2):b>-45&&b<45&&(e[3]+=r.attrs.height/2);var W=e[3]-e[1],O=e[2]-e[0];b=Math.atan2(-W,O),e[0]-=a.attrs.radiusX*Math.cos(b+Math.PI),e[1]+=a.attrs.radiusY*Math.sin(b+Math.PI)}else if(a.attrs.name.includes(\"ellipse\")&&r.attrs.name.includes(\"text\")){var A=r.textHeight||r.attrs.textHeight,N=r.textWidth||r.attrs.textWidth;k=r.attrs.y+A/2-a.attrs.y,M=r.attrs.x+N/2-a.attrs.x,(b=Math.atan2(k,M)/Math.PI*180)<=-45&&b>=-135?(e[2]+=N/2,e[3]+=A):b>45&&b<135?e[2]+=N/2:b>135&&b<180||b>-180&&b<-135?(e[2]+=N,e[3]+=A/2):b>-45&&b<45&&(e[3]+=A/2);var X=e[3]-e[1],j=e[2]-e[0];b=Math.atan2(-X,j),e[0]-=a.attrs.radiusX*Math.cos(b+Math.PI),e[1]+=a.attrs.radiusY*Math.sin(b+Math.PI),console.log(\"new points\",e,\"from\",a,\"from coord\",a.attrs)}else if(a.attrs.name.includes(\"ellipse\")&&r.attrs.name.includes(\"star\")){f={x:a.attrs.x,y:a.attrs.y};var Y=e[3]-e[1],H=e[2]-e[0],F=Math.atan2(-Y,H);e[0]+=-a.attrs.radiusX*Math.cos(F+Math.PI),e[1]+=a.attrs.radiusY*Math.sin(F+Math.PI),e[2]+=r.attrs.outerRadius*Math.cos(F+Math.PI),e[3]-=r.attrs.outerRadius*Math.sin(F+Math.PI)}else if(a.attrs.name.includes(\"star\")&&r.attrs.name.includes(\"ellipse\")){f={x:a.attrs.x,y:a.attrs.y};var U=e[3]-e[1],z=e[2]-e[0],J=Math.atan2(-U,z);e[0]+=-a.attrs.outerRadius*Math.cos(J+Math.PI),e[1]+=a.attrs.outerRadius*Math.sin(J+Math.PI),e[2]+=r.attrs.radiusX*Math.cos(J+Math.PI),e[3]-=r.attrs.radiusY*Math.sin(J+Math.PI)}else if(a.attrs.name.includes(\"star\")&&r.attrs.name.includes(\"rect\")){k=r.attrs.y+r.attrs.width/2-a.attrs.y,M=r.attrs.x+r.attrs.width/2-a.attrs.x,(b=Math.atan2(k,M)/Math.PI*180)<=-45&&b>=-135?(e[2]+=r.attrs.width/2,e[3]+=r.attrs.height):b>45&&b<135?e[2]+=r.attrs.width/2:b>135&&b<180||b>-180&&b<-135?(e[2]+=r.attrs.width,e[3]+=r.attrs.height/2):b>-45&&b<45&&(e[3]+=r.attrs.width/2);var B=e[3]-e[1],K=e[2]-e[0];b=Math.atan2(-B,K),e[0]-=a.attrs.outerRadius*Math.cos(b+Math.PI),e[1]+=a.attrs.outerRadius*Math.sin(b+Math.PI)}else if(a.attrs.name.includes(\"star\")&&r.attrs.name.includes(\"text\")){var L=r.textHeight||r.attrs.textHeight,V=r.textWidth||r.attrs.textWidth;k=r.attrs.y+L/2-a.attrs.y,M=r.attrs.x+V/2-a.attrs.x,(b=Math.atan2(k,M)/Math.PI*180)<=-45&&b>=-135?(e[2]+=V/2,e[3]+=L):b>45&&b<135?e[2]+=V/2:b>135&&b<180||b>-180&&b<-135?(e[2]+=V,e[3]+=L/2):b>-45&&b<45&&(e[3]+=L/2);var G=e[3]-e[1],q=e[2]-e[0];b=Math.atan2(-G,q),e[0]-=a.attrs.outerRadius*Math.cos(b+Math.PI),e[1]+=a.attrs.outerRadius*Math.sin(b+Math.PI)}else if(a.attrs.name.includes(\"text\")&&r.attrs.name.includes(\"star\")){var Q=a.textHeight||a.attrs.textHeight,Z=a.textWidth||a.attrs.textWidth;k=r.attrs.y+-(a.attrs.y+Q/2),M=r.attrs.x+-(a.attrs.x+Z/2),(b=Math.atan2(k,M)/Math.PI*180)<=-45&&b>=-135?e[0]+=Z/2:b>45&&b<135?(e[0]+=Z/2,e[1]+=Q):b>135&&b<180||b>-180&&b<-135?e[1]+=Q/2:b>-45&&b<45&&(e[0]+=Z,e[1]+=Q/2);var $=e[3]-e[1],_=e[2]-e[0];b=Math.atan2(-$,_),e[2]+=r.attrs.outerRadius*Math.cos(b+Math.PI),e[3]-=r.attrs.outerRadius*Math.sin(b+Math.PI)}else if(a.attrs.name.includes(\"text\")&&r.attrs.name.includes(\"ellipse\")){var tt=a.textHeight||a.attrs.textHeight,et=a.textWidth||a.attrs.textWidth;k=r.attrs.y+-(a.attrs.y+tt/2),M=r.attrs.x+-(a.attrs.x+et/2),(b=Math.atan2(k,M)/Math.PI*180)<=-45&&b>=-135?e[0]+=et/2:b>45&&b<135?(e[0]+=et/2,e[1]+=tt):b>135&&b<180||b>-180&&b<-135?e[1]+=tt/2:b>-45&&b<45&&(e[0]+=et,e[1]+=tt/2);var at=e[3]-e[1],rt=e[2]-e[0];b=Math.atan2(-at,rt),e[2]+=r.attrs.radiusX*Math.cos(b+Math.PI),e[3]-=r.attrs.radiusY*Math.sin(b+Math.PI)}if(\"onlyFrom\"===t.type)if(a.attrs.name.includes(\"rect\"))i=n-(f={x:a.attrs.x+a.attrs.width/2,y:a.attrs.y+a.attrs.height/2}).y,o=s-f.x,(b=Math.atan2(i,o)/Math.PI*180)<=-45&&b>=-135?e[0]+=a.attrs.width/2:b>45&&b<135?(e[0]+=a.attrs.width/2,e[1]+=a.attrs.height):b>135&&b<180||b>-180&&b<-135?e[1]+=a.attrs.height/2:b>-45&&b<45&&(e[0]+=a.attrs.width,e[1]+=a.attrs.height/2);else if(a.attrs.name.includes(\"ellipse\")){f={x:a.attrs.x,y:a.attrs.y};var st=e[3]-e[1],nt=e[2]-e[0],it=Math.atan2(-st,nt);e[0]+=-a.attrs.radiusX*Math.cos(it+Math.PI),e[1]+=a.attrs.radiusY*Math.sin(it+Math.PI)}else if(a.attrs.name.includes(\"star\")){f={x:a.attrs.x,y:a.attrs.y};var ot=e[3]-e[1],lt=e[2]-e[0],ht=Math.atan2(-ot,lt);e[0]+=-a.attrs.outerRadius*Math.cos(ht+Math.PI),e[1]+=a.attrs.outerRadius*Math.sin(ht+Math.PI)}else if(a.attrs.name.includes(\"text\")){var ct=a.textHeight||a.attrs.textHeight,dt=a.textWidth||a.attrs.textWidth;i=n-(f={x:a.attrs.x+dt/2,y:a.attrs.y+dt/2}).y,o=s-f.x,(b=Math.atan2(i,o)/Math.PI*180)<=-45&&b>=-135?e[0]+=dt/2:b>45&&b<135?(e[0]+=dt/2,e[1]+=ct):b>135&&b<180||b>-180&&b<-135?e[1]+=ct/2:b>-45&&b<45&&(e[0]+=dt,e[1]+=ct/2)}if(\"onlyTo\"===t.type)if(r.attrs.name.includes(\"rect\")){var ft={x:e[0],y:e[1]};f={x:r.attrs.x+r.attrs.width/2,y:r.attrs.y+r.attrs.height/2},i=ft.y-f.y,o=ft.x-f.x,(b=Math.atan2(i,o)/Math.PI*180)>45&&b<135?(e[2]+=r.attrs.width/2,e[3]+=r.attrs.height):b>135&&b<180||b>-180&&b<-135?e[3]+=r.attrs.height/2:b>-135&&b<-45?e[2]+=r.attrs.width/2:(e[2]+=r.attrs.width,e[3]+=r.attrs.height/2)}else if(r.attrs.name.includes(\"ellipse\")){var ut=e[3]-e[1],pt=e[2]-e[0],mt=Math.atan2(-ut,pt);e[2]+=r.attrs.radiusX*Math.cos(mt+Math.PI),e[3]-=r.attrs.radiusY*Math.sin(mt+Math.PI)}else if(r.attrs.name.includes(\"star\")){var gt=e[3]-e[1],xt=e[2]-e[0],yt=Math.atan2(-gt,xt);e[2]+=r.attrs.outerRadius*Math.cos(yt+Math.PI),e[3]-=r.attrs.outerRadius*Math.sin(yt+Math.PI)}else if(r.attrs.name.includes(\"text\")){var wt=r.textHeight||r.attrs.textHeight,St=r.textWidth||r.attrs.textWidth;ft={x:e[0],y:e[1]},f={x:r.attrs.x+St/2,y:r.attrs.y+St/2},i=ft.y-f.y,o=ft.x-f.x,(b=Math.atan2(i,o)/Math.PI*180)>45&&b<135?(e[2]+=St/2,e[3]+=wt):b>135&&b<180||b>-180&&b<-135?e[3]+=wt/2:b>-135&&b<-45?e[2]+=St/2:(e[2]+=wt,e[3]+=wt/2)}return e},a}return Object(o.a)(e,t),Object(s.a)(e,[{key:\"render\",value:function(){var t=null;if(this.props.current&&this.props.from){var e={points:t=[this.props.from.attrs.x,this.props.from.attrs.y,this.props.arrowEndX,this.props.arrowEndY],from:this.props.from,mouseX:this.props.arrowEndX,mouseY:this.props.arrowEndY,type:\"onlyFrom\"};t=this.getConnectorPoints(e)}if(!1===this.props.current)if(this.props.from&&this.props.to){var a={points:t=[this.props.from.attrs.x,this.props.from.attrs.y,this.props.to.attrs.x,this.props.to.attrs.y],from:this.props.from,to:this.props.to,type:\"FromAndTo\"};t=this.getConnectorPoints(a)}else if(this.props.from){var r={points:t=[this.props.from.attrs.x,this.props.from.attrs.y,this.props.points[2],this.props.points[3]],from:this.props.from,mouseX:this.props.points[2],mouseY:this.props.points[3],type:\"onlyFrom\"};t=this.getConnectorPoints(r)}else if(this.props.to){var s={points:t=[this.props.points[0],this.props.points[1],this.props.to.attrs.x,this.props.to.attrs.y],to:this.props.to,type:\"onlyTo\",mouseX:this.props.to.attrs.x,mouseY:this.props.to.attrs.y};t=this.getConnectorPoints(s)}return h.a.createElement(w.Arrow,{name:this.props.name,points:t,strokeWidth:1.5,stroke:this.props.stroke,fill:this.props.fill})}}]),e}(l.Component),v=function(){return h.a.createElement(w.Rect,{y:80,width:77.5,height:355,fill:\"white\",shadowBlur:5,shadowColor:\"black\"})},k=function(t){function e(){var t,a;Object(r.a)(this,e);for(var s=arguments.length,o=new Array(s),l=0;l<s;l++)o[l]=arguments[l];return(a=Object(n.a)(this,(t=Object(i.a)(e)).call.apply(t,[this].concat(o)))).state={arrowDraggable:!1,previousShape:void 0,count:0,isDragging:!1},a}return Object(o.a)(e,t),Object(s.a)(e,[{key:\"render\",value:function(){var t=this;return h.a.createElement(h.a.Fragment,null,this.props.layer?h.a.createElement(h.a.Fragment,null,h.a.createElement(v,null),h.a.createElement(w.Ellipse,{radiusX:20,radiusY:20,stroke:\"black\",strokeWidth:1.5,x:37.5,y:125}),h.a.createElement(w.Ellipse,{radiusX:20,radiusY:20,stroke:\"black\",strokeWidth:1.5,x:37.5,y:125,draggable:!0,ref:\"draggableEllipse\",onDragEnd:function(e){var a=\"ellipse\"+t.props.ellipseName,r={x:e.target.x(),y:e.target.y(),radiusX:20,radiusY:20,stroke:\"black\",strokeWidth:1.5,name:a,fill:\"white\",ref:a,rotation:0};t.props.appendToEllipses(r),t.refs.draggableEllipse.position({x:37.5,y:125})}}),h.a.createElement(w.Rect,{width:35,height:35,stroke:\"black\",strokeWidth:1.5,x:20,y:180,fill:\"white\"}),h.a.createElement(w.Rect,{width:35,height:35,stroke:\"black\",strokeWidth:1.5,x:20,y:180,draggable:!0,fill:\"white\",ref:\"draggableRect\",onDragEnd:function(e){var a=\"rectangle\"+t.props.rectName,r={x:e.target.x(),y:e.target.y(),width:35,height:35,stroke:\"black\",strokeWidth:1.5,rotation:0,name:a,ref:a,fill:\"white\",useImage:!1};t.props.appendToRectangles(r),t.refs.draggableRect.position({x:20,y:180})}}),h.a.createElement(w.Star,{innerRadius:8,outerRadius:20,numPoints:5,stroke:\"black\",strokeWidth:1.5,x:37.5,y:270,fill:\"white\"}),h.a.createElement(w.Star,{innerRadius:8,outerRadius:20,numPoints:5,stroke:\"black\",strokeWidth:1.5,x:37.5,y:270,draggable:!0,ref:\"draggableStar\",onDragEnd:function(e){var a=\"star\"+t.props.starName,r={x:e.target.x(),y:e.target.y(),innerRadius:8,outerRadius:20,numPoints:5,stroke:\"black\",strokeWidth:1.5,name:a,fill:\"white\",ref:a,rotation:0};t.props.appendToStars(r),t.refs.draggableStar.position({x:37.5,y:270})}}),h.a.createElement(w.Text,{fontSize:40,text:\"T\",fontFamily:\"Belgrano\",x:24,y:320}),h.a.createElement(w.Text,{fontSize:40,text:\"T\",fontFamily:\"Belgrano\",x:24,y:320,draggable:!0,ref:\"draggableText\",onDragEnd:function(e){var a=\"text\"+t.props.textName,r=\"text\"+t.props.textName,s={x:e.target.x(),y:e.target.y(),fontSize:25,fontFamily:\"Belgrano\",ref:r,name:a,text:\"\",fill:\"black\",width:300,height:25,rotation:0,textWidth:t.refs.draggableText.textWidth,textHeight:t.refs.draggableText.textHeight};console.log(\"tosend\",s),t.props.appendToTexts(s),t.refs.draggableText.position({x:24,y:320})}}),h.a.createElement(w.Arrow,{points:[20,400,50,400],fill:\"black\",stroke:\"black\"}),h.a.createElement(w.Arrow,{points:[20,400,50,400],fill:\"black\",stroke:\"black\",ref:\"draggableArrow\",name:\"draggableArrow\",draggable:!0,onDragStart:function(){t.refs.draggableArrow.setAttr(\"fill\",\"grey\"),t.refs.draggableArrow.setAttr(\"stroke\",\"grey\")},onDragMove:function(){var e=t.props.layer.getStage().getPointerPosition(),a=t.props.layer.getIntersection(e);void 0!==t.state.previousShape&&null!==t.state.previousShape&&(t.state.previousShape!==a?\"ContainerRect\"===t.state.previousShape.attrs.id||t.state.previousShape.attrs.name.includes(\"arrow\")||(t.refs.draggableArrow.setAttr(\"fill\",\"black\"),t.refs.draggableArrow.setAttr(\"stroke\",\"black\")):\"ContainerRect\"===t.state.previousShape.attrs.id||a.attrs.name.includes(\"arrow\")||(t.refs.draggableArrow.setAttr(\"fill\",\"#ccf5ff\"),t.refs.draggableArrow.setAttr(\"stroke\",\"#ccf5ff\"))),t.props.layer.draw(),t.setState({previousShape:a})},onDragEnd:function(e){var a=t.props.layer.getStage().getPointerPosition(),r=t.props.layer.getIntersection(a);if(r&&void 0===r.attrs.id&&!r.attrs.name.includes(\"arrow\")){var s={x:a.x,y:a.y,points:[20,475,60,475],from:r,stroke:\"black\",strokeWidth:\"1.5\",fill:\"black\"};console.log(\"from shape\",r),t.props.newArrowOnDragEnd(s)}else{var n={x:a.x,y:a.y,points:[20,475,60,475],stroke:\"black\",strokeWidth:\"1.5\",fill:\"black\"};t.props.newArrowOnDragEnd(n)}var i=t.refs.draggableArrow;i.position({x:0,y:0}),i.setAttr(\"fill\",\"black\"),i.setAttr(\"stroke\",\"black\"),i.draw()}})):null)}}]),e}(l.Component),M=(a(97),function(t){function e(){return Object(r.a)(this,e),Object(n.a)(this,Object(i.a)(e).apply(this,arguments))}return Object(o.a)(e,t),Object(s.a)(e,[{key:\"componentDidMount\",value:function(){this.checkNode()}},{key:\"componentDidUpdate\",value:function(){this.checkNode()}},{key:\"checkNode\",value:function(){var t=this.transformer.getStage(),e=this.props.selectedShapeName;if(\"\"!==e){var a=t.findOne(\".\"+e);a!==this.transformer.node()&&(a?this.transformer.attachTo(a):this.transformer.detach(),this.transformer.getLayer().batchDraw())}else this.transformer.detach()}},{key:\"render\",value:function(){var t=this;if(this.props.selectedShapeName.includes(\"text\"))var e=h.a.createElement(w.Transformer,{ref:function(e){t.transformer=e},name:\"transformer\",boundBoxFunc:function(t,e){return e.width=Math.max(30,e.width),e},enabledAnchors:[\"middle-left\",\"middle-right\"]});else if(this.props.selectedShapeName.includes(\"star\"))e=h.a.createElement(w.Transformer,{ref:function(e){t.transformer=e},name:\"transformer\",enabledAnchors:[\"top-left\",\"top-right\",\"bottom-left\",\"bottom-right\"]});else if(this.props.selectedShapeName.includes(\"arrow\"))e=h.a.createElement(w.Transformer,{ref:function(e){t.transformer=e},name:\"transformer\",resizeEnabled:!1,rotateEnabled:!1});else e=h.a.createElement(w.Transformer,{ref:function(e){t.transformer=e},name:\"transformer\",keepRatio:!0});return e}}]),e}(h.a.Component)),b=[],E=0,P=function(t){function e(t){var a;return Object(r.a)(this,e),(a=Object(n.a)(this,Object(i.a)(e).call(this,t))).handleSave=function(){var t=a.state.rectangles,e=a.state.ellipses,r=a.state.stars,s=a.state.texts,n=a.state.arrows;if(JSON.stringify(a.state.saved)!==JSON.stringify([t,e,r,s,n])){a.setState({saved:[t,e,r,s,n]});var i=a.state.arrows;i.forEach(function(t){t.from&&t.from.attrs&&t.from.attrs.name.includes(\"text\")&&(t.from.textWidth=t.from.textWidth,t.from.textHeight=t.from.textHeight),t.to&&t.to.attrs&&t.to.attrs.name.includes(\"text\")&&(t.to.attrs.textWidth=t.to.textWidth,t.to.attrs.textHeight=t.to.textHeight)}),a.state.roadmapId?(a.setState({saving:!0}),fetch(\"/api/roadmap/modifyDraftDB\",{method:\"POST\",headers:{\"Content-Type\":\"application/json\"},body:JSON.stringify({roadmapId:a.state.roadmapId,data:{rects:t,ellipses:e,stars:r,texts:s,arrows:i}})}).then(function(t){a.setState({saving:!1})})):(a.setState({saving:!0}),fetch(\"/api/roadmap/saveRoadmapToDB\",{method:\"POST\",headers:{\"Content-Type\":\"application/json\"},body:JSON.stringify({userId:a.props.auth.user.id,roadmapType:\"draft\",data:{rects:t,ellipses:e,stars:r,texts:s,arrows:n}})}).then(function(t){return t.json().then(function(t){a.setState({saving:!1}),a.setState({roadmapId:t.roadmapId})})}))}},a.handleStageClick=function(t){var e=a.refs.layer2.getStage().getPointerPosition(),r=a.refs.layer2.getIntersection(e);console.log(\"texts\",a.state.texts),null!==r&&void 0!==r.name()&&void 0!==r&&void 0!==r.name()&&a.setState({selectedShapeName:r.name()},function(){a.refs.graphicStage.draw()}),\"\"!==a.state.newArrowRef&&(a.state.previousShape&&\"ContainerRect\"!==a.state.previousShape.attrs.id&&a.state.arrows.map(function(t){t.name===a.state.newArrowRef&&(t.to=a.state.previousShape)}),a.state.arrows.map(function(t){t.name===a.state.newArrowRef&&(t.fill=\"black\",t.stroke=\"black\")}),a.setState({arrowDraggable:!1,newArrowRef:\"\"}))},a.handleMouseOver=function(t){var e=a.refs.graphicStage.getPointerPosition(),r=a.refs.graphicStage.getIntersection(e);if(r&&r.attrs.link?document.body.style.cursor=\"pointer\":document.body.style.cursor=\"default\",\"\"!==a.state.newArrowRef){var s=a.refs.layer2.getAbsoluteTransform().copy();s.invert(),e=s.point(e),a.setState({arrowEndX:e.x,arrowEndY:e.y}),r&&r.attrs&&void 0!=r.attrs.name&&(r.attrs.name.includes(\"arrow\")||a.state.previousShape&&a.state.previousShape!==r&&(\"ContainerRect\"!==a.state.previousShape.attrs.id?(a.state.arrows.map(function(t){t.name===a.state.newArrowRef&&(t.fill=\"black\",t.stroke=\"black\")}),a.forceUpdate()):(a.state.arrows.map(function(t){t.name===a.state.newArrowRef&&(t.fill=\"#ccf5ff\",t.stroke=\"#ccf5ff\")}),a.forceUpdate())),r.attrs.name.includes(\"arrow\")||a.setState({previousShape:r}))}var n=a.state.arrows;n.map(function(t){if(t.name===a.state.newArrowRef){var r=n.indexOf(t),s=t;s.points=[s.points[0],s.points[1],e.x,e.y],a.state.arrows[r]=s}})},a.handleUndo=function(){if(!a.state.isTransforming&&!a.state.textEditVisible){if(0===E)return;E-=1,a.setState({rectangles:b[E].rectangles,arrows:b[E].arrows,ellipses:b[E].ellipses,stars:b[E].stars,texts:b[E].texts,connectors:b[E].connectors,redoing:!0,selectedShapeName:a.shapeIsGone(b[E])?\"\":a.state.selectedShapeName},function(){a.refs.graphicStage.draw()})}},a.handleRedo=function(){if(E!==b.length-1){var t=b[E+=1];a.setState({rectangles:t.rectangles,arrows:t.arrows,ellipses:t.ellipses,stars:t.stars,texts:t.texts,redoing:!0,selectedShapeName:a.shapeIsGone(b[E])?\"\":a.state.selectedShapeName},function(){a.forceUpdate()})}},a.shapeIsGone=function(t){var e=!0,r=a.state.selectedShapeName,s=[t.rectangles,t.ellipses,t.stars,t.arrows,t.texts],n=s[1],i=s[2],o=s[3],l=s[4];return s[0].map(function(t){t.name===r&&(e=!1)}),n.map(function(t){t.name===r&&(e=!1)}),i.map(function(t){t.name===r&&(e=!1)}),o.map(function(t){t.name===r&&(e=!1)}),l.map(function(t){t.name===r&&(e=!1)}),e},a.IsJsonString=function(t){try{JSON.parse(t)}catch(e){return!1}return!0},a.state={layerX:0,layerY:0,layerScale:1,selectedShapeName:\"\",errMsg:\"\",rectangles:[],ellipses:[],stars:[],texts:[],arrows:[],connectors:[],currentTextRef:\"\",shouldTextUpdate:!0,textX:0,textY:0,textEditVisible:!1,arrowDraggable:!1,newArrowRef:\"\",count:0,newArrowDropped:!1,newConnectorDropped:!1,arrowEndX:0,arrowEndY:0,isTransforming:!1,lastFill:null,saving:null,saved:[],roadmapId:null,alreadyCreated:!1,publishing:!1,title:\"\",category:\"\",description:\"\",thumbnail:\"\",isPasteDisabled:!1,ellipseDeleteCount:0,starDeleteCount:0,arrowDeleteCount:0,textDeleteCount:0,rectDeleteCount:0},a.handleWheel=a.handleWheel.bind(Object(y.a)(Object(y.a)(a))),a}return Object(o.a)(e,t),Object(s.a)(e,[{key:\"handleWheel\",value:function(t){if(0===this.state.rectangles.length&&0===this.state.ellipses.length&&0===this.state.stars.length&&0===this.state.texts.length&&0===this.state.arrows.length);else{t.evt.preventDefault();var e=this.refs.graphicStage,a=this.refs.layer2,r=a.scaleX(),s={x:e.getPointerPosition().x/r-this.state.layerX/r,y:e.getPointerPosition().y/r-this.state.layerY/r},n=t.evt.deltaY<0?1.2*r:r/1.2;a.scale({x:n,y:n}),this.setState({layerScale:n,layerX:-(s.x-e.getPointerPosition().x/n)*n,layerY:-(s.y-e.getPointerPosition().y/n)*n})}}},{key:\"componentDidUpdate\",value:function(t,e){var a=[e.rectangles,e.ellipses,e.stars,e.arrows,e.connectors,e.texts],r=[this.state.rectangles,this.state.ellipses,this.state.stars,this.state.arrows,this.state.connectors,this.state.texts];if(!this.state.redoing&&!this.state.isTransforming&&JSON.stringify(this.state)!==JSON.stringify(e)&&JSON.stringify(a)!==JSON.stringify(r)&&this.state.shouldTextUpdate){b=b.slice(0,E+1);var s=this.state;b=b.concat(s),E+=1}this.state.redoing=!1}},{key:\"componentDidMount\",value:function(){var t=Object(x.a)(g.a.mark(function t(){return g.a.wrap(function(t){for(;;)switch(t.prev=t.next){case 0:b.push(this.state),this.setState({selectedShapeName:\"\"});case 2:case\"end\":return t.stop()}},t,this)}));return function(){return t.apply(this,arguments)}}()},{key:\"render\",value:function(){var t=this,e=this.state.saving;null!==e&&(e?h.a.createElement(\"div\",{style:{color:\"white\"}},\"Saving\"):h.a.createElement(\"div\",{style:{color:\"white\"}},\"Saved\"));var a=document.createElement(\"canvas\").getContext(\"2d\").createLinearGradient(0,0,100,100);a.addColorStop(0,\"red\"),a.addColorStop(1/6,\"orange\"),a.addColorStop(2/6,\"yellow\"),a.addColorStop(.5,\"green\"),a.addColorStop(4/6,\"aqua\"),a.addColorStop(5/6,\"blue\"),a.addColorStop(1,\"purple\");var r,s=this.state.errMsg;\"\"!==s&&(r=h.a.createElement(\"div\",{className:\"errMsginner\"},h.a.createElement(\"span\",{style:{color:\"white\"}},\"\"!==s?s:null)));return h.a.createElement(h.a.Fragment,null,h.a.createElement(\"div\",{onKeyDown:function(e){if((e.ctrlKey&&88===e.keyCode||46===e.keyCode)&&!t.state.isPasteDisabled){if(\"\"!==t.state.selectedShapeName){var a=t,r=t.state.selectedShapeName,s=t.state.rectangles.filter(function(t){return t.name===r&&a.setState({rectDeleteCount:a.state.rectDeleteCount+1}),t.name!==r}),n=t.state.ellipses.filter(function(t){return t.name===r&&a.setState({ellipseDeleteCount:a.state.ellipseDeleteCount+1}),t.name!==r}),i=t.state.stars.filter(function(t){return t.name===r&&a.setState({starDeleteCount:a.state.starDeleteCount+1}),t.name!==r}),o=t.state.arrows.filter(function(t){return t.name===r&&a.setState({arrowDeleteCount:a.state.arrowDeleteCount+1}),t.name!==r}),l=t.state.texts.filter(function(t){return t.name===r&&a.setState({textDeleteCount:a.state.textDeleteCount+1}),t.name!==r});t.setState({rectangles:s,ellipses:n,stars:i,arrows:o,texts:l,selectedShapeName:\"\"})}}else if(e.shiftKey&&e.ctrlKey&&90===e.keyCode)t.handleRedo();else if(e.ctrlKey&&90===e.keyCode)t.handleUndo();else if(e.ctrlKey&&89===e.keyCode)t.handleRedo();else if(e.ctrlKey&&67===e.keyCode){if(\"\"!==t.state.selectedShapeName){var h=t.state.selectedShapeName,c=null;h.includes(\"rect\")?c=t.state.rectangles.filter(function(t){return t.name===h}):h.includes(\"ellipse\")?c=t.state.ellipses.filter(function(t){return t.name===h}):h.includes(\"star\")?c=t.state.stars.filter(function(t){return t.name===h}):h.includes(\"text\")?c=t.state.texts.filter(function(t){return t.name===h}):h.includes(\"arrow\")&&(c=t.state.arrows.filter(function(t){return t.name===h})),t.setState({copiedElement:c},function(){console.log(\"copied ele\",t.state.copiedElement)})}}else if(e.ctrlKey&&86===e.keyCode&&!t.state.isPasteDisabled){var d=t.state.copiedElement[0];if(console.log(d),d)if(d.attrs);else if(d.name.includes(\"rectangle\")){t.state.rectangles.length+1+t.state.rectDeleteCount;var f={x:d.x+10,y:d.y+10,width:d.width,height:d.height,stroke:d.stroke,strokeWidth:d.strokeWidth,name:\"rectangle\"+(t.state.rectangles.length+t.state.rectDeleteCount+1),ref:\"rectangle\"+(t.state.rectangles.length+t.state.rectDeleteCount+1),fill:d.fill,useImage:d.useImage,link:d.link,rotation:d.rotation};t.state.selectedShapeName;t.setState(function(t){return{rectangles:[].concat(Object(p.a)(t.rectangles),[f])}},function(){t.setState({selectedShapeName:\"rectangle\"+t.state.rectangles.length})})}else if(d.name.includes(\"arrow\"))if(t.state.arrows.length+1+t.state.arrowDeleteCount,d.to||d.from)t.setState({errMsg:\"Connectors cannot be pasted\"},function(){var e=t;setTimeout(function(){e.setState({errMsg:\"\"})},1e3)});else{f={points:[d.points[0]+30,d.points[1]+30,d.points[2]+30,d.points[3]+30],fill:d.fill,link:d.link,stroke:d.stroke,strokeWidth:d.strokeWidth,name:\"arrow\"+(t.state.arrows.length+1+t.state.arrowDeleteCount),ref:\"arrow\"+(t.state.arrows.length+1+t.state.arrowDeleteCount),rotation:d.rotation},t.state.selectedShapeName;t.setState(function(t){return{arrows:[].concat(Object(p.a)(t.arrows),[f])}},function(){t.setState({selectedShapeName:\"arrow\"+t.state.arrows.length})})}else if(d.name.includes(\"ellipse\")){t.state.ellipses.length+1+t.state.ellipseDeleteCount;f={x:d.x+10,y:d.y+10,radiusX:d.radiusX,radiusY:d.radiusY,stroke:d.stroke,strokeWidth:d.strokeWidth,name:\"ellipse\"+(t.state.ellipses.length+1+t.state.ellipseDeleteCount),ref:\"ellipse\"+(t.state.ellipses.length+1+t.state.ellipseDeleteCount),fill:d.fill,link:d.link,useImage:d.useImage,rotation:d.rotation},t.state.selectedShapeName;t.setState(function(t){return{ellipses:[].concat(Object(p.a)(t.ellipses),[f])}},function(){t.setState({selectedShapeName:\"ellipse\"+t.state.ellipses.length})})}else if(d.name.includes(\"star\")){t.state.stars.length+1+t.state.starDeleteCount;f={x:d.x+10,y:d.y+10,link:d.link,innerRadius:d.innerRadius,outerRadius:d.outerRadius,stroke:d.stroke,strokeWidth:d.strokeWidth,name:\"star\"+(t.state.stars.length+1+t.state.starDeleteCount),ref:\"star\"+(t.state.stars.length+1+t.state.starDeleteCount),fill:d.fill,useImage:d.useImage,rotation:d.rotation},t.state.selectedShapeName;t.setState(function(t){return{stars:[].concat(Object(p.a)(t.stars),[f])}},function(){t.setState({selectedShapeName:\"star\"+t.state.stars.length})})}else if(d.name.includes(\"text\")){t.state.texts.length+1+t.state.textDeleteCount;f={x:d.x+10,y:d.y+10,link:d.link,name:\"text\"+(t.state.texts.length+1+t.state.textDeleteCount),ref:\"text\"+(t.state.texts.length+1+t.state.textDeleteCount),fill:d.fill,fontSize:d.fontSize,fontFamily:d.fontFamily,useImage:d.useImage,text:d.text,width:d.width,rotation:d.rotation},t.state.selectedShapeName;t.setState(function(t){return{texts:[].concat(Object(p.a)(t.texts),[f])}},function(){t.setState({selectedShapeName:\"text\"+(t.state.texts.length+t.state.textDeleteCount)},function(){console.log(t.state.selectedShapeName)})})}}},tabIndex:\"0\",style:{outline:\"none\"}},h.a.createElement(w.Stage,{onClick:this.handleStageClick,onMouseMove:this.handleMouseOver,onWheel:function(e){return t.handleWheel(e)},height:window.innerHeight,width:window.innerWidth,ref:\"graphicStage\"},h.a.createElement(w.Layer,{scaleX:this.state.layerScale,scaleY:this.state.layerScale,x:this.state.layerX,y:this.state.layerY,height:window.innerHeight,width:window.innerWidth,draggable:!0,onDragEnd:function(){t.setState({layerX:t.refs.layer2.x(),layerY:t.refs.layer2.y()})},ref:\"layer2\"},h.a.createElement(w.Rect,{x:-5*window.innerWidth,y:-5*window.innerHeight,height:10*window.innerHeight,width:10*window.innerWidth,name:\"\",id:\"ContainerRect\"}),this.state.rectangles.map(function(e){return h.a.createElement(w.Rect,{onClick:function(){var a=t;void 0!==e.link&&\"\"!==e.link&&t.setState({errMsg:\"Links will not be opened in create mode\"},function(){setTimeout(function(){a.setState({errMsg:\"\"})},1e3)})},onTransformStart:function(){t.setState({isTransforming:!0});var a=t.refs[e.ref];a.setAttr(\"lastRotation\",a.rotation())},onTransform:function(){var a=t.refs[e.ref];a.attrs.lastRotation!==a.rotation()&&t.state.arrows.map(function(e){e.to&&e.to.name()===a.name()&&t.setState({errMsg:\"Rotating rects with connectors might skew things up!\"}),e.from&&e.from.name()===a.name()&&t.setState({errMsg:\"Rotating rects with connectors might skew things up!\"})}),a.setAttr(\"lastRotation\",a.rotation())},onTransformEnd:function(){t.setState({isTransforming:!1});var a=t.refs[e.ref];t.setState(function(t){return{errMsg:\"\",rectangles:t.rectangles.map(function(t){return t.name===a.attrs.name?Object(u.a)({},t,{width:a.width()*a.scaleX(),height:a.height()*a.scaleY(),rotation:a.rotation(),x:a.x(),y:a.y()}):t})}},function(){t.forceUpdate()}),a.setAttr(\"scaleX\",1),a.setAttr(\"scaleY\",1)},rotation:e.rotation,ref:e.ref,fill:e.fill,name:e.name,x:e.x,y:e.y,width:e.width,height:e.height,stroke:e.stroke,strokeWidth:e.strokeWidth,strokeScaleEnabled:!1,draggable:!0,onDragMove:function(){t.state.arrows.map(function(a){void 0!==a.from&&e.name===a.from.attrs.name&&(a.points=[e.x,e.y,a.points[2],a.points[3]],t.forceUpdate()),void 0!==a.to&&e.name==a.to.attrs.name&&(a.points=[a.points[0],a.points[1],e.x,e.y],t.forceUpdate())})},onDragEnd:function(a){var r=t.refs[e.ref];t.setState(function(t){return{rectangles:t.rectangles.map(function(t){return t.name===r.attrs.name?Object(u.a)({},t,{x:a.target.x(),y:a.target.y()}):t})}})}})}),this.state.ellipses.map(function(e){return h.a.createElement(w.Ellipse,{ref:e.ref,name:e.name,x:e.x,y:e.y,rotation:e.rotation,radiusX:e.radiusX,radiusY:e.radiusY,fill:e.fill,stroke:e.stroke,strokeWidth:e.strokeWidth,strokeScaleEnabled:!1,onClick:function(){var a=t;void 0!==e.link&&\"\"!==e.link&&t.setState({errMsg:\"Links will not be opened in create mode\"},function(){setTimeout(function(){a.setState({errMsg:\"\"})},1e3)})},onTransformStart:function(){t.setState({isTransforming:!0});var a=t.refs[e.ref];a.setAttr(\"lastRotation\",a.rotation())},onTransform:function(){var a=t.refs[e.ref];a.attrs.lastRotation!==a.rotation()&&t.state.arrows.map(function(e){e.to&&e.to.name()===a.name()&&t.setState({errMsg:\"Rotating ellipses with connectors might skew things up!\"}),e.from&&e.from.name()===a.name()&&t.setState({errMsg:\"Rotating ellipses with connectors might skew things up!\"})}),a.setAttr(\"lastRotation\",a.rotation())},onTransformEnd:function(){t.setState({isTransforming:!1});var a=t.refs[e.ref];a.scaleX(),a.scaleY();t.setState(function(t){return{errMsg:\"\",ellipses:t.ellipses.map(function(t){return t.name===a.attrs.name?Object(u.a)({},t,{radiusX:a.radiusX()*a.scaleX(),radiusY:a.radiusY()*a.scaleY(),rotation:a.rotation(),x:a.x(),y:a.y()}):t})}}),a.setAttr(\"scaleX\",1),a.setAttr(\"scaleY\",1),t.forceUpdate()},draggable:!0,onDragMove:function(){console.log(\"name of ellipse moving: \",e.name,\"new x y\",e.x,e.y),t.state.arrows.map(function(a){void 0!==a.from&&(console.log(\"prevArrow: \",a.points),e.name==a.from.attrs.name&&(a.points=[e.x,e.y,a.points[2],a.points[3]],t.forceUpdate(),t.refs.graphicStage.draw()),console.log(\"new arrows:\",a.points)),void 0!==a.to&&e.name===a.to.attrs.name&&(a.points=[a.points[0],a.points[1],e.x,e.y],t.forceUpdate(),t.refs.graphicStage.draw())})},onDragEnd:function(a){var r=t.refs[e.ref];t.setState(function(t){return{ellipses:t.ellipses.map(function(t){return t.name===r.attrs.name?Object(u.a)({},t,{x:a.target.x(),y:a.target.y()}):t})}}),t.refs.graphicStage.draw()}})}),this.state.stars.map(function(e){return h.a.createElement(w.Star,{ref:e.ref,name:e.name,x:e.x,y:e.y,innerRadius:e.innerRadius,outerRadius:e.outerRadius,numPoints:e.numPoints,stroke:e.stroke,strokeWidth:e.strokeWidth,fill:e.fill,strokeScaleEnabled:!1,rotation:e.rotation,onClick:function(){var a=t;void 0!==e.link&&\"\"!==e.link&&t.setState({errMsg:\"Links will not be opened in create mode\"},function(){setTimeout(function(){a.setState({errMsg:\"\"})},1e3)})},onTransformStart:function(){t.setState({isTransforming:!0})},onTransformEnd:function(){t.setState({isTransforming:!1});var a=t.refs[e.ref];a.scaleX(),a.scaleY();t.setState(function(t){return{stars:t.stars.map(function(t){return t.name===a.attrs.name?Object(u.a)({},t,{innerRadius:a.innerRadius()*a.scaleX(),outerRadius:a.outerRadius()*a.scaleX(),rotation:a.rotation(),x:a.x(),y:a.y()}):t})}}),a.setAttr(\"scaleX\",1),a.setAttr(\"scaleY\",1),t.forceUpdate()},draggable:!0,onDragMove:function(){t.state.arrows.map(function(a){void 0!==a.from&&e.name==a.from.attrs.name&&(a.points=[e.x,e.y,a.points[2],a.points[3]],t.forceUpdate()),void 0!==a.to&&e.name===a.to.attrs.name&&(a.points=[a.points[0],a.points[1],e.x,e.y],t.forceUpdate())})},onDragEnd:function(a){var r=t.refs[e.ref];t.setState(function(t){return{stars:t.stars.map(function(t){return t.name===r.attrs.name?Object(u.a)({},t,{x:a.target.x(),y:a.target.y()}):t})}})}})}),this.state.texts.map(function(e){return h.a.createElement(w.Text,{textDecoration:e.link?\"underline\":\"\",onTransformStart:function(){var e=t.refs[t.state.selectedShapeName];e.setAttr(\"lastRotation\",e.rotation())},onTransform:function(){var e=t.refs[t.state.selectedShapeName];e.setAttr(\"width\",e.width()*e.scaleX()),e.setAttr(\"scaleX\",1),e.draw(),e.attrs.lastRotation!==e.rotation()&&t.state.arrows.map(function(a){a.to&&a.to.name()===e.name()&&t.setState({errMsg:\"Rotating texts with connectors might skew things up!\"}),a.from&&a.from.name()===e.name()&&t.setState({errMsg:\"Rotating texts with connectors might skew things up!\"})}),e.setAttr(\"lastRotation\",e.rotation())},onTransformEnd:function(){var e=t.refs[t.state.selectedShapeName];t.setState(function(a){return{errMsg:\"\",texts:a.texts.map(function(a){return a.name===t.state.selectedShapeName?Object(u.a)({},a,{width:e.width(),rotation:e.rotation(),textWidth:e.textWidth,textHeight:e.textHeight,x:e.x(),y:e.y()}):a})}}),e.setAttr(\"scaleX\",1),e.draw()},link:e.link,width:e.width,fill:e.fill,name:e.name,ref:e.ref,rotation:e.rotation,fontFamily:e.fontFamily,fontSize:e.fontSize,x:e.x,y:e.y,text:e.text,draggable:!0,onDragMove:function(){t.state.arrows.map(function(a){void 0!==a.from&&e.name===a.from.attrs.name&&(a.points=[e.x,e.y,a.points[2],a.points[3]],t.forceUpdate()),void 0!==a.to&&e.name===a.to.attrs.name&&(a.points=[a.points[0],a.points[1],e.x,e.y],t.forceUpdate())})},onDragEnd:function(a){var r=t.refs[e.ref];t.setState(function(t){return{texts:t.texts.map(function(t){return t.name===r.attrs.name?Object(u.a)({},t,{x:a.target.x(),y:a.target.y()}):t})}})},onClick:function(){var a=t;void 0!==e.link&&\"\"!==e.link&&t.setState({errMsg:\"Links will not be opened in create mode\"},function(){setTimeout(function(){a.setState({errMsg:\"\"})},1e3)})},onDblClick:function(){var a=t.refs.graphicStage,r=a.findOne(\".\"+e.name);t.setState({textX:r.absolutePosition().x,textY:r.absolutePosition().y,textEditVisible:!t.state.textEditVisible,text:e.text,textNode:e,currentTextRef:e.ref,textareaWidth:r.textWidth,textareaHeight:r.textHeight,textareaFill:r.attrs.fill,textareaFontFamily:r.attrs.fontFamily,textareaFontSize:r.attrs.fontSize}),t.refs.textarea.focus(),r.hide(),a.findOne(\".transformer\").hide(),t.refs.layer2.draw()}})}),this.state.arrows.map(function(e){return e.from||e.to?e.name===t.state.newArrowRef&&(e.from||e.to)?h.a.createElement(S,{name:e.name,from:e.from,to:e.to,arrowEndX:t.state.arrowEndX,arrowEndY:t.state.arrowEndY,current:!0,stroke:e.stroke,fill:e.fill}):e.from||e.to?h.a.createElement(S,{name:e.name,from:e.from,to:e.to,points:e.points,current:!1,stroke:e.stroke,fill:e.fill}):void 0:h.a.createElement(w.Arrow,{ref:e.ref,name:e.name,points:[e.points[0],e.points[1],e.points[2],e.points[3]],stroke:e.stroke,fill:e.fill,draggable:!0,onDragEnd:function(a){var r=[e.points[0],e.points[1],e.points[2],e.points[3]],s=t.refs[e.ref].attrs.x,n=t.refs[e.ref].attrs.y,i=[r[0]+s,r[1]+n,r[2]+s,r[3]+n];t.refs[e.ref].position({x:0,y:0}),t.refs.layer2.draw(),t.setState(function(t){return{arrows:t.arrows.map(function(t){return t.name===e.name?Object(u.a)({},t,{points:i}):t})}})}})}),(this.state.selectedShapeName.includes(\"text\"),h.a.createElement(M,{selectedShapeName:this.state.selectedShapeName}))),h.a.createElement(w.Layer,{height:window.innerHeight,width:window.innerWidth,ref:\"layer\"},h.a.createElement(k,{layer:this.refs.layer2,rectName:this.state.rectangles.length+1+this.state.rectDeleteCount,ellipseName:this.state.ellipses.length+1+this.state.ellipseDeleteCount,starName:this.state.stars.length+1+this.state.starDeleteCount,textName:this.state.texts.length+1+this.state.textDeleteCount,newArrowOnDragEnd:function(e){if(void 0!==e.from){(s=t.refs.layer2.getAbsoluteTransform().copy()).invert();var a=s.point({x:e.x,y:e.y});e.x=a.x,e.y=a.y;var r={points:e.points,ref:\"arrow\"+(t.state.arrows.length+1+t.state.arrowDeleteCount),name:\"arrow\"+(t.state.arrows.length+1+t.state.arrowDeleteCount),from:e.from,stroke:e.stroke,strokeWidth:e.strokeWidth,fill:e.fill};t.setState(function(t){return{arrows:[].concat(Object(p.a)(t.arrows),[r]),newArrowDropped:!0,newArrowRef:r.name,arrowEndX:e.x,arrowEndY:e.y}})}else{var s;(s=t.refs.layer2.getAbsoluteTransform().copy()).invert();var n=s.point({x:e.x,y:e.y});e.x=n.x,e.y=n.y;r={points:[e.x,e.y,e.x,e.y],ref:\"arrow\"+(t.state.arrows.length+1+t.state.arrowDeleteCount),name:\"arrow\"+(t.state.arrows.length+1+t.state.arrowDeleteCount),from:e.from,stroke:e.stroke,strokeWidth:e.strokeWidth,fill:e.fill};t.setState(function(t){return{arrows:[].concat(Object(p.a)(t.arrows),[r]),newArrowDropped:!0,newArrowRef:r.name,arrowEndX:e.x,arrowEndY:e.y}})}},appendToRectangles:function(e){var a=t.refs.layer2,r=e,s=(t.refs.graphicStage,t.refs.layer2.getAbsoluteTransform().copy());s.invert();var n=s.point({x:r.x,y:r.y});null===a.attrs.x&&void 0===a.attrs.x||(r.x=n.x,r.y=n.y),t.setState(function(t){return{rectangles:[].concat(Object(p.a)(t.rectangles),[r]),selectedShapeName:r.name}})},appendToEllipses:function(e){var a=t.refs.layer2,r=e,s=(t.refs.graphicStage,t.refs.layer2.getAbsoluteTransform().copy());s.invert();var n=s.point({x:r.x,y:r.y});null===a.attrs.x&&void 0===a.attrs.x||(r.x=n.x,r.y=n.y),t.setState(function(t){return{ellipses:[].concat(Object(p.a)(t.ellipses),[r]),selectedShapeName:r.name}})},appendToStars:function(e){var a=t.refs.layer2,r=e,s=(t.refs.graphicStage,t.refs.layer2.getAbsoluteTransform().copy());s.invert();var n=s.point({x:r.x,y:r.y});null===a.attrs.x&&void 0===a.attrs.x||(r.x=n.x,r.y=n.y),t.setState(function(t){return{stars:[].concat(Object(p.a)(t.stars),[r]),selectedShapeName:r.name}})},appendToTexts:function(e){var a=t.refs.layer2,r=e,s=(t.refs.graphicStage,t.refs.layer2.getAbsoluteTransform().copy());s.invert();var n=s.point({x:r.x,y:r.y});null===a.attrs.x&&void 0===a.attrs.x||(r.x=n.x,r.y=n.y),t.setState(function(t){return{texts:[].concat(Object(p.a)(t.texts),[r])}}),t.refs[r.ref].fire(\"dblclick\")}}))),h.a.createElement(\"textarea\",{ref:\"textarea\",id:\"textarea\",value:this.state.text,onChange:function(e){t.setState({text:e.target.value,shouldTextUpdate:!1})},onKeyDown:function(e){if(13===e.keyCode){t.setState({textEditVisible:!1,shouldTextUpdate:!0});var a=t.refs[t.state.currentTextRef];console.log(\"node width before set\",a.textWidth);var r=a.attrs.name;t.setState(function(e){return{selectedShapeName:r,texts:e.texts.map(function(e){return e.name===r?Object(u.a)({},e,{text:t.state.text}):e})}},function(){t.setState(function(t){return{texts:t.texts.map(function(t){return t.name===r?Object(u.a)({},t,{textWidth:a.textWidth,textHeight:a.textHeight}):t})}})}),a.show(),t.refs.graphicStage.findOne(\".transformer\").show()}},onBlur:function(){t.setState({textEditVisible:!1,shouldTextUpdate:!0});var e=t.refs.graphicStage.findOne(\".\"+t.state.currentTextRef),a=e.attrs.name;t.setState(function(e){return{selectedShapeName:a,texts:e.texts.map(function(e){return e.name===a?Object(u.a)({},e,{text:t.state.text}):e})}},function(){t.setState(function(t){return{texts:t.texts.map(function(t){return t.name===a?Object(u.a)({},t,{textWidth:e.textWidth,textHeight:e.textHeight}):t})}})}),e.show(),t.refs.graphicStage.findOne(\".transformer\").show(),t.refs.graphicStage.draw()},style:{display:this.state.textEditVisible?\"block\":\"none\",position:\"absolute\",top:this.state.textY+80+\"px\",left:this.state.textX+\"px\",width:\"300px\",height:\"300px\",overflow:\"hidden\",fontSize:this.state.textareaFontSize,fontFamily:this.state.textareaFontFamily,color:this.state.textareaFill,border:\"none\",padding:\"0px\",margin:\"0px\",outline:\"none\",resize:\"none\",background:\"none\"}}),h.a.createElement(\"div\",{className:\"errMsg\"},r)))}}]),e}(l.Component);h.a.Component;d.a.render(h.a.createElement(P,null),document.getElementById(\"root\"))},39:function(t,e,a){t.exports=a(101)},44:function(t,e,a){},97:function(t,e,a){}},[[39,2,1]]]);","extractedComments":[]}